#!/usr/bin/env tsx
/**
 * This script generates module augmentation types for Chakra UI based on the Nimbus theme.
 *
 * It runs the Chakra CLI typegen command, then transforms the output to be
 * module augmentation declarations that ship with the nimbus package.
 *
 * This ensures consumers get proper TypeScript autocomplete for Nimbus's
 * custom recipes, tokens, and conditions without running typegen themselves.
 */

import { execSync } from "node:child_process";
import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const PACKAGE_ROOT = path.resolve(__dirname, "..");
const TEMP_DIR = path.join(PACKAGE_ROOT, ".chakra-typegen-temp");
const OUTPUT_FILE = path.join(
  PACKAGE_ROOT,
  "src",
  "theme",
  "chakra-types.gen.d.ts"
);
const THEME_FILE = path.join(PACKAGE_ROOT, "src", "theme", "index.ts");

/**
 * Files generated by chakra typegen and their required imports from @chakra-ui/react
 */
const GENERATED_FILES = {
  "recipes.gen.d.ts": {
    chakraImports: [
      "RecipeDefinition",
      "SlotRecipeDefinition",
      "SystemRecipeFn",
      "SystemSlotRecipeFn",
      "ConditionalValue",
    ],
  },
  "token.gen.d.ts": {
    chakraImports: [],
  },
  "conditions.gen.d.ts": {
    chakraImports: [],
  },
  "prop-types.gen.d.ts": {
    chakraImports: ["CssProperties"],
  },
  "system.gen.d.ts": {
    chakraImports: ["ConditionalValue", "CssProperties"],
  },
} as const;

/**
 * Transform a generated .d.ts file into module augmentation format
 */
function transformToModuleAugmentation(
  content: string,
  _filename: string
): string {
  // Remove all import statements - we'll add consolidated imports at the top
  const withoutImports = content
    .split("\n")
    .filter((line) => !line.startsWith("import "))
    .join("\n");

  // Transform exports to work within module augmentation
  // `export type X = ...` becomes just `type X = ...` (exported from module block)
  // `export interface X` becomes just `interface X`
  const transformed = withoutImports
    .replace(/^export type /gm, "export type ")
    .replace(/^export interface /gm, "export interface ");

  return transformed;
}

/**
 * Collect all unique imports needed from @chakra-ui/react
 */
function collectChakraImports(): string[] {
  const imports = new Set<string>();
  for (const config of Object.values(GENERATED_FILES)) {
    for (const imp of config.chakraImports) {
      imports.add(imp);
    }
  }
  return Array.from(imports).sort();
}

/**
 * Main function to generate the augmentation file
 */
async function main() {
  console.log(
    "üé® Generating Chakra UI type augmentations for Nimbus theme...\n"
  );

  // Clean up temp directory if it exists
  if (fs.existsSync(TEMP_DIR)) {
    fs.rmSync(TEMP_DIR, { recursive: true });
  }
  fs.mkdirSync(TEMP_DIR, { recursive: true });

  try {
    // Run chakra typegen to temp directory
    console.log("üì¶ Running chakra typegen...");
    execSync(`pnpm chakra typegen ${THEME_FILE} --outdir ${TEMP_DIR}`, {
      cwd: PACKAGE_ROOT,
      stdio: "inherit",
    });

    // Check that files were generated
    const generatedFiles = fs.readdirSync(TEMP_DIR);
    console.log(`\n‚úÖ Generated ${generatedFiles.length} type files\n`);

    // Collect all imports needed
    const chakraImports = collectChakraImports();

    // Build the output file
    const outputParts: string[] = [];

    // Add header comment
    outputParts.push(`/**
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file is generated by scripts/generate-chakra-types.ts
 * Run \`pnpm build-theme-typings\` to regenerate.
 *
 * These type augmentations provide TypeScript support for Nimbus's
 * custom Chakra UI theme (recipes, tokens, conditions, etc.)
 */

/* eslint-disable @typescript-eslint/no-empty-object-type */
`);

    // Add import for types we need to reference
    if (chakraImports.length > 0) {
      outputParts.push(
        `import type { ${chakraImports.join(", ")} } from "@chakra-ui/react";\n`
      );
    }

    // Open module declaration
    outputParts.push(`declare module "@chakra-ui/react" {`);

    // Process each generated file
    for (const filename of Object.keys(GENERATED_FILES)) {
      const filePath = path.join(TEMP_DIR, filename);
      if (!fs.existsSync(filePath)) {
        console.warn(`‚ö†Ô∏è  Warning: Expected file not found: ${filename}`);
        continue;
      }

      console.log(`  üìÑ Processing ${filename}...`);
      const content = fs.readFileSync(filePath, "utf-8");
      const transformed = transformToModuleAugmentation(content, filename);

      // Add section comment
      outputParts.push(`\n  // ============================================`);
      outputParts.push(`  // ${filename.replace(".d.ts", "")}`);
      outputParts.push(`  // ============================================\n`);

      // Indent the content for the module block
      const indentedContent = transformed
        .split("\n")
        .map((line) => (line ? `  ${line}` : line))
        .join("\n");

      outputParts.push(indentedContent);
    }

    // Close module declaration
    outputParts.push(`}\n`);

    // Write the output file
    const output = outputParts.join("\n");
    fs.writeFileSync(OUTPUT_FILE, output);
    console.log(`\n‚ú® Generated ${OUTPUT_FILE}\n`);

    // Clean up temp directory
    fs.rmSync(TEMP_DIR, { recursive: true });
    console.log("üßπ Cleaned up temp files\n");

    console.log("‚úÖ Done! Type augmentations are ready.\n");
  } catch (error) {
    console.error("‚ùå Error generating types:", error);
    // Clean up on error
    if (fs.existsSync(TEMP_DIR)) {
      fs.rmSync(TEMP_DIR, { recursive: true });
    }
    process.exit(1);
  }
}

main();
