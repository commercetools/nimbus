---
description: Create or maintain a react component
globs:
alwaysApply: false
---

# Nimbus Component Blueprint

This MDC file provides guidance for creating and maintaining components in the
Nimbus design system. Use this as a blueprint when creating new components or
maintaining existing ones.

## Component Architecture Overview

Nimbus components follow one of three primary structural patterns, each serving
a different purpose.

1.  **Single-Part Components**: Simple components that render a single element.
    They are styled using `defineRecipe` and exported as a single component.
    (e.g., `Button`, `Link`).
2.  **Multi-Part Components (Single Export)**: Components with multiple distinct
    parts (slots) that are composed internally and exported as a single React
    component. They are styled using `defineSlotRecipe`. This provides a simpler
    consumer API while managing internal complexity. (e.g., `Switch`).
3.  **Multi-Part Components (Compound Export)**: Complex components composed of
    several sub-components that are exported together as a single object (e.g.,
    `Accordion.Root`, `Accordion.Item`). This pattern uses `defineSlotRecipe`
    and offers maximum composition flexibility to the consumer. (e.g., `Alert`,
    `Accordion`).

### Core Files Structure

```
packages/nimbus/src/components/{component-name}/
├── {component-name}.tsx                # Main component implementation or compound component export
├── {component-name}.types.ts           # Consumer TypeScript interfaces and types
├── {component-name}.slots.tsx          # Chakra UI slot components and styling context
├── {component-name}.recipe.tsx         # Styling recipe with variants
├── {component-name}.stories.tsx        # Storybook stories for testing [component-stories.mdc](mdc:packages/nimbus/.cursor/rules/component-stories.mdc)
├── {component-name}.mdx                # Component documentation
├── index.ts                           # Exports
└── components/                        # Sub-components (for compound components)
    ├── {sub-component-1}.tsx
    └── {sub-component-2}.tsx
```

## Step-by-Step Component Creation Guide

### 1. Component Planning

**Input Required:**

- `componentName`: PascalCase name (e.g., "CustomButton").
- `purpose`: Clear description of component functionality.
- `element`: The primary HTML element type (e.g., "button", "div").
- `structuralType`: One of `Single-Part`, `Multi-Part (Single Export)`, or
  `Multi-Part (Compound Export)`.

### 2. File Creation Patterns

---

### Pattern 1: Single-Part Component

Used for simple components wrapping a single element.

#### A. Recipe File (`{component-name}.recipe.tsx`)

Uses `defineRecipe` for single-element styling.

```typescript
import { defineRecipe } from "@chakra-ui/react";

export const {componentName}Recipe = defineRecipe({
  className: "nimbus-{component-name}",
  base: {
    // Base styles for the component
  },
  variants: {
    // Styling variants
  },
  defaultVariants: {
    // Default variants
  },
});
```

#### B. Slots File (`{component-name}.slots.tsx`)

Uses `createRecipeContext` to create a single styled component.

```typescript
import {
  type HTMLChakraProps,
  type RecipeProps,
  type UnstyledProp,
  createRecipeContext,
} from "@chakra-ui/react";
import { {componentName}Recipe } from "./{component-name}.recipe";

interface {ComponentName}RecipeProps extends RecipeProps<"{element}">, UnstyledProp {}

export interface {ComponentName}RootProps
  extends HTMLChakraProps<"{element}", {ComponentName}RecipeProps> {}

const { withContext } = createRecipeContext({ recipe: {componentName}Recipe });

export const {ComponentName}Root = withContext<{ElementType}, {ComponentName}RootProps>(
  "{element}"
);
```

#### C. Types File (`{component-name}.types.ts`)

Exports consumer-facing props.

```typescript
import type { {ComponentName}RootProps } from "./{component-name}.slots";
import type { RecipeVariantProps } from "@chakra-ui/react";
import { {componentName}Recipe } from "./{component-name}.recipe";

type {ComponentName}VariantProps = {ComponentName}RootProps & RecipeVariantProps<typeof {componentName}Recipe>;

export interface {ComponentName}Props extends {ComponentName}VariantProps {
  children?: React.ReactNode;
  ref?: React.Ref<{ElementType}>;
}
```

#### D. Component File (`{component-name}.tsx`)

The final component, exported directly.

```typescript
import { forwardRef } from "react";
import { {ComponentName}Root } from "./{component-name}.slots";
import type { {ComponentName}Props } from "./{component-name}.types";

export const {ComponentName} = forwardRef<{ElementType}, {ComponentName}Props>(
  ({ children, ...props }, ref) => {
    return (
      <{ComponentName}Root ref={ref} {...props}>
        {children}
      </{ComponentName}Root>
    );
  }
);

{ComponentName}.displayName = "{ComponentName}";
```

---

### Pattern 2: Multi-Part Component (Single Export)

Used for components with multiple slots that are composed internally and exposed
as a single component.

#### A. Recipe File (`{component-name}.recipe.tsx`)

Uses `defineSlotRecipe` to style multiple parts. List the slots in the `slots`
array.

```typescript
import { defineSlotRecipe } from "@chakra-ui/react";

export const {componentName}SlotRecipe = defineSlotRecipe({
  slots: ["root", "slotA", "slotB"], // e.g., "root", "label", "track", "thumb"
  className: "nimbus-{component-name}",
  base: {
    root: {
      // Base styles for the root container
    },
    slotA: {
      // Base styles for the first slot
    },
    slotB: {
      // Base styles for the second slot
    },
  },
  variants: {
    // Variants affecting any of the slots
  },
});
```

#### B. Slots File (`{component-name}.slots.tsx`)

Uses `createSlotRecipeContext` to create components for each slot.

```typescript
import { createSlotRecipeContext, type HTMLChakraProps, type RecipeVariantProps } from "@chakra-ui/react";
import { {componentName}SlotRecipe } from "./{component-name}.recipe";

const { withProvider, withContext } = createSlotRecipeContext({
  recipe: {componentName}SlotRecipe,
});

export const {ComponentName}RootSlot = withProvider<HTMLElement, HTMLChakraProps<"div">>
  ("div", "root");

export const {ComponentName}SlotA = withContext<HTMLElement, HTMLChakraProps<"div">>
  ("div", "slotA");

export const {ComponentName}SlotB = withContext<HTMLElement, HTMLChakraProps<"div">>
  ("div", "slotB");
```

#### C. Types File (`{component-name}.types.ts`)

Props for the single exported component.

```typescript
import type { RecipeVariantProps } from "@chakra-ui/react";
import type { {componentName}SlotRecipe } from "./{component-name}.recipe";

export interface {ComponentName}Props
  extends RecipeVariantProps<typeof {componentName}SlotRecipe> {
  children?: React.ReactNode;
  // Other specific props...
}
```

#### D. Component File (`{component-name}.tsx`)

Internally composes the slots and exports a single component. Example based on
`Switch`.

```typescript
import { useSlotRecipe } from "@chakra-ui/react";
import type { {ComponentName}Props } from "./{component-name}.types";
import {
  {ComponentName}RootSlot,
  {ComponentName}SlotA,
  {ComponentName}SlotB,
} from "./{component-name}.slots";
import { {componentName}SlotRecipe } from "./{component-name}.recipe";

export const {ComponentName} = (props: {ComponentName}Props) => {
  const recipe = useSlotRecipe({ recipe: {componentName}SlotRecipe });
  const [variantProps, otherProps] = recipe.splitVariantProps(props);

  const classes = recipe(variantProps);

  return (
    <{ComponentName}RootSlot className={classes.root} {...otherProps}>
      <{ComponentName}SlotA className={classes.slotA}>
        {/* Content for Slot A */}
      </{ComponentName}SlotA>
      <{ComponentName}SlotB className={classes.slotB}>
        {/* Content for Slot B */}
      </{ComponentName}SlotB>
      {props.children}
    </{ComponentName}RootSlot>
  );
};

{ComponentName}.displayName = "{ComponentName}";
```

---

### Pattern 3: Multi-Part Component (Compound Export)

Used for complex components where sub-components are exposed to the consumer for
flexible composition.

#### A. Recipe File (`{component-name}.recipe.tsx`)

Uses `defineSlotRecipe`, identical to the single-export pattern.

```typescript
import { defineSlotRecipe } from "@chakra-ui/react";

export const {componentName}SlotRecipe = defineSlotRecipe({
  slots: ["root", "item", "trigger"], // Example slots
  className: "nimbus-{component-name}",
  base: {
    root: { /* ... */ },
    item: { /* ... */ },
    trigger: { /* ... */ },
  },
  // ... variants
});
```

#### B. Slots File (`{component-name}.slots.tsx`)

Uses `createSlotRecipeContext`. The resulting provider (`{ComponentName}Root`)
wraps the entire component structure.

```typescript
import { createSlotRecipeContext } from "@chakra-ui/react";
import { {componentName}SlotRecipe } from "./{component-name}.recipe";
import type {
  {ComponentName}RootProps,
  {ComponentName}ItemProps,
  {ComponentName}TriggerProps
} from './{component-name}.types'

const { withProvider, withContext } = createSlotRecipeContext({
  recipe: {componentName}SlotRecipe,
});

export const {ComponentName}Root = withProvider<HTMLDivElement, {ComponentName}RootProps>("div", "root");
export const {ComponentName}Item = withContext<HTMLDivElement, {ComponentName}ItemProps>("div", "item");
export const {ComponentName}Trigger = withContext<HTMLButtonElement, {ComponentName}TriggerProps>("button", "trigger");
```

#### C. Types File (`{component-name}.types.ts`)

Defines and exports props for each sub-component.

```typescript
import type { HTMLChakraProps, RecipeVariantProps } from "@chakra-ui/react";
import { {componentName}SlotRecipe } from "./{component-name}.recipe";

// Props for the Root component, including variants
export interface {ComponentName}RootProps extends HTMLChakraProps<"div", RecipeVariantProps<typeof {componentName}SlotRecipe>> {}

// Props for other sub-components
export interface {ComponentName}ItemProps extends HTMLChakraProps<"div"> {}
export interface {ComponentName}TriggerProps extends HTMLChakraProps<"button"> {}
```

#### D. Component File (`{component-name}.tsx`)

Exports a namespace object containing all the sub-components. Sub-components are
typically defined in the `components/` directory.

```typescript
import { {ComponentName}Root } from "./components/{component-name}.root";
import { {ComponentName}Item } from "./components/{component-name}.item";
import { {ComponentName}Trigger } from "./components/{component-name}.trigger";

// Create the namespace object for compound export
export const {ComponentName} = {
  Root: {ComponentName}Root,
  Item: {ComponentName}Item,
  Trigger: {ComponentName}Trigger,
};

// Optional: Export individual components with an underscore prefix
// for internal use or special cases like react-docgen.
export {
  {ComponentName}Root as _{ComponentName}Root,
  {ComponentName}Item as _{ComponentName}Item,
  {ComponentName}Trigger as _{ComponentName}Trigger,
};
```

### 3. Integration Steps

#### A. Update Main Components Index

Add export to `packages/nimbus/src/components/index.ts`:

```typescript
export * from "./{component-name}";
```

#### B. Update Package Exports (if needed)

Ensure the component is exported from the main package index.

### 4. Testing Checklist

- [ ] Component renders without errors
- [ ] All variants work correctly
- [ ] Props are properly typed
- [ ] Accessibility attributes are forwarded
- [ ] Ref forwarding works
- [ ] Storybook stories render and pass tests
- [ ] Documentation is complete and accurate

### 5. Common Patterns

#### For Interactive Components

- Use React Aria hooks for accessibility
- Implement proper keyboard navigation
- Add focus management
- Include ARIA attributes

#### For Form Components

- Integrate with form libraries
- Provide validation states
- Include proper labeling
- Support controlled/uncontrolled modes

#### For Layout Components

- Use Chakra UI's layout primitives
- Support responsive props
- Include proper spacing tokens

### 6. HTML Element Mapping

Common element types and their TypeScript interfaces:

```typescript
const elementMapping = {
  div: "HTMLDivElement",
  button: "HTMLButtonElement",
  input: "HTMLInputElement",
  textarea: "HTMLTextAreaElement",
  select: "HTMLSelectElement",
  a: "HTMLAnchorElement",
  p: "HTMLParagraphElement",
  span: "HTMLSpanElement",
  section: "HTMLElement",
  header: "HTMLElement",
  footer: "HTMLElement",
  main: "HTMLElement",
  nav: "HTMLElement",
  ul: "HTMLUListElement",
  ol: "HTMLOListElement",
  li: "HTMLLIElement",
  form: "HTMLFormElement",
  label: "HTMLLabelElement",
  svg: "SVGSVGElement",
};
```

### 7. Code Generation Helper

You can use the existing Hygen templates in `_templates/component/new/` to
generate the basic structure:

```bash
npx hygen component new
```

This will prompt for:

- Component name (PascalCase)
- Purpose description
- HTML element type
- Element TypeScript type

### 8. Maintenance Guidelines

#### When updating existing components:

1. Maintain backward compatibility
2. Update documentation and examples
3. Add new stories for new features
4. Update TypeScript types
5. Run full test suite
6. Update changelog

#### Performance considerations:

- always forward the ref of a component
- Minimize re-renders with proper prop handling
- use Chakra's recipe system for styling
- avoid inline styles where possible

This blueprint ensures consistency across all Nimbus components while providing
flexibility for different component types and complexities.
