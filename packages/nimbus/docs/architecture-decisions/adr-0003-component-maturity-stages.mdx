---
id: Component-Status-Stages
title: "ADR: Component Status Stages"
description: >-
  Defining status stages for exported components, hooks, functions, and other
  API surfaces
documentState: InitialDraft
order: 3
menu:
  - Home
  - ADR's
  - ADR0003 Component Status Stages
tags:
  - architecture
  - components
  - api
  - versioning
  - status
---

# ADR: Component Status Stages

## Context

As our component library evolves, we need a standardized way to communicate the
stability and status of different components, hooks, functions, and other API
surfaces to consumers. This helps:

- Set appropriate expectations about API stability
- Guide adoption decisions by consumers based on their risk tolerance
- Provide a clear pathway for components to develop and stabilize
- Create a structured process for deprecating outdated APIs

Currently, there's no formal system to indicate whether a component is
experimental, stable, or somewhere in between, which can lead to confusion for
consumers and maintainers alike.

## Decision

We will establish a standardized set of status stages for all exported APIs in
our component library. Each exported component, hook, function, or other API
will be explicitly labeled with one of these stages:

### Status Stages

1. **Experimental**

   - Early-stage implementation with minimal testing
   - No guarantees about API stability
   - May contain significant bugs or performance issues
   - May be removed without deprecation notice
   - Intended for feedback and exploration only

2. **Alpha**

   - Core functionality is implemented
   - Basic testing in place
   - API likely to change significantly
   - Known limitations and bugs may exist
   - Not recommended for production use

3. **Beta**

   - Feature complete implementation
   - Comprehensive test coverage
   - API largely stabilized, but may still change
   - Performance optimized for common use cases
   - Suitable for production use with caution

4. **Release Candidate (RC)**

   - Fully implemented and tested
   - API frozen except for critical issues
   - Performance fully optimized
   - Documentation complete
   - Safe for production use
   - Ready for final validation before GA

5. **General Availability (GA)**

   - Production-ready with full support
   - API stable with semantic versioning
   - Thoroughly tested and optimized
   - Complete documentation
   - Changes follow proper deprecation cycles

6. **Deprecated**
   - No longer recommended for use
   - May receive critical bug fixes only
   - Will be removed in a future version
   - Alternatives documented
   - Migration guide provided

### Implementation

Each exported API will be labeled with its status stage through:

1. **Code annotations**: JSDoc `@status` tag to indicate the status stage
2. **Documentation tags**: Clear indication in component documentation
3. **Visual indicators**: In the component documentation site (example pages,
   storybook, etc.)
4. **Package exports**: Possibly organizing exports by status level

We will also implement a formal process for promoting components through these
stages, including criteria for each promotion.

## Consequences

**Positive:**

- Consumers have clear expectations about component stability
- Development teams can ship experimental features with appropriate expectations
- Provides a roadmap for component development
- Creates a structured approach to API lifecycle management
- Reduces risk for consumers by clearly communicating stability
- Uses standard JSDoc convention (`@status`) that is well-recognized

**Negative:**

- Additional overhead to maintain and update status labels
- May create hesitation to use components marked with earlier status stages
- Requires discipline to properly manage the promotion process
- Additional documentation effort required

## Examples

Here's how the status stage would be documented in code and documentation:

**Code Example:**

```tsx
/**
 * @status experimental
 * This component is experimental and may change significantly.
 */
export const ExperimentalFeature = () => {
  // Implementation
};

/**
 * @status beta
 * This component is in beta. The API is mostly stable but may still change.
 */
export const BetaComponent = () => {
  // Implementation
};

/**
 * @status stable
 * This component is generally available and follows semantic versioning.
 */
export const StableComponent = () => {
  // Implementation
};

/**
 * @status deprecated
 * This component is deprecated. Use NewComponent instead.
 * @see NewComponent
 */
export const DeprecatedComponent = () => {
  // Implementation
};
```

**Documentation Example:**

```mdx
# Button Component

<StatusBadge stage="beta" />

The Button component is currently in beta. While its API is relatively stable,
minor changes may still occur before the final release.
```

## Promotion Criteria

For a component to be promoted to the next status stage, it must meet the
following criteria:

1. **Experimental → Alpha**

   - Core functionality implemented
   - Basic tests in place
   - Initial documentation available
   - Reviewed by at least one other team member

2. **Alpha → Beta**

   - Feature complete
   - Comprehensive test coverage (>80%)
   - API reviewed and approved
   - Documentation complete
   - No known major bugs

3. **Beta → Release Candidate**

   - All tests passing (>90% coverage)
   - Performance optimized
   - API frozen
   - Documentation finalized
   - Successfully used in at least one internal project

4. **Release Candidate → General Availability**
   - Successfully used in production
   - All feedback from RC addressed
   - Documentation fully reviewed
   - No open issues that affect core functionality

## Deprecation Process

When deprecating an API:

1. Mark the API as deprecated with appropriate warnings (using both
   `@status deprecated` and `@deprecated`)
2. Document the alternative approach
3. Provide a migration guide
4. Maintain the deprecated API for at least one major version cycle
5. Remove the API only after sufficient notice (typically 6-12 months)

## Summary

By implementing clear status stages for our components and APIs, we provide
necessary guidance to consumers, set appropriate expectations, and establish a
structured path for component development and evolution. Using the standard
JSDoc `@status` tag aligns with existing documentation conventions and improves
the overall developer experience for both maintainers and consumers of our
component library.
