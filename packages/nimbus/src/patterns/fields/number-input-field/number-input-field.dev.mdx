---
title: NumberInputField Pattern
tab-title: Implementation
tab-order: 3
---

## Comparison: field pattern vs manual composition

**With NumberInputField:**
```tsx
<NumberInputField
  label="Quantity"
  description="Enter the product quantity"
  value={quantity}
  onChange={setQuantity}
  minValue={1}
  maxValue={100}
  errors={errors}
  touched={touched}
  isRequired
/>
```

**Manual composition:**
```tsx
<FormField.Root isInvalid={!!(errors && touched)} isRequired>
  <FormField.Label>Quantity</FormField.Label>
  <FormField.Input>
    <NumberInput
      value={quantity}
      onChange={setQuantity}
      minValue={1}
      maxValue={100}
      width="full"
    />
  </FormField.Input>
  <FormField.Description>
    Enter the product quantity
  </FormField.Description>
  {touched && errors && (
    <FormField.Error>
      <FieldErrors errors={errors} />
    </FormField.Error>
  )}
</FormField.Root>
```

### When to use which

**Use NumberInputField when:**
- Building standard forms with typical field layouts
- You want consistent field patterns across your app
- You need built-in error handling with FieldErrors
- You want to minimize boilerplate code

**Use NumberInput with manual FormField composition when:**
- You need custom field layouts
- You're building complex, non-standard forms
- You need granular control over FormField sub-components
- You require a different error handling implementation

## Getting started

### Import

```tsx
import { NumberInputField, type NumberInputFieldProps } from '@commercetools/nimbus';
```

### Basic usage

The simplest implementation with a label and controlled state:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<number>(0);

  return (
    <NumberInputField
      label="Quantity"
      value={value}
      onChange={setValue}
    />
  );
}
```

## Usage examples

### Size options

The `sm` and `md` size variants are available to match your interface density:

```jsx-live-dev
const App = () => {
  const [valueSmall, setValueSmall] = useState<number>(0);
  const [valueMedium, setValueMedium] = useState<number>(0);

  return (
    <Stack direction="column" gap="400">
      <NumberInputField
        size="sm"
        label="Small input"
        value={valueSmall}
        onChange={setValueSmall}
        placeholder="0"
      />
      <NumberInputField
        size="md"
        label="Medium input"
        value={valueMedium}
        onChange={setValueMedium}
        placeholder="0 (default)"
      />
    </Stack>
  );
}
```

### Visual variants

Choose between `solid` and `ghost` variants to match your design context:

```jsx-live-dev
const App = () => {
  const [valueSolid, setValueSolid] = useState<number>(42);
  const [valueGhost, setValueGhost] = useState<number>(42);

  return (
    <Stack direction="column" gap="400">
      <NumberInputField
        variant="solid"
        label="Solid variant"
        value={valueSolid}
        onChange={setValueSolid}
        placeholder="0"
      />
      <NumberInputField
        variant="ghost"
        label="Ghost variant"
        value={valueGhost}
        onChange={setValueGhost}
        placeholder="0"
      />
    </Stack>
  );
}
```

### With description

Add helper text below the input to provide context:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<number>(10);

  return (
    <NumberInputField
      label="Product quantity"
      description="Enter the number of items in stock"
      value={value}
      onChange={setValue}
      minValue={0}
    />
  );
}
```

### With validation errors

Show error messages when the field is touched and has validation errors:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<number | undefined>(undefined);
  const [touched, setTouched] = useState<boolean>(false);

  // Simulate validation: require a value and minimum of 1
  const errors = touched && (!value || value < 1) ? { missing: true } : undefined;

  return (
    <NumberInputField
      label="Quantity"
      description="Enter at least 1 item"
      value={value}
      onChange={setValue}
      onBlur={() => setTouched(true)}
      errors={errors}
      touched={touched}
      isRequired
      minValue={1}
      placeholder="0"
    />
  );
}
```

**Note**: Errors only display when both `touched={true}` and `errors` exist. This prevents showing errors before the user interacts with the field.

### With info popover

Provide additional context through an info button and popover:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<number>(50);

  return (
    <NumberInputField
      label="Stock Level"
      description="Current inventory count"
      info="This represents the total quantity available in all warehouses. The value updates automatically when orders are placed or shipments are received."
      value={value}
      onChange={setValue}
      minValue={0}
    />
  );
}
```

### Required field

Mark fields as required with the `isRequired` prop:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<number | undefined>(undefined);

  return (
    <NumberInputField
      label="Age"
      description="Enter your age"
      value={value}
      onChange={setValue}
      isRequired
      minValue={0}
      maxValue={120}
      placeholder="0"
    />
  );
}
```

### Disabled state

Prevent user interaction with the `isDisabled` prop:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<number>(999);

  return (
    <NumberInputField
      label="System-calculated total"
      description="This field is automatically calculated"
      value={value}
      onChange={setValue}
      isDisabled
    />
  );
}
```

### Read-only state

Display a non-editable value with the `isReadOnly` prop:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<number>(12345);

  return (
    <NumberInputField
      label="Order number"
      description="This value is automatically generated"
      value={value}
      onChange={setValue}
      isReadOnly
    />
  );
}
```

### Min and max constraints

Enforce value boundaries with `minValue` and `maxValue`:

```jsx-live-dev
const App = () => {
  const [percentage, setPercentage] = useState<number>(50);

  return (
    <NumberInputField
      label="Discount percentage"
      description="Enter a value between 0 and 100"
      value={percentage}
      onChange={setPercentage}
      minValue={0}
      maxValue={100}
      trailingElement="%"
    />
  );
}
```

### Custom step increments

Use the `step` prop to control increment/decrement amounts:

```jsx-live-dev
const App = () => {
  const [price, setPrice] = useState<number>(5.00);

  return (
    <NumberInputField
      label="Price"
      description="Increments of $0.25"
      value={price}
      onChange={setPrice}
      step={0.25}
      minValue={0}
      formatOptions={{
        style: 'currency',
        currency: 'USD',
      }}
    />
  );
}
```

### Currency formatting

Format values as currency using `formatOptions`:

```jsx-live-dev
const App = () => {
  const [amount, setAmount] = useState<number>(1234.56);

  return (
    <Stack direction="column" gap="400">
      <NumberInputField
        label="USD Amount"
        value={amount}
        onChange={setAmount}
        formatOptions={{
          style: 'currency',
          currency: 'USD',
        }}
      />
      <NumberInputField
        label="EUR Amount"
        value={amount}
        onChange={setAmount}
        formatOptions={{
          style: 'currency',
          currency: 'EUR',
        }}
      />
      <NumberInputField
        label="JPY Amount"
        value={amount}
        onChange={setAmount}
        formatOptions={{
          style: 'currency',
          currency: 'JPY',
        }}
      />
    </Stack>
  );
}
```

### Percentage formatting

Format values as percentages:

```jsx-live-dev
const App = () => {
  const [rate, setRate] = useState<number>(0.25);

  return (
    <NumberInputField
      label="Interest Rate"
      description="Enter as a decimal (0.25 = 25%)"
      value={rate}
      onChange={setRate}
      step={0.01}
      minValue={0}
      maxValue={1}
      formatOptions={{
        style: 'percent',
      }}
    />
  );
}
```

### With leading element

Add icons or text before the input:

```jsx-live-dev
const App = () => {
  const [price, setPrice] = useState<number>(99.99);

  return (
    <NumberInputField
      label="Product price"
      description="Enter the price in USD"
      value={price}
      onChange={setPrice}
      leadingElement="$"
      minValue={0}
    />
  );
}
```

### With trailing element

Add units or symbols after the input:

```jsx-live-dev
const App = () => {
  const [weight, setWeight] = useState<number>(150);
  const [temperature, setTemperature] = useState<number>(72);

  return (
    <Stack direction="column" gap="400">
      <NumberInputField
        label="Weight"
        value={weight}
        onChange={setWeight}
        trailingElement="lbs"
        minValue={0}
      />
      <NumberInputField
        label="Temperature"
        value={temperature}
        onChange={setTemperature}
        trailingElement="Â°F"
      />
    </Stack>
  );
}
```

### Decimal precision

Control decimal places with format options:

```jsx-live-dev
const App = () => {
  const [value1, setValue1] = useState<number>(3.14159);
  const [value2, setValue2] = useState<number>(3.14159);

  return (
    <Stack direction="column" gap="400">
      <NumberInputField
        label="Two decimal places"
        value={value1}
        onChange={setValue1}
        formatOptions={{
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        }}
      />
      <NumberInputField
        label="Four decimal places"
        value={value2}
        onChange={setValue2}
        formatOptions={{
          minimumFractionDigits: 4,
          maximumFractionDigits: 4,
        }}
      />
    </Stack>
  );
}
```

## Component requirements

### Error handling

NumberInputField uses the `FieldErrors` component to display validation errors with built-in localized messages. For custom error messages, use the `renderError` prop (see [Custom error rendering](#custom-error-rendering) below).

**Error object format** (`FieldErrorsData`):
```tsx
type FieldErrorsData = {
  [key: string]: boolean | string | ReactNode;
};

// Common numeric validation errors:
const errors = {
  missing: true,         // "This field is required"
  negative: true,        // "Please enter a positive number"
  belowMin: true,        // "Value is below minimum"
  aboveMax: true,        // "Value is above maximum"
  fractions: true,       // "Please enter a whole number"
  custom: "Must be even" // Custom message
};
```

### Accessibility

NumberInputField provides comprehensive accessibility through [FormField](components/inputs/formfield) and [NumberInput](components/inputs/number-input):

**Automatic ARIA relationships:**
- Labels connected via `aria-labelledby`
- Descriptions connected via `aria-describedby`
- Error messages connected via `aria-describedby`
- Required fields indicated with `aria-required`
- Invalid state indicated with `aria-invalid`
- Value bounds communicated via `aria-valuemin` and `aria-valuemax`
- Current value communicated via `aria-valuenow`
- Increment/decrement buttons with localized `aria-label`

If your use case requires tracking and analytics for this component, add a **persistent**, **unique** id:

```tsx
const PERSISTENT_ID = "example-number-input";

export const Example = () => (
  <NumberInputField
    id={PERSISTENT_ID}
    label="Quantity"
    value={value}
    onChange={setValue}
  />
);
```

#### Keyboard navigation

The component supports standard numeric input keyboard interaction:
- `Tab` / `Shift+Tab`: Move focus to/from the input
- `Arrow Up` / `Arrow Down`: Increment/decrement value (when focused)
- `Page Up` / `Page Down`: Increment/decrement by larger amount
- `Home`: Set to minimum value (if `minValue` specified)
- `End`: Set to maximum value (if `maxValue` specified)
- Number keys: Enter numeric values
- `-` (minus): Enter negative values (if allowed)
- `.` (period): Enter decimal point

## Form integration

NumberInputField integrates seamlessly with Formik:

```tsx
import { useFormik } from 'formik';
import { NumberInputField, Button, Stack } from '@commercetools/nimbus';

const MyForm = () => {
  const formik = useFormik({
    initialValues: {
      quantity: 1,
      price: 0,
    },
    validate: (values) => {
      const errors = {};

      if (!values.quantity) {
        errors.quantity = { missing: true };
      } else if (values.quantity < 1) {
        errors.quantity = { belowMin: true };
      } else if (values.quantity > 100) {
        errors.quantity = { aboveMax: true };
      }

      if (!values.price) {
        errors.price = { missing: true };
      } else if (values.price < 0) {
        errors.price = { negative: true };
      }

      return errors;
    },
    onSubmit: (values) => {
      console.log('Submitted:', values);
    },
  });

  return (
    <form onSubmit={formik.handleSubmit}>
      <Stack direction="column" gap="400">
        <NumberInputField
          name="quantity"
          label="Quantity"
          description="Enter quantity (1-100)"
          value={formik.values.quantity}
          onChange={(value) => formik.setFieldValue('quantity', value)}
          onBlur={() => formik.setFieldTouched('quantity', true)}
          errors={formik.errors.quantity}
          touched={formik.touched.quantity}
          minValue={1}
          maxValue={100}
          isRequired
        />
        <NumberInputField
          name="price"
          label="Price"
          description="Enter product price"
          value={formik.values.price}
          onChange={(value) => formik.setFieldValue('price', value)}
          onBlur={() => formik.setFieldTouched('price', true)}
          errors={formik.errors.price}
          touched={formik.touched.price}
          minValue={0}
          formatOptions={{
            style: 'currency',
            currency: 'USD',
          }}
          isRequired
        />
        <Button type="submit">Submit</Button>
      </Stack>
    </form>
  );
};
```

**Key integration points:**
- **Value/OnChange**: Connect Formik values with `value` and `setFieldValue`
- **OnBlur**: Mark field as touched on blur
- **Errors**: Pass `errors.fieldName` (supports `FieldErrorsData` format or strings)
- **Touched**: Pass `touched.fieldName` to control error visibility
- **Validation**: Use `minValue`/`maxValue` for client-side bounds checking

## API reference

<PropsTable id="NumberInputField" />

### Custom error rendering

Use the `renderError` prop to customize how specific error keys are displayed:

```tsx
<NumberInputField
  label="Age"
  value={value}
  onChange={setValue}
  errors={{ tooYoung: true, invalidAge: true }}
  touched={true}
  renderError={(key) => {
    switch (key) {
      case 'tooYoung':
        return 'You must be at least 18 years old';
      case 'invalidAge':
        return 'Please enter a valid age between 18 and 120';
      default:
        return null; // Fall back to FieldErrors built-in messages
    }
  }}
/>
```

## Testing your implementation

These examples demonstrate how to test your implementation when using NumberInputField in your application. The component's internal functionality is already tested by Nimbus - these patterns help you verify your integration and application-specific logic.

### Basic rendering tests

Verify the component renders with expected elements:

```tsx
import { render, screen } from '@testing-library/react';
import { NumberInputField } from '@commercetools/nimbus';

describe('NumberInputField', () => {
  it('renders label and input', () => {
    render(
      <NumberInputField
        label="Quantity"
        value={0}
        onChange={() => {}}
      />
    );

    // Verify label is rendered
    expect(screen.getByText('Quantity')).toBeInTheDocument();

    // Verify input is rendered with spinbutton role
    expect(screen.getByRole('spinbutton', { name: /quantity/i })).toBeInTheDocument();
  });

  it('renders description text', () => {
    render(
      <NumberInputField
        label="Quantity"
        description="Enter product quantity"
        value={0}
        onChange={() => {}}
      />
    );

    expect(screen.getByText('Enter product quantity')).toBeInTheDocument();
  });

  it('shows required indicator', () => {
    render(
      <NumberInputField
        label="Required field"
        value={0}
        onChange={() => {}}
        isRequired
      />
    );

    const input = screen.getByRole('spinbutton');
    expect(input).toHaveAttribute('aria-required', 'true');
  });

  it('renders increment and decrement buttons', () => {
    render(
      <NumberInputField
        label="Quantity"
        value={5}
        onChange={() => {}}
      />
    );

    expect(screen.getByLabelText('Increment')).toBeInTheDocument();
    expect(screen.getByLabelText('Decrement')).toBeInTheDocument();
  });
});
```

### Interaction tests

Test user interactions with the component:

```tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { NumberInputField } from '@commercetools/nimbus';

describe('NumberInputField interactions', () => {
  it('calls onChange when user types', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();

    render(
      <NumberInputField
        label="Quantity"
        value={0}
        onChange={handleChange}
      />
    );

    const input = screen.getByRole('spinbutton', { name: /quantity/i });
    await user.clear(input);
    await user.type(input, '42');

    expect(handleChange).toHaveBeenCalled();
    // Last call should be with 42
    expect(handleChange).toHaveBeenLastCalledWith(42);
  });

  it('increments value when increment button clicked', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();

    render(
      <NumberInputField
        label="Quantity"
        value={5}
        onChange={handleChange}
      />
    );

    const incrementButton = screen.getByLabelText('Increment');
    await user.click(incrementButton);

    expect(handleChange).toHaveBeenCalledWith(6);
  });

  it('decrements value when decrement button clicked', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();

    render(
      <NumberInputField
        label="Quantity"
        value={5}
        onChange={handleChange}
      />
    );

    const decrementButton = screen.getByLabelText('Decrement');
    await user.click(decrementButton);

    expect(handleChange).toHaveBeenCalledWith(4);
  });

  it('calls onBlur when input loses focus', async () => {
    const user = userEvent.setup();
    const handleBlur = jest.fn();

    render(
      <NumberInputField
        label="Quantity"
        value={0}
        onChange={() => {}}
        onBlur={handleBlur}
      />
    );

    const input = screen.getByRole('spinbutton');
    await user.click(input);
    await user.tab(); // Move focus away

    expect(handleBlur).toHaveBeenCalledTimes(1);
  });

  it('does not call onChange when disabled', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();

    render(
      <NumberInputField
        label="Quantity"
        value={0}
        onChange={handleChange}
        isDisabled
      />
    );

    const input = screen.getByRole('spinbutton');
    expect(input).toBeDisabled();

    // Buttons should also be disabled
    expect(screen.getByLabelText('Increment')).toBeDisabled();
    expect(screen.getByLabelText('Decrement')).toBeDisabled();

    // Attempt to type (should not work)
    await user.type(input, '42');
    expect(handleChange).not.toHaveBeenCalled();
  });
});
```

### Testing validation and errors

Test error handling and validation behavior:

```tsx
import { render, screen } from '@testing-library/react';
import { NumberInputField } from '@commercetools/nimbus';

describe('NumberInputField validation', () => {
  it('does not show errors when untouched', () => {
    render(
      <NumberInputField
        label="Quantity"
        value={0}
        onChange={() => {}}
        errors={{ missing: true }}
        touched={false}
      />
    );

    // Error should not be visible
    expect(screen.queryByText(/required/i)).not.toBeInTheDocument();
  });

  it('shows errors when touched', () => {
    render(
      <NumberInputField
        label="Quantity"
        value={0}
        onChange={() => {}}
        errors={{ missing: true }}
        touched={true}
      />
    );

    // Error should be visible
    expect(screen.getByText(/required/i)).toBeInTheDocument();
  });

  it('shows custom error messages', () => {
    render(
      <NumberInputField
        label="Age"
        value={10}
        onChange={() => {}}
        errors={{ tooYoung: true }}
        touched={true}
        renderError={(key) => {
          if (key === 'tooYoung') return 'Must be at least 18';
          return null;
        }}
      />
    );

    expect(screen.getByText('Must be at least 18')).toBeInTheDocument();
  });

  it('applies invalid styling when isInvalid is true', () => {
    render(
      <NumberInputField
        label="Quantity"
        value={0}
        onChange={() => {}}
        isInvalid
      />
    );

    const input = screen.getByRole('spinbutton');
    expect(input).toHaveAttribute('data-invalid', 'true');
  });
});
```

### Testing min/max constraints

Test boundary validation:

```tsx
import { render, screen } from '@testing-library/react';
import { NumberInputField } from '@commercetools/nimbus';

describe('NumberInputField constraints', () => {
  it('applies min and max values', () => {
    render(
      <NumberInputField
        label="Percentage"
        value={50}
        onChange={() => {}}
        minValue={0}
        maxValue={100}
      />
    );

    const input = screen.getByRole('spinbutton');
    expect(input).toHaveAttribute('aria-valuemin', '0');
    expect(input).toHaveAttribute('aria-valuemax', '100');
  });

  it('communicates current value via aria-valuenow', () => {
    render(
      <NumberInputField
        label="Quantity"
        value={42}
        onChange={() => {}}
      />
    );

    const input = screen.getByRole('spinbutton');
    expect(input).toHaveAttribute('aria-valuenow', '42');
  });
});
```

### Testing format options

Test number formatting:

```tsx
import { render, screen } from '@testing-library/react';
import { NumberInputField } from '@commercetools/nimbus';

describe('NumberInputField formatting', () => {
  it('formats as currency', () => {
    render(
      <NumberInputField
        label="Price"
        value={1234.56}
        onChange={() => {}}
        formatOptions={{
          style: 'currency',
          currency: 'USD',
        }}
      />
    );

    const input = screen.getByRole('spinbutton');
    expect(input).toHaveValue('$1,234.56');
  });

  it('formats as percentage', () => {
    render(
      <NumberInputField
        label="Rate"
        value={0.25}
        onChange={() => {}}
        formatOptions={{
          style: 'percent',
        }}
      />
    );

    const input = screen.getByRole('spinbutton');
    expect(input).toHaveValue('25%');
  });
});
```

## Resources

- [Storybook](https://nimbus-storybook.vercel.app/?path=/docs/patterns-fields-numberinputfield--docs)
- [NumberInput Component](/components/inputs/number-input)
- [FormField Component](/components/inputs/formfield)
- [FieldErrors Component](/components/forms/fielderrors)
- [React Aria NumberField](https://react-spectrum.adobe.com/react-aria/NumberField.html)
- [ARIA Spinbutton Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/spinbutton/)
