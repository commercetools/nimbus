---
title: PasswordInputField Pattern
tab-title: Implementation
tab-order: 3
---

## Comparison: field pattern vs manual composition

**With PasswordInputField:**
```tsx
<PasswordInputField
  label="Password"
  description="Enter a secure password"
  value={value}
  onChange={setValue}
  errors={errors}
  touched={touched}
  isRequired
/>
```

**Manual composition:**
```tsx
<FormField.Root isInvalid={!!(errors && touched)} isRequired>
  <FormField.Label>Password</FormField.Label>
  <FormField.Input>
    <PasswordInput
      value={value}
      onChange={setValue}
      width="full"
    />
  </FormField.Input>
  <FormField.Description>
    Enter a secure password
  </FormField.Description>
  {touched && errors && (
    <FormField.Error>
      <FieldErrors errors={errors} />
    </FormField.Error>
  )}
</FormField.Root>
```

### When to use which

**Use PasswordInputField when:**
- Building standard authentication forms (login, signup, password change)
- You want consistent field patterns across your app
- You need built-in error handling with FieldErrors
- You want to minimize boilerplate code

**Use PasswordInput with manual FormField composition when:**
- You need custom field layouts
- You're building complex, non-standard forms
- You need granular control over FormField sub-components
- You require a different error handling implementation

## Getting started

### Import

```tsx
import { PasswordInputField, type PasswordInputFieldProps } from '@commercetools/nimbus';
```

### Basic usage

The simplest implementation with a label and controlled state:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<string>('');

  return (
    <PasswordInputField
      label="Password"
      value={value}
      onChange={setValue}
    />
  );
}
```

## Usage examples

### With description

Add helper text below the input to provide context:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<string>('');

  return (
    <PasswordInputField
      label="New Password"
      description="Password must be at least 8 characters long"
      value={value}
      onChange={setValue}
      placeholder="Enter password"
    />
  );
}
```

### With validation errors

Show error messages when the field is touched and has validation errors:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<string>('');
  const [touched, setTouched] = useState<boolean>(false);

  // Simulate validation: require at least 8 characters
  const errors = touched && value.length < 8 ? { tooShort: true } : undefined;

  return (
    <PasswordInputField
      label="Password"
      description="Enter at least 8 characters"
      value={value}
      onChange={setValue}
      onBlur={() => setTouched(true)}
      errors={errors}
      touched={touched}
      isRequired
      renderError={(key) => key === 'tooShort' ? 'Password must be at least 8 characters' : null}
    />
  );
}
```

**Note**: Errors only display when both `touched={true}` and `errors` exist. This prevents showing errors before the user interacts with the field.

### With info popover

Provide additional context through an info button and popover:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<string>('');

  return (
    <PasswordInputField
      label="Secret Key"
      info="This key is used to encrypt your data locally. Do not lose it."
      value={value}
      onChange={setValue}
    />
  );
}
```

### Required field

Mark fields as required with the `isRequired` prop:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<string>('');

  return (
    <PasswordInputField
      label="Current Password"
      value={value}
      onChange={setValue}
      isRequired
    />
  );
}
```

### Disabled state

Prevent user interaction with the `isDisabled` prop:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<string>('Sup3rS3cr3t');

  return (
    <PasswordInputField
      label="Password"
      value={value}
      onChange={setValue}
      isDisabled
    />
  );
}
```

### Read-only state

Display a non-editable value with the `isReadOnly` prop:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<string>('Sup3rS3cr3t');

  return (
    <PasswordInputField
      label="Generated Password"
      description="Copy this password now, it won't be shown again"
      value={value}
      onChange={setValue}
      isReadOnly
    />
  );
}
```

## Component requirements

### Error handling

PasswordInputField uses the `FieldErrors` component to display validation errors with built-in localized messages. For custom error messages, use the `renderError` prop.

### Accessibility

PasswordInputField provides comprehensive accessibility through [FormField](components/inputs/formfield):

**Automatic ARIA relationships:**
- Labels connected via `aria-labelledby`
- Descriptions connected via `aria-describedby`
- Error messages connected via `aria-describedby`
- Required fields indicated with `aria-required`
- Invalid state indicated with `aria-invalid`

#### Password Visibility
The underlying `PasswordInput` component handles the "Show/Hide Password" toggle accessibly, ensuring the button has an appropriate label (aria-label) and state updates.

#### Keyboard navigation
The component supports standard text input keyboard interaction:
- `Tab` / `Shift+Tab`: Move focus to/from the input and the visibility toggle
- `Enter` / `Space`: Toggle visibility when focused on the toggle button

## Form integration

PasswordInputField integrates seamlessly with Formik:

```tsx
import { useFormik } from 'formik';
import { PasswordInputField, Button, Stack } from '@commercetools/nimbus';

const MyForm = () => {
  const formik = useFormik({
    initialValues: {
      password: '',
      confirmPassword: '',
    },
    validate: (values) => {
      const errors = {};
      if (!values.password) {
        errors.password = { missing: true };
      }
      if (values.password !== values.confirmPassword) {
        errors.confirmPassword = { custom: "Passwords do not match" };
      }
      return errors;
    },
    onSubmit: (values) => {
      console.log('Submitted:', values);
    },
  });

  return (
    <form onSubmit={formik.handleSubmit}>
      <Stack direction="column" gap="400">
        <PasswordInputField
          name="password"
          label="Password"
          value={formik.values.password}
          onChange={(value) => formik.setFieldValue('password', value)}
          onBlur={() => formik.setFieldTouched('password', true)}
          errors={formik.errors.password}
          touched={formik.touched.password}
          isRequired
        />
        <PasswordInputField
          name="confirmPassword"
          label="Confirm Password"
          value={formik.values.confirmPassword}
          onChange={(value) => formik.setFieldValue('confirmPassword', value)}
          onBlur={() => formik.setFieldTouched('confirmPassword', true)}
          errors={formik.errors.confirmPassword}
          touched={formik.touched.confirmPassword}
          isRequired
          renderError={(key) => key === 'custom' ? 'Passwords do not match' : null}
        />
        <Button type="submit">Submit</Button>
      </Stack>
    </form>
  );
};
```

## Testing your implementation

### Basic rendering tests

Verify the component renders with expected elements:

```tsx
import { render, screen } from '@testing-library/react';
import { PasswordInputField } from '@commercetools/nimbus';

describe('PasswordInputField', () => {
  it('renders label and input', () => {
    render(
      <PasswordInputField
        label="Password"
        value=""
        onChange={() => {}}
      />
    );

    // Verify label is rendered
    expect(screen.getByText('Password')).toBeInTheDocument();

    // Verify input is rendered (usually type="password")
    expect(screen.getByLabelText('Password')).toHaveAttribute('type', 'password');
  });
});
```

### Interaction tests

Test user interactions with the component:

```tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { PasswordInputField } from '@commercetools/nimbus';

describe('PasswordInputField interactions', () => {
  it('calls onChange when user types', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();

    render(
      <PasswordInputField
        label="Password"
        value=""
        onChange={handleChange}
      />
    );

    const input = screen.getByLabelText('Password');
    await user.type(input, 'secure123');

    expect(handleChange).toHaveBeenCalledTimes(9);
    expect(handleChange).toHaveBeenLastCalledWith('secure123');
  });
});
```

