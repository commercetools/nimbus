---
title: TextInputField Pattern
tab-title: Implementation
tab-order: 3
---

## Comparison: field pattern vs manual composition

**With TextInputField:**
```tsx
<TextInputField
  label="Project name"
  description="Enter a descriptive name"
  value={value}
  onChange={setValue}
  errors={errors}
  touched={touched}
  isRequired
/>
```

**Manual composition:**
```tsx
<FormField.Root isInvalid={!!(errors && touched)} isRequired>
  <FormField.Label>Project name</FormField.Label>
  <FormField.Input>
    <TextInput
      value={value}
      onChange={setValue}
      width="full"
    />
  </FormField.Input>
  <FormField.Description>
    Enter a descriptive name
  </FormField.Description>
  {touched && errors && (
    <FormField.Error>
      <FieldErrors errors={errors} />
    </FormField.Error>
  )}
</FormField.Root>
```

### When to use which

**Use TextInputField when:**
- Building standard forms with typical field layouts
- You want consistent field patterns across your app
- You need built-in error handling with FieldErrors
- You want to minimize boilerplate code

**Use TextInput with manual FormField composition when:**
- You need custom field layouts
- You're building complex, non-standard forms
- You need granular control over FormField sub-components
- You require a different error handling implementation

## Getting started

### Import

```tsx
import { TextInputField, type TextInputFieldProps } from '@commercetools/nimbus';
```

### Basic usage

The simplest implementation with a label and controlled state:

```jsx live-dev
const App = () => {
  const [value, setValue] = useState<string>('');

  return (
    <TextInputField
      label="Username"
      value={value}
      onChange={setValue}
    />
  );
}
```

## Usage examples

### Size options

The `sm` and `md` size variants are available to match your interface density:

```jsx live-dev
const App = () => {
  const [valueSmall, setValueSmall] = useState<string>('');
  const [valueMedium, setValueMedium] = useState<string>('');

  return (
    <Stack direction="column" gap="400">
      <TextInputField
        size="sm"
        label="Small input"
        value={valueSmall}
        onChange={setValueSmall}
        placeholder="Small size"
      />
      <TextInputField
        size="md"
        label="Medium input"
        value={valueMedium}
        onChange={setValueMedium}
        placeholder="Medium size (default)"
      />
    </Stack>
  );
}
```

### Visual variants

Choose between `solid` and `ghost` variants to match your design context:

```jsx live-dev
const App = () => {
  const [valueSolid, setValueSolid] = useState<string>('');
  const [valueGhost, setValueGhost] = useState<string>('');

  return (
    <Stack direction="column" gap="400">
      <TextInputField
        variant="solid"
        label="Solid variant"
        value={valueSolid}
        onChange={setValueSolid}
        placeholder="Solid variant (default)"
      />
      <TextInputField
        variant="ghost"
        label="Ghost variant"
        value={valueGhost}
        onChange={setValueGhost}
        placeholder="Ghost variant"
      />
    </Stack>
  );
}
```

### With description

Add helper text below the input to provide context:

```jsx live-dev
const App = () => {
  const [value, setValue] = useState<string>('');

  return (
    <TextInputField
      label="Project name"
      description="Choose a unique name that describes your project"
      value={value}
      onChange={setValue}
      placeholder="My Awesome Project"
    />
  );
}
```

### With validation errors

Show error messages when the field is touched and has validation errors:

```jsx live-dev
const App = () => {
  const [value, setValue] = useState<string>('');
  const [touched, setTouched] = useState<boolean>(false);

  // Simulate validation: require at least 3 characters
  const errors = touched && value.length < 3 ? { missing: true } : undefined;

  return (
    <TextInputField
      label="Username"
      description="Enter at least 3 characters"
      value={value}
      onChange={setValue}
      onBlur={() => setTouched(true)}
      errors={errors}
      touched={touched}
      isRequired
      placeholder="johndoe"
    />
  );
}
```

**Note**: Errors only display when both `touched={true}` and `errors` exist. This prevents showing errors before the user interacts with the field.

### With info popover

Provide additional context through an info button and popover:

```jsx live-dev
const App = () => {
  const [value, setValue] = useState<string>('');

  return (
    <TextInputField
      label="API Key"
      description="Enter your API key for authentication"
      info="Your API key can be found in your account settings under 'Developers'. Keep this key secure and do not share it publicly."
      value={value}
      onChange={setValue}
      type="password"
    />
  );
}
```

### Required field

Mark fields as required with the `isRequired` prop:

```jsx live-dev
const App = () => {
  const [value, setValue] = useState<string>('');

  return (
    <TextInputField
      label="Email address"
      description="We'll use this to contact you"
      value={value}
      onChange={setValue}
      isRequired
      placeholder="user@example.com"
    />
  );
}
```

### Disabled state

Prevent user interaction with the `isDisabled` prop:

```jsx live-dev
const App = () => {
  const [value, setValue] = useState<string>('Cannot edit this');

  return (
    <TextInputField
      label="Account ID"
      description="This field cannot be modified"
      value={value}
      onChange={setValue}
      isDisabled
    />
  );
}
```

### Read-only state

Display a non-editable value with the `isReadOnly` prop:

```jsx live-dev
const App = () => {
  const [value, setValue] = useState<string>('Read-only value');

  return (
    <TextInputField
      label="System-generated ID"
      description="This value is automatically generated"
      value={value}
      onChange={setValue}
      isReadOnly
    />
  );
}
```

### Different input types

Use the `type` prop to specify the HTML input type:

```jsx live-dev
const App = () => {
  const [email, setEmail] = useState<string>('');
  const [password, setPassword] = useState<string>('');
  const [search, setSearch] = useState<string>('');

  return (
    <Stack direction="column" gap="400">
      <TextInputField
        type="email"
        label="Email"
        value={email}
        onChange={setEmail}
        placeholder="user@example.com"
      />
      <TextInputField
        type="password"
        label="Password"
        value={password}
        onChange={setPassword}
        placeholder="Enter your password"
      />
      <TextInputField
        type="search"
        label="Search"
        value={search}
        onChange={setSearch}
        placeholder="Search..."
      />
    </Stack>
  );
}
```

### With leading and trailing elements

Add icons or other elements to the input using `leadingElement` and `trailingElement`:

```jsx live-dev
const App = () => {
  const [search, setSearch] = useState<string>('');
  const [url, setUrl] = useState<string>('');

  return (
    <Stack direction="column" gap="400">
      <TextInputField
        label="Search"
        value={search}
        onChange={setSearch}
        placeholder="Search..."
        leadingElement={<Icons.Search />}
      />
      <TextInputField
        label="Website URL"
        value={url}
        onChange={setUrl}
        placeholder="example.com"
        leadingElement={<Text fontSize="sm" color="neutral.11">https://</Text>}
      />
    </Stack>
  );
}
```

## Component requirements

### Error handling

TextInputField uses the `FieldErrors` component to display validation errors with built-in localized messages. For custom error messages, use the `renderError` prop (see [Custom error rendering](#custom-error-rendering) below).

**Error object format** (`FieldErrorsData`):
```tsx
type FieldErrorsData = {
  [key: string]: boolean | string | ReactNode;
};

// Examples:
const errors = {
  missing: true,              // Built-in message: "This field is required"
  invalidFormat: true,        // Built-in message: "Please enter a valid format"
  custom: "Custom error text" // Custom message
};
```

## Accessibility

TextInputField provides comprehensive accessibility through [FormField](components/inputs/formfield):

**Automatic ARIA relationships:**
- Labels connected via `aria-labelledby`
- Descriptions connected via `aria-describedby`
- Error messages connected via `aria-describedby`
- Required fields indicated with `aria-required`
- Invalid state indicated with `aria-invalid`

If your use case requires tracking and analytics for this component, add a **persistent**, **unique** id:

```tsx
const PERSISTENT_ID = "example-text-input";

export const Example = () => (
  <TextInputField
    id={PERSISTENT_ID}
    label="Username"
    value={value}
    onChange={setValue}
  />
);
```

#### Keyboard navigation

The component supports standard text input keyboard interaction:
- `Tab` / `Shift+Tab`: Move focus to/from the input
- `Arrow keys`: Navigate within the text
- `Home` / `End`: Move to start/end of text
- `Ctrl+A` / `Cmd+A`: Select all text

## Form integration

TextInputField integrates seamlessly with Formik:

```tsx
import { useFormik } from 'formik';
import { TextInputField, Button, Stack } from '@commercetools/nimbus';

const MyForm = () => {
  const formik = useFormik({
    initialValues: {
      username: '',
      email: '',
    },
    validate: (values) => {
      const errors = {};

      if (!values.username) {
        errors.username = { missing: true };
      } else if (values.username.length < 3) {
        errors.username = { tooShort: true };
      }

      if (!values.email) {
        errors.email = { missing: true };
      } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(values.email)) {
        errors.email = { invalidFormat: true };
      }

      return errors;
    },
    onSubmit: (values) => {
      console.log('Submitted:', values);
    },
  });

  return (
    <form onSubmit={formik.handleSubmit}>
      <Stack direction="column" gap="400">
        <TextInputField
          name="username"
          label="Username"
          description="Choose a unique username"
          value={formik.values.username}
          onChange={(value) => formik.setFieldValue('username', value)}
          onBlur={() => formik.setFieldTouched('username', true)}
          errors={formik.errors.username}
          touched={formik.touched.username}
          isRequired
        />
        <TextInputField
          name="email"
          type="email"
          label="Email address"
          description="We'll use this to contact you"
          value={formik.values.email}
          onChange={(value) => formik.setFieldValue('email', value)}
          onBlur={() => formik.setFieldTouched('email', true)}
          errors={formik.errors.email}
          touched={formik.touched.email}
          isRequired
        />
        <Button type="submit">Submit</Button>
      </Stack>
    </form>
  );
};
```

**Key integration points:**
- **Value/OnChange**: Connect Formik values with `value` and `setFieldValue`
- **OnBlur**: Mark field as touched on blur
- **Errors**: Pass `errors.fieldName` (supports `FieldErrorsData` format or strings)
- **Touched**: Pass `touched.fieldName` to control error visibility

## API reference

<PropsTable id="TextInputField" />

### Custom error rendering

Use the `renderError` prop to customize how specific error keys are displayed:

```tsx
<TextInputField
  label="Email address"
  value={value}
  onChange={setValue}
  errors={{ invalidEmail: true, tooShort: true }}
  touched={true}
  renderError={(key) => {
    switch (key) {
      case 'invalidEmail':
        return 'Please enter a valid email address (e.g., user@example.com)';
      case 'tooShort':
        return 'Email must be at least 5 characters long';
      default:
        return null; // Fall back to FieldErrors built-in messages
    }
  }}
/>
```

## Testing your implementation

These examples demonstrate how to test your implementation when using TextInputField within your application. As the component's internal functionality is already tested by Nimbus, these patterns help you verify your integration and application-specific logic.

### Basic rendering tests

Verify the component renders with expected elements:

```tsx
import { render, screen } from '@testing-library/react';
import { TextInputField } from '@commercetools/nimbus';

describe('TextInputField', () => {
  it('renders label and input', () => {
    render(
      <TextInputField
        label="Username"
        value=""
        onChange={() => {}}
      />
    );

    // Verify label is rendered
    expect(screen.getByText('Username')).toBeInTheDocument();

    // Verify input is rendered
    expect(screen.getByRole('textbox', { name: /username/i })).toBeInTheDocument();
  });

  it('renders description text', () => {
    render(
      <TextInputField
        label="Email"
        description="Enter your email address"
        value=""
        onChange={() => {}}
      />
    );

    expect(screen.getByText('Enter your email address')).toBeInTheDocument();
  });

  it('shows required indicator', () => {
    render(
      <TextInputField
        label="Required field"
        value=""
        onChange={() => {}}
        isRequired
      />
    );

    // Check for required indicator (typically an asterisk or aria-required)
    const input = screen.getByRole('textbox');
    expect(input).toHaveAttribute('aria-required', 'true');
  });
});
```

### Interaction tests

Test user interactions with the component:

```tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { TextInputField } from '@commercetools/nimbus';

describe('TextInputField interactions', () => {
  it('calls onChange when user types', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();

    render(
      <TextInputField
        label="Username"
        value=""
        onChange={handleChange}
      />
    );

    const input = screen.getByRole('textbox', { name: /username/i });
    await user.type(input, 'johndoe');

    expect(handleChange).toHaveBeenCalledTimes(7); // Once per character
    expect(handleChange).toHaveBeenLastCalledWith('johndoe');
  });

  it('calls onBlur when input loses focus', async () => {
    const user = userEvent.setup();
    const handleBlur = jest.fn();

    render(
      <TextInputField
        label="Email"
        value=""
        onChange={() => {}}
        onBlur={handleBlur}
      />
    );

    const input = screen.getByRole('textbox');
    await user.click(input);
    await user.tab(); // Move focus away

    expect(handleBlur).toHaveBeenCalledTimes(1);
  });

  it('does not call onChange when disabled', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();

    render(
      <TextInputField
        label="Username"
        value=""
        onChange={handleChange}
        isDisabled
      />
    );

    const input = screen.getByRole('textbox');
    expect(input).toBeDisabled();

    // Attempt to type (should not work)
    await user.type(input, 'test');
    expect(handleChange).not.toHaveBeenCalled();
  });
});
```

### Testing validation and errors

Test error handling and validation behavior:

```tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { TextInputField } from '@commercetools/nimbus';

describe('TextInputField validation', () => {
  it('does not show errors when untouched', () => {
    render(
      <TextInputField
        label="Username"
        value=""
        onChange={() => {}}
        errors={{ missing: true }}
        touched={false}
      />
    );

    // Error should not be visible
    expect(screen.queryByText(/required/i)).not.toBeInTheDocument();
  });

  it('shows errors when touched', () => {
    render(
      <TextInputField
        label="Username"
        value=""
        onChange={() => {}}
        errors={{ missing: true }}
        touched={true}
      />
    );

    // Error should be visible
    expect(screen.getByText(/required/i)).toBeInTheDocument();
  });

  it('shows custom error messages', () => {
    render(
      <TextInputField
        label="Email"
        value=""
        onChange={() => {}}
        errors={{ invalidFormat: true }}
        touched={true}
        renderError={(key) => {
          if (key === 'invalidFormat') return 'Please enter a valid email';
          return null;
        }}
      />
    );

    expect(screen.getByText('Please enter a valid email')).toBeInTheDocument();
  });

  it('applies invalid styling when isInvalid is true', () => {
    render(
      <TextInputField
        label="Username"
        value=""
        onChange={() => {}}
        isInvalid
      />
    );

    const input = screen.getByRole('textbox');
    expect(input).toHaveAttribute('aria-invalid', 'true');
  });
});
```

### Testing with different input types

Test specific input type behavior:

```tsx
import { render, screen } from '@testing-library/react';
import { TextInputField } from '@commercetools/nimbus';

describe('TextInputField input types', () => {
  it('renders email input type', () => {
    render(
      <TextInputField
        type="email"
        label="Email"
        value=""
        onChange={() => {}}
      />
    );

    const input = screen.getByRole('textbox');
    expect(input).toHaveAttribute('type', 'email');
  });

  it('renders password input type', () => {
    render(
      <TextInputField
        type="password"
        label="Password"
        value=""
        onChange={() => {}}
      />
    );

    const input = screen.getByLabelText(/password/i);
    expect(input).toHaveAttribute('type', 'password');
  });

  it('renders search input type', () => {
    render(
      <TextInputField
        type="search"
        label="Search"
        value=""
        onChange={() => {}}
      />
    );

    const input = screen.getByRole('searchbox');
    expect(input).toHaveAttribute('type', 'search');
  });
});
```

## Resources

- [Storybook](https://nimbus-storybook.vercel.app/?path=/docs/patterns-fields-textinputfield--docs)
- [TextInput Component](/components/inputs/textinput)
- [FormField Component](/components/inputs/formfield)
- [FieldErrors Component](/components/forms/fielderrors)
- [React Aria TextField](https://react-spectrum.adobe.com/react-aria/TextField.html)
- [ARIA Textbox Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/textbox/)
