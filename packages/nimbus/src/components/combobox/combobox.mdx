---
id: Components-ComboBox
title: Combo box
exportName: ComboBox
description: A combo box combines a text input with a dropdown list, allowing users to filter a list of options to items matching a query.
documentState: InitialDraft
lifecycleState: Stable
order: 999
menu:
  - Components
  - Inputs
  - Combo box
tags:
  - component
  - combobox
  - autocomplete
  - dropdown
  - typeahead
---

# Combo box input

A combobox is an input that combines a text field with a pop-up list of options.
It allows users to select a value from a predefined list or enter their own
custom value.

## Overview

The combobox component provides both selection and text input capabilities. It
displays a list of options that users can choose from, while also allowing them
to type directly into the text field. This functionality improves user
experience by assisting with value selection and, in some cases, prevents
invalid entries.

### Key features

- **External State Management:** Full control over async logic using React Stately's `useAsyncList`
- **Debouncing:** Use `useDebouncedCallback` from `use-debounce` to reduce API calls while typing
- **Minimum Search Length:** Implement custom validation in the `load` function
- **Automatic Cancellation:** `useAsyncList` cancels previous requests via AbortSignal
- **Loading States:** Access `list.loadingState` to display loading indicators
- **Error Handling:** Manage errors in your `load` function with full control

### Resources

Deep dive into implementation details and access the Nimbus design library.

[Figma library](https://www.figma.com/design/gHbAJGfcrCv7f2bgzUQgHq/NIMBUS-Guidelines?node-id=1852-4333&m=dev)

## Variables

Get familiar with the features.

### Visual options

#### Size

The medium size of the combobox is default, the small sizes are meant for more
compact uses.

```jsx live
const App = () => {
  const options = [
    { id: "seasonal", name: "Seasonal", description: "Grower's choice" },
    { id: "greens", name: "Greens", description: "Leafy and nutritious" },
    { id: "fruit", name: "Fruit", description: "Sweet and tart" },
    { id: "root-vegetables", name: "Root Vegetables", description: "Firm and hearty" }
  ];

  return (
    <Stack direction="horizontal" gap="400" alignItems="flex-start">
      <ComboBox.Root size="md" items={options} placeholder="Search...">
        <ComboBox.Trigger />
        <ComboBox.Popover>
          <ComboBox.ListBox>
            {(item) => (
              <ComboBox.Option id={item.id} textValue={item.name}>
                <Stack gap="100">
                  <Text textStyle="sm">{item.name}</Text>
                  <Text textStyle="xs" color="neutral.11">{item.description}</Text>
                </Stack>
              </ComboBox.Option>
            )}
          </ComboBox.ListBox>
        </ComboBox.Popover>
      </ComboBox.Root>

      <ComboBox.Root size="sm" items={options} placeholder="Search...">
        <ComboBox.Trigger />
        <ComboBox.Popover>
          <ComboBox.ListBox>
            {(item) => (
              <ComboBox.Option id={item.id} textValue={item.name}>
                <Stack gap="100">
                  <Text textStyle="sm">{item.name}</Text>
                  <Text textStyle="xs" color="neutral.11">{item.description}</Text>
                </Stack>
              </ComboBox.Option>
            )}
          </ComboBox.ListBox>
        </ComboBox.Popover>
      </ComboBox.Root>
    </Stack>
  )
}
```

#### Appearances

Combobox supports solid and ghost styles.

```jsx live
const App = () => {
  const options = [
    { id: "seasonal", name: "Seasonal", description: "Grower's choice" },
    { id: "greens", name: "Greens", description: "Leafy and nutritious" },
    { id: "fruit", name: "Fruit", description: "Sweet and tart" },
    { id: "root-vegetables", name: "Root Vegetables", description: "Firm and hearty" }
  ];

  return (
    <Stack direction="horizontal" gap="400" alignItems="flex-start">
      <ComboBox.Root variant="solid" items={options} placeholder="Search...">
        <ComboBox.Trigger />
        <ComboBox.Popover>
          <ComboBox.ListBox>
            {(item) => (
              <ComboBox.Option id={item.id} textValue={item.name}>
                <Stack gap="100">
                  <Text textStyle="sm">{item.name}</Text>
                  <Text textStyle="xs" color="neutral.11">{item.description}</Text>
                </Stack>
              </ComboBox.Option>
            )}
          </ComboBox.ListBox>
        </ComboBox.Popover>
      </ComboBox.Root>

      <ComboBox.Root variant="ghost" items={options} placeholder="Search...">
        <ComboBox.Trigger />
        <ComboBox.Popover>
          <ComboBox.ListBox>
            {(item) => (
              <ComboBox.Option id={item.id} textValue={item.name}>
                <Stack gap="100">
                  <Text textStyle="sm">{item.name}</Text>
                  <Text textStyle="xs" color="neutral.11">{item.description}</Text>
                </Stack>
              </ComboBox.Option>
            )}
          </ComboBox.ListBox>
        </ComboBox.Popover>
      </ComboBox.Root>
    </Stack>
  )
}
```

#### Selection types

Single and multi-select is supported by comboboxes.

```jsx live
const App = () => {
  const options = [
    { id: "surprise-me", name: "Surprise me", description: "A mix of delights" },
    { id: "toys-only", name: "Toys only", description: "Balls, stuffies, and tug toys" },
    { id: "treats-only", name: "Treats only", description: "Chews, bites, and crunchy snacks" },
    { id: "heavy-chewers", name: "Heavy chewers", description: "Only difficult to destroy toys" }
  ];

  return (
    <Stack direction="horizontal" gap="400" alignItems="flex-start">
      <ComboBox.Root items={options} placeholder="Search...">
        <ComboBox.Trigger />
        <ComboBox.Popover>
        <ComboBox.ListBox>
          {(item) => (
            <ComboBox.Option id={item.id} textValue={item.name}>
              <Stack gap="100">
                <Text textStyle="sm">{item.name}</Text>
                <Text textStyle="xs" color="neutral.11">{item.description}</Text>
              </Stack>
            </ComboBox.Option>
              )}
          </ComboBox.ListBox>
        </ComboBox.Popover>
      </ComboBox.Root>

      <ComboBox.Root
        selectionMode="multiple"
        items={options}
        placeholder="Search..."
      >
        <ComboBox.Trigger />
        <ComboBox.Popover>
          <ComboBox.ListBox>
        {(item) => (
          <ComboBox.Option id={item.id} textValue={item.name}>
            <Stack gap="100">
              <Text textStyle="sm">{item.name}</Text>
              <Text textStyle="xs" color="neutral.11">{item.description}</Text>
            </Stack>
          </ComboBox.Option>
            )}
          </ComboBox.ListBox>
        </ComboBox.Popover>
      </ComboBox.Root>
    </Stack>
  )
}
```

### Async Loading

ComboBox supports async data loading by managing the async state externally
using React Stately's `useAsyncList` hook. This pattern gives you full control
over data fetching and works seamlessly with ComboBox's filtering and selection
features.

**Use cases:**

- Loading large datasets on demand
- Providing search suggestions from a server
- Fetching filtered results based on user input

```jsx live
const App = () => {
  const [error, setError] = useState(null);
  const [inputValue, setInputValue] = useState("");
  const [isPending, setIsPending] = useState(false);
  const minSearchLength = 2;

  // Manage async data loading with useAsyncList
  const list = useAsyncList({
    async load({ signal, filterText }) {
      setError(null);

      // Don't load if below minimum search length
      if (!filterText || filterText.length < minSearchLength) {
        return { items: [] };
      }

      try {
        const response = await fetch(
          `https://swapi.py4e.com/api/people/?search=${encodeURIComponent(filterText)}`,
          { signal }
        );

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return { items: data.results || [] };
      } catch (err) {
        if (err.name === "AbortError") {
          throw err;
        }
        setError(err.message);
        return { items: [] };
      }
    }
  });

  // Debounce only the API call, not the input update
  const debouncedSetFilterText = useDebouncedCallback(
    (value) => {
      setIsPending(false);
      list.setFilterText(value);
    },
    300
  );

  // Handle input changes: update immediately for responsive typing, debounce API calls
  const handleInputChange = (value) => {
    setInputValue(value);
    setIsPending(true);
    debouncedSetFilterText(value);
  };

  // Compute combined loading state
  // Check all loading states from useAsyncList: "loading", "loadingMore", "filtering"
  const isLoading = isPending ||
    list.loadingState === "loading" ||
    list.loadingState === "loadingMore" ||
    list.loadingState === "filtering";

  return (
    <FormField.Root invalid={!!error}>
      <ComboBox.Root
        label="Search Star Wars Characters"
        placeholder="Type to search (min 2 characters)..."
        items={list.items}
        inputValue={inputValue}
        onInputChange={handleInputChange}
        isLoading={isLoading}
        getKey={(character) => character.name}
        // Disable client-side filtering since server already filters results
        filter={(nodes) => nodes}
        // Keep menu open during async loading to show loading/empty states
        allowsEmptyMenu={true}
        renderEmptyState={({ isLoading }) => {
          if (isLoading) {
            return <Text padding="300">Loading...</Text>;
          }
          if (!inputValue || inputValue.length < minSearchLength) {
            return <Text padding="300">Type at least {minSearchLength} characters to search</Text>;
          }
          return <Text padding="300">No results found</Text>;
        }}
      >
        <ComboBox.Trigger />
        <ComboBox.Popover>
          <ComboBox.ListBox>
            {(character) => (
              <ComboBox.Option textValue={character.name}>
                <Stack gap="100">
                  <Text textStyle="sm">{character.name}</Text>
                  <Text textStyle="xs" color="neutral.11">
                    {character.gender} â€¢ Born {character.birth_year}
                  </Text>
                </Stack>
              </ComboBox.Option>
            )}
          </ComboBox.ListBox>
        </ComboBox.Popover>
      </ComboBox.Root>
      {error && <FormField.ErrorMessage>{error}</FormField.ErrorMessage>}
    </FormField.Root>
  );
};
```
