---
title: DateRangePicker Component
tab-title: Implementation
tab-order: 3
---

## Getting started

### Import

```jsx
import { DateRangePicker } from '@commercetools/nimbus';
```

For TypeScript projects:
```tsx
import { DateRangePicker, type DateRangePickerProps } from '@commercetools/nimbus';
```

### Basic usage

The simplest implementation uses uncontrolled mode with default settings:

```jsx-live-dev
const App = () => (
  <DateRangePicker />
)
```

## Working with date values

The DateRangePicker relies on Adobe's `@internationalized/date` library for type-safe date handling. This library provides calendar system support, time zone handling, and locale-aware date formatting.

### Date value types

Three primary date types are available depending on your needs:

```tsx
import { CalendarDate, CalendarDateTime, ZonedDateTime } from '@internationalized/date';

// Date only (no time)
const dateOnly = new CalendarDate(2024, 1, 15);

// Date with time (no timezone)
const dateTime = new CalendarDateTime(2024, 1, 15, 14, 30);

// Date with time and timezone
const zonedDate = new ZonedDateTime(2024, 1, 15, 14, 30, 'America/New_York');
```

### Creating date values

Use helper functions to parse ISO strings or create dates programmatically:

```tsx
import { parseDate, parseDateTime, parseZonedDateTime } from '@internationalized/date';

// Parse ISO date strings
const date = parseDate('2024-01-15');
const dateTime = parseDateTime('2024-01-15T14:30');
const zonedDate = parseZonedDateTime('2024-01-15T14:30[America/New_York]');
```

### Date range structure

The component expects and returns date ranges in this structure:

```tsx
type DateRange = {
  start: CalendarDate | CalendarDateTime | ZonedDateTime;
  end: CalendarDate | CalendarDateTime | ZonedDateTime;
}
```

> [!TIP]\
> See [Adobe's @internationalized/date documentation](https://react-spectrum.adobe.com/internationalized/date/index.html) for complete API reference and advanced usage.

## Usage examples

### Size options

Two size variants are available to match your interface density:

```jsx-live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <DateRangePicker size="sm" />
    <DateRangePicker size="md" />
  </Stack>
)
```

Use `size="sm"` for compact layouts or dense data tables. Use `size="md"` (default) for standard forms and prominent date selection.

### Visual variants

Choose between solid and ghost variants to match your design context:

```jsx-live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <DateRangePicker variant="solid" />
    <DateRangePicker variant="ghost" />
  </Stack>
)
```

The `solid` variant (default) provides clear visual boundaries. The `ghost` variant offers a minimal appearance suitable for embedded contexts.

### Granularity options

The `granularity` prop controls both the level of date precision and the component's behavior:

```jsx-live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <DateRangePicker granularity="day" />
    <DateRangePicker granularity="minute" />
  </Stack>
)
```

**Behavioral differences:**
- `granularity="day"` (default): Calendar closes automatically after selecting the end date. Time inputs are hidden.
- `granularity="minute"` or other time values: Calendar remains open after date selection, displaying time input fields in the footer. This allows users to set both dates and times in one interaction.

Available granularity options: `"day"`, `"hour"`, `"minute"`, `"second"`.

### Controlled state

For scenarios requiring programmatic control or coordination with other components, use controlled mode:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<DateRangePickerProps["value"]>(null);

  return (
    <Stack direction="column" gap="400">
      <DateRangePicker
        value={value}
        onChange={setValue}
      />
      <Text fontSize="sm" color="neutral.11">
        {value ? `Selected: ${value.start} to ${value.end}` : 'No selection'}
      </Text>
    </Stack>
  );
}
```

Use controlled mode when you need to:
- Synchronize the date range with external state
- Validate or transform date selections
- Clear or programmatically set the date range

### Time zone handling

When working with `ZonedDateTime` values, configure time zone display and hour format:

```jsx-live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <DateRangePicker
      granularity="minute"
      hideTimeZone={false}
      hourCycle={24}
    />
    <DateRangePicker
      granularity="minute"
      hideTimeZone={true}
      hourCycle={12}
    />
  </Stack>
)
```

- `hideTimeZone`: Controls visibility of the time zone selector
- `hourCycle`: Set to `12` for 12-hour format with AM/PM, or `24` for 24-hour format

## Component requirements

### Date value types

All date values **must** use `@internationalized/date` types:
- `CalendarDate` for date-only scenarios
- `CalendarDateTime` for dates with times (no timezone)
- `ZonedDateTime` for timezone-aware dates

### Accessibility

The DateRangePicker handles all accessibility requirements internally. However, for proper tracking and analytics, **always add an `aria-label`** if your use case warrants it:

```tsx
<DateRangePicker aria-label="Report date range" />
```

Using a `<label>` element or `aria-label` is also appropriate when the picker's purpose isn't clear from surrounding content:

```tsx
<label htmlFor="report-dates">Report date range</label>
<DateRangePicker id="report-dates" />
```

#### Keyboard navigation

The component supports full keyboard interaction:
- `Tab` / `Shift+Tab`: Navigate between date segments and buttons
- `Arrow keys`: Increment/decrement date segments and navigate calendar
- `Enter` / `Space`: Open calendar, select dates
- `Escape`: Close calendar popover

## Common patterns

### Filtering data by date range

A common use case is filtering lists or tables by date range:

```jsx-live-dev
const App = () => {
  const [dateRange, setDateRange] = useState<DateRangePickerProps["value"]>(null);

  // In a real application, you'd filter data based on dateRange
  const appliedFilter = dateRange
    ? `Showing data from ${dateRange.start} to ${dateRange.end}`
    : 'No date filter applied';

  return (
    <Stack direction="column" gap="400">
      <DateRangePicker
        value={dateRange}
        onChange={setDateRange}
      />
      <Text fontSize="sm" color="neutral.11">
        {appliedFilter}
      </Text>
    </Stack>
  );
}
```

### Promotion period selection

For e-commerce scenarios like setting up promotions, sales, or limited-time offers:

```jsx-live-dev
const App = () => {
  const [promotionRange, setPromotionRange] = useState<DateRangePickerProps["value"]>(null);

  return (
    <Stack direction="column" gap="400">
      <Text fontWeight="500">Promotion Period</Text>
      <DateRangePicker
        granularity="minute"
        value={promotionRange}
        onChange={setPromotionRange}
        hourCycle={24}
      />
      {promotionRange && (
        <Text fontSize="sm" color="neutral.11">
          Promotion active from {promotionRange.start.toString()} to {promotionRange.end.toString()}
        </Text>
      )}
    </Stack>
  );
}
```

## Testing your implementation

These examples demonstrate how to test your implementation when using DateRangePicker in your application. The component's internal functionality is already tested by Nimbus - these patterns help you verify your integration and application-specific logic.

### Basic rendering tests

Verify the component renders with expected elements:

```tsx
import { render, screen } from '@testing-library/react';
import { DateRangePicker } from '@commercetools/nimbus';

describe('DateRangePicker', () => {
  it('renders start and end date inputs', () => {
    render(<DateRangePicker />);

    // Each date input has 3 segments (month, day, year)
    const dateInputs = screen.getAllByRole('spinbutton');
    expect(dateInputs).toHaveLength(6);
  });

  it('renders calendar and clear buttons', () => {
    render(<DateRangePicker />);

    expect(screen.getByRole('button', { name: /open calendar/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /clear/i })).toBeInTheDocument();
  });
});
```

### Interaction tests

Test user interactions with the component:

```tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { DateRangePicker } from '@commercetools/nimbus';

describe('DateRangePicker interactions', () => {
  it('opens calendar when button is clicked', async () => {
    const user = userEvent.setup();
    render(<DateRangePicker />);

    const calendarButton = screen.getByRole('button', { name: /open calendar/i });
    await user.click(calendarButton);

    await waitFor(() => {
      expect(screen.getByRole('grid')).toBeInTheDocument();
    });
  });

  it('clears selection when clear button is clicked', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();
    render(<DateRangePicker onChange={handleChange} />);

    const clearButton = screen.getByRole('button', { name: /clear/i });
    await user.click(clearButton);

    expect(handleChange).toHaveBeenCalledWith(null);
  });
});
```

### Testing with date values

Test date value handling using `@internationalized/date`:

```tsx
import { render, screen } from '@testing-library/react';
import { CalendarDate } from '@internationalized/date';
import { DateRangePicker } from '@commercetools/nimbus';

describe('DateRangePicker with date values', () => {
  it('displays provided date range', () => {
    const dateRange = {
      start: new CalendarDate(2024, 1, 15),
      end: new CalendarDate(2024, 1, 20),
    };

    render(<DateRangePicker value={dateRange} />);

    // Verify the dates are displayed in the input segments
    expect(screen.getByText('1', { selector: '[role="spinbutton"]' })).toBeInTheDocument(); // Month
    expect(screen.getByText('15', { selector: '[role="spinbutton"]' })).toBeInTheDocument(); // Start day
    expect(screen.getByText('20', { selector: '[role="spinbutton"]' })).toBeInTheDocument(); // End day
  });

  it('calls onChange with correct date types', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();
    render(<DateRangePicker onChange={handleChange} />);

    // Interact with date picker...
    // After selection:
    expect(handleChange).toHaveBeenCalledWith(
      expect.objectContaining({
        start: expect.any(CalendarDate),
        end: expect.any(CalendarDate),
      })
    );
  });
});
```

### Testing time selection

When using time granularity, test time input behavior:

```tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { DateRangePicker } from '@commercetools/nimbus';

describe('DateRangePicker with time', () => {
  it('shows time inputs when granularity includes time', async () => {
    const user = userEvent.setup();
    render(<DateRangePicker granularity="minute" />);

    // Open calendar
    const calendarButton = screen.getByRole('button', { name: /open calendar/i });
    await user.click(calendarButton);

    // Time inputs should appear in the popover footer
    await waitFor(() => {
      expect(screen.getByText(/start time/i)).toBeInTheDocument();
      expect(screen.getByText(/end time/i)).toBeInTheDocument();
    });
  });
});
```

## API reference

<PropsTable id="DateRangePicker" />

## Resources

- [Storybook](link-tbd)
- [React Aria DateRangePicker](https://react-spectrum.adobe.com/react-aria/DateRangePicker.html)
- [ARIA Date Picker Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/examples/datepicker-dialog/)