---
title: Date range picker component
tab-title: Implementation
tab-order: 3
---

## Getting started

### Import

```tsx
import { DateRangePicker, type DateRangePickerProps } from '@commercetools/nimbus';
```

### Basic usage

The simplest implementation uses uncontrolled mode:

```jsx live-dev
const App = () => (
  <DateRangePicker />
)
```

## Working with date values

The DateRangePicker relies on `@internationalized/date`'s library for type-safe date handling. This library provides calendar system support, time zone handling, and locale-aware date formatting.

### Date value types

Three primary date types are available depending on your needs:

```tsx
import { CalendarDate, CalendarDateTime, ZonedDateTime } from '@internationalized/date';

// Date only (no time)
const dateOnly = new CalendarDate(2024, 1, 15);

// Date with time (no timezone)
const dateTime = new CalendarDateTime(2024, 1, 15, 14, 30);

// Date with time and timezone
const zonedDate = new ZonedDateTime(2024, 1, 15, 14, 30, 'America/New_York');
```

### Creating date values

Use helper functions to parse ISO strings or create dates programmatically:

```tsx
import { parseDate, parseDateTime, parseZonedDateTime } from '@internationalized/date';

// Parse ISO date strings
const date = parseDate('2024-01-15');
const dateTime = parseDateTime('2024-01-15T14:30');
const zonedDate = parseZonedDateTime('2024-01-15T14:30[America/New_York]');
```

### Converting to ISO strings

Use `.toString()` to convert date objects for API/backend consumption:

```tsx
// Convert individual dates
const date = new CalendarDate(2024, 1, 15);
date.toString(); // "2024-01-15"

const dateTime = new CalendarDateTime(2024, 1, 15, 14, 30);
dateTime.toString(); // "2024-01-15T14:30:00"

// Convert date ranges for API calls
const dateRange = {
  start: new CalendarDate(2024, 1, 15),
  end: new CalendarDate(2024, 1, 20)
};

const apiPayload = {
  startDate: dateRange.start.toString(), // "2024-01-15"
  endDate: dateRange.end.toString()      // "2024-01-20"
};
```

> [!TIP]\
> See [@internationalized/date documentation](https://react-spectrum.adobe.com/internationalized/date/) for complete API reference and advanced usage.

### Date range structure

The component expects and returns date ranges in this structure:

```tsx
type DateRange = {
  start: CalendarDate | CalendarDateTime | ZonedDateTime;
  end: CalendarDate | CalendarDateTime | ZonedDateTime;
}

// Note: While TypeScript allows mixing types, always use the same type for both
// start and end to avoid semantic issues.
```

## Usage examples

### Size options

The `sm` and `md` size variants are available to match your interface density:

```jsx live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <DateRangePicker size="sm" />
    <DateRangePicker size="md" />
  </Stack>
)
```

### Visual variants

Choose between `solid` and `ghost` variants to match your design context:

```jsx live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <DateRangePicker variant="solid" />
    <DateRangePicker variant="ghost" />
  </Stack>
)
```

### Granularity options

The `granularity` prop controls both the level of date precision and the component's behavior:

```jsx live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <DateRangePicker granularity="day" />
    <DateRangePicker granularity="minute" />
  </Stack>
)
```

**Behavioral differences:**
- `granularity="day"` (default): Calendar closes automatically after selecting the end date. Time inputs are hidden.
- `granularity="hour" | "minute" | "second"`: Calendar remains open after date selection, displaying time input fields in the footer. This allows users to set both dates and times in one interaction.

### Uncontrolled mode

For simpler use cases, use uncontrolled mode with `defaultValue` and `onChange`:

```jsx live-dev
const App = () => {
  const [selectedRange, setSelectedRange] = useState<string>('No selection');

  return (
    <>
      <DateRangePicker
        defaultValue={{
          start: new CalendarDate(2025, 1, 15),
          end: new CalendarDate(2025, 1, 20),
        }}
        onChange={(range) => {
          setSelectedRange(range ? `${range.start} to ${range.end}` : 'No selection');
        }}
      />
      <Text fontSize="sm">{selectedRange}</Text>
    </>
  );
}
```

Use uncontrolled mode when you need to capture the selected value without managing state yourself.

### Controlled mode

For scenarios requiring programmatic control or coordination with other components, use controlled mode:

```jsx live-dev
const App = () => {
  const [value, setValue] = useState<DateRangePickerProps["value"]>(null);

  return (
    <Stack direction="column" gap="400">
      <DateRangePicker
        value={value}
        onChange={setValue}
      />
      <Text fontSize="sm">
        {value ? `Selected: ${value.start} to ${value.end}` : 'No selection'}
      </Text>
    </Stack>
  );
}
```

Use controlled mode when you need to:
- Synchronize the date range with external state
- Validate or transform date selections
- Clear or programmatically set the date range

### Time zone handling

When working with `ZonedDateTime` values, configure time zone display and hour format:

```jsx live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <DateRangePicker
      granularity="minute"
      hideTimeZone={false}
      hourCycle={24}
    />
    <DateRangePicker
      granularity="minute"
      hideTimeZone={true}
      hourCycle={12}
    />
  </Stack>
)
```

- `hideTimeZone`: Controls visibility of the time zone selector
- `hourCycle`: Set to `12` for 12-hour format with AM/PM, or `24` for 24-hour format

## Component requirements

### Date value types

All date values **must** use `@internationalized/date` types:
- `CalendarDate` for date-only scenarios
- `CalendarDateTime` for dates with times (no timezone)
- `ZonedDateTime` for timezone-aware dates

## Accessibility

The DateRangePicker handles most accessibility requirements internally. However, you must always associate an internationalized label with the component. Visual labels are preferable, and can be set by:

- Using the `DateRangePickerField` pattern component (recommended)
- Associating a `<label>` element with the `DateRangePicker` using `aria-labelledby`:

```tsx
<label id="label-id">
  {msg.format(labelMessage)}
</label>
<DateRangePicker aria-labelledby="label-id" />
```

- Associating a `<label>` element with the `DateRangePicker` using `htmlFor`:

```tsx
<label htmlFor="date-range-picker-id">
  {msg.format(labelMessage)}
</label>
<DateRangePicker id="date-range-picker-id" />
```

If your design requires that the label should not be visible, the label should be set using the `aria-label` prop:

```tsx
<DateRangePicker aria-label={msg.format(labelMessage)} />
```

If your use case requires tracking and analytics for this component, it is good practice to add a **persistent**, **unique** id to the component:

```tsx
const PERSISTENT_ID = "example-date-range-picker";

export const Example = () => (
  <DateRangePicker id={PERSISTENT_ID} />
);
```

#### Keyboard navigation

The component supports full keyboard interaction:
- `Tab` / `Shift+Tab`: Navigate between date segments and buttons
- `Arrow keys`: Increment/decrement date segments and navigate calendar
- `Enter` / `Space`: Open calendar, select dates
- `Escape`: Close calendar popover

## API reference

<PropsTable id="DateRangePicker" />

## Common patterns

### Filtering data by date range

A common use case is filtering lists or tables by date range:

```jsx live-dev
const App = () => {
  const [dateRange, setDateRange] = useState<DateRangePickerProps["value"]>(null);

  // In a real application, you'd filter data based on dateRange
  const appliedFilter = dateRange
    ? `Showing data from ${dateRange.start} to ${dateRange.end}`
    : 'No date filter applied';

  return (
    <Stack direction="column" gap="400">
      <DateRangePicker
        value={dateRange}
        onChange={setDateRange}
      />
      <Text fontSize="sm">
        {appliedFilter}
      </Text>
    </Stack>
  );
}
```

### Promotion period selection

For e-commerce scenarios like setting up promotions, sales, or limited-time offers:

```jsx live-dev
const App = () => {
  const [promotionRange, setPromotionRange] = useState<DateRangePickerProps["value"]>(null);

  return (
    <Stack direction="column" gap="400">
      <DateRangePicker
        granularity="minute"
        value={promotionRange}
        onChange={setPromotionRange}
        hourCycle={24}
      />
      {promotionRange && (
        <Text fontSize="sm">
          Promotion active from {promotionRange.start.toString()} to {promotionRange.end.toString()}
        </Text>
      )}
    </Stack>
  );
}
```

## Testing your implementation

These examples demonstrate how to test your implementation when using DateRangePicker within your application. As the component's internal functionality is already tested by Nimbus, these patterns help you verify your integration and application-specific logic.

{{docs-tests: date-range-picker.docs.spec.tsx}}

## Resources

- [Storybook](https://nimbus-storybook.vercel.app/?path=/docs/components-date-daterangepicker--docs)
- [React Aria DateRangePicker](https://react-spectrum.adobe.com/react-aria/DateRangePicker.html)
- [ARIA Date Picker Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/examples/datepicker-dialog/)