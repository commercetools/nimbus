---
title: DraggableList
tab-title: Guidelines
tab-order: 2
---

## Guidelines

Draggable list guidelines ensure that reordering is intuitive and accessible by
providing a clear drag handle, visual feedback on the insertion point, and a
necessary keyboard alternative for manipulation.

### Best practices

- **Clear drag handle:** the distinct drag handle icon on each list item will
  explicitly communicate that the item is movable and defines the primary target
  for the drag action.
- **Show insertion point:** As the user drags the item, clearly indicate the
  exact target position where the item will be dropped. This is often done by
  visually highlighting the gap or line where the item will be inserted.
- **Maintain performance:** Ensure the drag-and-drop animation is smooth and
  responsive without lag, especially in long lists.
- **Limited scope:** Only allow items to be dragged within the confines of the
  current list; do not allow dragging to other unrelated sections unless
  explicitly necessary for the application's core function.
- **Use the right cursor:** The mouse cursor will change to a hand or grab
  cursor when hovering over the drag handle to visually reinforce interactivity.
- **Lift the item (visual pickup):** When the user clicks the handle to start
  dragging, the appearance will immediately change to separate it visually from
  the rest of the list.
- **Maintain stability:** Keep the other list items stable while one is being
  dragged. Do not introduce excessive animations or visual clutter that makes it
  hard to see the remaining order.
- **Provide an accessible alternative:** Always include keyboard-operable "Move
  Up" and "Move Down" buttons for each list item, as drag-and-drop actions are
  inaccessible to many keyboard-only and assistive technology users.

### Usage

The draggable list component is used when the explicit, user-defined order of
items directly impacts the application's logic or user outcome, such as
sequencing workflow steps or organizing a custom list.

> [!TIP]\
> When to use

- **User-defined order:** When the order of items directly impacts the
  application's logic or user outcome.
- **Short to medium lists:** For lists that are manageable without extensive
  scrolling where dragging is quick.
- **Spatial relationship is key:** When the user benefits from seeing the new
  sequence immediately take effect visually.

> [!CAUTION]\
> When not to use

- **Simple filtering/sorting:** If the only goal is to change the list's view
  (e.g., sort alphabetically, filter by date), use standard sort/filter controls
  instead.
- **Very long lists:** Dragging items across many screen heights or dozens of
  items is tedious and inefficient.
- **Actions are primary:** If the main interaction is performing an action on
  the item (e.g., edit, delete) rather than changing its position. Use a
  standard list component with action buttons.

### Draggable list in use

> [!TIP]\
> **Do**
>
> - Do save the new order instantly or provide a clear "Save Order" button after
>   the drop action is completed.
> - Do ensure all relevant metadata (e.g., numbering) updates automatically
>   after a successful drop.

```jsx-live
const App = () => {
  const [leftItems, setLeftItems] = useState([
    { key: "1", label: "Food" },
    { key: "2", label: "Cosmetics" },
    { key: "3", label: "Furniture" },
    { key: "4", label: "Electronics" },
    { key: "5", label: "Clothing" },
  ]);

  const [rightItems, setRightItems] = useState([
    { key: "6", label: "Sport" },
    { key: "7", label: "Home" },
  ]);

  return (
    <Flex gap="400">
      <DraggableList.Root
        aria-label="Left column"
        items={leftItems}
        onUpdateItems={setLeftItems}
      />
      <DraggableList.Root
        aria-label="Right column"
        items={rightItems}
        onUpdateItems={setRightItems}
      />
    </Flex>
  );
}
```

> [!CAUTION]\
> **Don't**
>
> - Don't make the entire list item the draggable area; this interferes with
>   clicking links, checkboxes, or actions within the item.
> - Don't interrupt the drag action with tooltips, modals, or sudden page
>   refreshes.
> - Don't forget to provide accessible alternatives for reordering (see
>   Accessibility).

```jsx-live
const App = () => {
  const initialLeft = [
    { key: "1", label: "Food" },
    { key: "2", label: "Cosmetics" },
    { key: "3", label: "Furniture" },
    { key: "4", label: "Electronics" },
    { key: "5", label: "Clothing" },
  ];

  const initialRight = [
    { key: "6", label: "Sport" },
    { key: "7", label: "Home" },
  ];

  const [leftItems, setLeftItems] = useState(initialLeft);
  const [rightItems, setRightItems] = useState(initialRight);

  const handleLeftUpdate = (items) => {
    setLeftItems(items);
    setTimeout(() => {
      setLeftItems(initialLeft);
      setRightItems(initialRight);
    }, 500);
  };

  const handleRightUpdate = (items) => {
    setRightItems(items);
    setTimeout(() => {
      setLeftItems(initialLeft);
      setRightItems(initialRight);
    }, 500);
  };

  return (
    <Flex gap="400">
      <DraggableList.Root
        aria-label="Left column"
        items={leftItems}
        onUpdateItems={handleLeftUpdate}
      />
      <DraggableList.Root
        aria-label="Right column"
        items={rightItems}
        onUpdateItems={handleRightUpdate}
      />
    </Flex>
  );
}
```
