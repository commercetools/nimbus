---
title: Table Component
tab-title: Implementation
tab-order: 3
---

## Getting started

### Import

```tsx
import { Table, type TableRootProps } from '@commercetools/nimbus';
```

### Basic usage

The Table component is a compound component that renders semantic HTML table markup with accessible structure. Use `Table.Root` as the container with nested parts for headers, body, rows, and cells:

```jsx live-dev
const App = () => {
  const products = [
    { id: '1', name: 'Laptop Pro', category: 'Electronics', price: '$1,299', stock: 'In Stock' },
    { id: '2', name: 'Wireless Mouse', category: 'Accessories', price: '$29', stock: 'Low Stock' },
    { id: '3', name: 'USB-C Cable', category: 'Accessories', price: '$15', stock: 'In Stock' },
  ];

  return (
    <Table.Root>
      <Table.Header>
        <Table.Row>
          <Table.ColumnHeader>Product</Table.ColumnHeader>
          <Table.ColumnHeader>Category</Table.ColumnHeader>
          <Table.ColumnHeader>Price</Table.ColumnHeader>
          <Table.ColumnHeader>Status</Table.ColumnHeader>
        </Table.Row>
      </Table.Header>
      <Table.Body>
        {products.map((product) => (
          <Table.Row key={product.id}>
            <Table.Cell>{product.name}</Table.Cell>
            <Table.Cell>{product.category}</Table.Cell>
            <Table.Cell>{product.price}</Table.Cell>
            <Table.Cell>{product.stock}</Table.Cell>
          </Table.Row>
        ))}
      </Table.Body>
    </Table.Root>
  );
}
```

## When to use Table

Use the **Table** component when you need to display **static, read-only data** in a simple tabular format. It's designed for straightforward data presentation without interactive features.

### Ideal use cases

- **Static content displays**: Product specifications, feature comparisons, pricing tiers
- **Small datasets**: Fewer than 50 rows that don't require pagination
- **Read-only data**: Information that users only need to view, not interact with
- **Simple layouts**: Basic tables without complex features like sorting or filtering
- **Documentation and reference**: Help content, glossaries, or static lists

### When to upgrade to DataTable

Consider upgrading to the [DataTable component](/components/data-display/data-table) when you need:

- **Sorting**: Allow users to sort columns in ascending or descending order
- **Row selection**: Enable users to select one or multiple rows for bulk actions
- **Column management**: Let users show/hide, reorder, or resize columns
- **Search and filtering**: Help users find specific data within large datasets
- **Pagination**: Handle datasets with more than 50 rows efficiently
- **Server-side operations**: Support for server-side sorting, filtering, and pagination
- **Nested data**: Display hierarchical data with expandable rows
- **Dense data visualization**: Use condensed row spacing for data-heavy interfaces

**Quick decision guide:**

| Feature | Table | DataTable |
|---------|-------|-----------|
| Static display | ✓ | ✓ |
| Sorting | ✗ | ✓ |
| Selection | ✗ | ✓ |
| Filtering | ✗ | ✓ |
| Pagination | ✗ | ✓ |
| Column resizing | ✗ | ✓ |
| Best for | < 20 rows | > 20 rows |

## Usage examples

### Size variants

The `size` prop controls padding and text size. Available sizes are `sm`, `md` (default), and `lg`:

```jsx live-dev
const App = () => {
  const [size, setSize] = useState('md');

  const data = [
    { name: 'Alice Johnson', role: 'Admin', email: 'alice@example.com' },
    { name: 'Bob Smith', role: 'User', email: 'bob@example.com' },
  ];

  return (
    <Stack gap="400">
      <Stack direction="row" gap="300">
        <Button
          variant={size === 'sm' ? 'solid' : 'outline'}
          colorPalette="primary"
          onPress={() => setSize('sm')}
        >
          Small
        </Button>
        <Button
          variant={size === 'md' ? 'solid' : 'outline'}
          colorPalette="primary"
          onPress={() => setSize('md')}
        >
          Medium
        </Button>
        <Button
          variant={size === 'lg' ? 'solid' : 'outline'}
          colorPalette="primary"
          onPress={() => setSize('lg')}
        >
          Large
        </Button>
      </Stack>
      <Table.Root size={size}>
        <Table.Header>
          <Table.Row>
            <Table.ColumnHeader>Name</Table.ColumnHeader>
            <Table.ColumnHeader>Role</Table.ColumnHeader>
            <Table.ColumnHeader>Email</Table.ColumnHeader>
          </Table.Row>
        </Table.Header>
        <Table.Body>
          {data.map((row, idx) => (
            <Table.Row key={idx}>
              <Table.Cell>{row.name}</Table.Cell>
              <Table.Cell>{row.role}</Table.Cell>
              <Table.Cell>{row.email}</Table.Cell>
            </Table.Row>
          ))}
        </Table.Body>
      </Table.Root>
    </Stack>
  );
}
```

### Visual variants

The `variant` prop controls the table's visual style. Available variants are `line` (default) and `outline`:

```jsx live-dev
const App = () => {
  const [variant, setVariant] = useState('line');

  const orders = [
    { id: '#1001', customer: 'John Doe', total: '$450.00', status: 'Shipped' },
    { id: '#1002', customer: 'Jane Smith', total: '$320.00', status: 'Processing' },
    { id: '#1003', customer: 'Bob Wilson', total: '$180.00', status: 'Delivered' },
  ];

  return (
    <Stack gap="400">
      <Stack direction="row" gap="300">
        <Button
          variant={variant === 'line' ? 'solid' : 'outline'}
          colorPalette="primary"
          onPress={() => setVariant('line')}
        >
          Line
        </Button>
        <Button
          variant={variant === 'outline' ? 'solid' : 'outline'}
          colorPalette="primary"
          onPress={() => setVariant('outline')}
        >
          Outline
        </Button>
      </Stack>
      <Table.Root variant={variant}>
        <Table.Header>
          <Table.Row>
            <Table.ColumnHeader>Order ID</Table.ColumnHeader>
            <Table.ColumnHeader>Customer</Table.ColumnHeader>
            <Table.ColumnHeader>Total</Table.ColumnHeader>
            <Table.ColumnHeader>Status</Table.ColumnHeader>
          </Table.Row>
        </Table.Header>
        <Table.Body>
          {orders.map((order) => (
            <Table.Row key={order.id}>
              <Table.Cell>{order.id}</Table.Cell>
              <Table.Cell>{order.customer}</Table.Cell>
              <Table.Cell>{order.total}</Table.Cell>
              <Table.Cell>
                <Badge
                  colorPalette={
                    order.status === 'Delivered' ? 'positive' :
                    order.status === 'Shipped' ? 'info' : 'warning'
                  }
                >
                  {order.status}
                </Badge>
              </Table.Cell>
            </Table.Row>
          ))}
        </Table.Body>
      </Table.Root>
    </Stack>
  );
}
```

### Sticky headers

Use `stickyHeader` to keep the table header visible when scrolling. Combine with `Table.ScrollArea` for scrollable content:

```jsx live-dev
const App = () => {
  const transactions = Array.from({ length: 20 }, (_, i) => ({
    id: `TXN-${1000 + i}`,
    date: `2024-01-${String(i + 1).padStart(2, '0')}`,
    description: `Transaction ${i + 1}`,
    amount: `$${(Math.random() * 500 + 50).toFixed(2)}`,
  }));

  return (
    <Table.ScrollArea maxHeight="300px">
      <Table.Root stickyHeader>
        <Table.Header>
          <Table.Row>
            <Table.ColumnHeader>Transaction ID</Table.ColumnHeader>
            <Table.ColumnHeader>Date</Table.ColumnHeader>
            <Table.ColumnHeader>Description</Table.ColumnHeader>
            <Table.ColumnHeader textAlign="end">Amount</Table.ColumnHeader>
          </Table.Row>
        </Table.Header>
        <Table.Body>
          {transactions.map((txn) => (
            <Table.Row key={txn.id}>
              <Table.Cell>{txn.id}</Table.Cell>
              <Table.Cell>{txn.date}</Table.Cell>
              <Table.Cell>{txn.description}</Table.Cell>
              <Table.Cell textAlign="end">{txn.amount}</Table.Cell>
            </Table.Row>
          ))}
        </Table.Body>
      </Table.Root>
    </Table.ScrollArea>
  );
}
```

### Column borders

Show vertical borders between columns with the `showColumnBorder` prop:

```jsx live-dev
const App = () => {
  const metrics = [
    { metric: 'Revenue', q1: '$125K', q2: '$150K', q3: '$180K', q4: '$200K' },
    { metric: 'Customers', q1: '450', q2: '520', q3: '610', q4: '720' },
    { metric: 'Growth Rate', q1: '12%', q2: '15%', q3: '18%', q4: '22%' },
  ];

  return (
    <Table.Root variant="outline" showColumnBorder>
      <Table.Header>
        <Table.Row>
          <Table.ColumnHeader>Metric</Table.ColumnHeader>
          <Table.ColumnHeader textAlign="end">Q1</Table.ColumnHeader>
          <Table.ColumnHeader textAlign="end">Q2</Table.ColumnHeader>
          <Table.ColumnHeader textAlign="end">Q3</Table.ColumnHeader>
          <Table.ColumnHeader textAlign="end">Q4</Table.ColumnHeader>
        </Table.Row>
      </Table.Header>
      <Table.Body>
        {metrics.map((row, idx) => (
          <Table.Row key={idx}>
            <Table.Cell fontWeight="medium">{row.metric}</Table.Cell>
            <Table.Cell textAlign="end">{row.q1}</Table.Cell>
            <Table.Cell textAlign="end">{row.q2}</Table.Cell>
            <Table.Cell textAlign="end">{row.q3}</Table.Cell>
            <Table.Cell textAlign="end">{row.q4}</Table.Cell>
          </Table.Row>
        ))}
      </Table.Body>
    </Table.Root>
  );
}
```

### Table with caption

Use `Table.Caption` to provide a title or description for the table:

```jsx live-dev
const App = () => {
  const schedule = [
    { time: '9:00 AM', event: 'Team Checkpoint', location: 'Conference Room A' },
    { time: '11:00 AM', event: 'Design Review', location: 'Meeting Room 3' },
    { time: '2:00 PM', event: 'Client Presentation', location: 'Virtual' },
  ];

  return (
    <Table.Root variant="outline">
      <Table.Caption>Today's Schedule - January 8, 2026</Table.Caption>
      <Table.Header>
        <Table.Row>
          <Table.ColumnHeader>Time</Table.ColumnHeader>
          <Table.ColumnHeader>Event</Table.ColumnHeader>
          <Table.ColumnHeader>Location</Table.ColumnHeader>
        </Table.Row>
      </Table.Header>
      <Table.Body>
        {schedule.map((item, idx) => (
          <Table.Row key={idx}>
            <Table.Cell>{item.time}</Table.Cell>
            <Table.Cell>{item.event}</Table.Cell>
            <Table.Cell>{item.location}</Table.Cell>
          </Table.Row>
        ))}
      </Table.Body>
    </Table.Root>
  );
}
```

### Table with footer

Use `Table.Footer` to display summary information or totals at the bottom of the table:

```jsx live-dev
const App = () => {
  const expenses = [
    { category: 'Office Supplies', amount: 450.00 },
    { category: 'Software Licenses', amount: 1200.00 },
    { category: 'Travel', amount: 850.00 },
    { category: 'Marketing', amount: 2100.00 },
  ];

  const total = expenses.reduce((sum, item) => sum + item.amount, 0);

  return (
    <Table.Root variant="outline">
      <Table.Header>
        <Table.Row>
          <Table.ColumnHeader>Category</Table.ColumnHeader>
          <Table.ColumnHeader textAlign="end">Amount</Table.ColumnHeader>
        </Table.Row>
      </Table.Header>
      <Table.Body>
        {expenses.map((expense, idx) => (
          <Table.Row key={idx}>
            <Table.Cell>{expense.category}</Table.Cell>
            <Table.Cell textAlign="end">${expense.amount.toFixed(2)}</Table.Cell>
          </Table.Row>
        ))}
      </Table.Body>
      <Table.Footer>
        <Table.Row>
          <Table.Cell fontWeight="bold">Total</Table.Cell>
          <Table.Cell textAlign="end" fontWeight="bold">
            ${total.toFixed(2)}
          </Table.Cell>
        </Table.Row>
      </Table.Footer>
    </Table.Root>
  );
}
```

## Component requirements

## Accessibility

The Table component follows semantic HTML table structure and WCAG 2.1 AA guidelines.

**Role**: The component uses native HTML table elements (`<table>`, `<thead>`, `<tbody>`, `<tr>`, `<th>`, `<td>`) which have implicit ARIA roles.

**Labeling**:
- Use `Table.ColumnHeader` for header cells (renders `<th>`) to provide column labels
- Consider adding `aria-label` or `aria-labelledby` to `Table.Root` for complex tables
- Use `Table.Caption` to provide a descriptive title for the table

**Keyboard Navigation**:
- Tables are not interactive by default
- If making rows clickable, ensure they are keyboard accessible
- For interactive tables, consider adding `tabIndex={0}` to focusable elements

If your use case requires tracking and analytics for this component, it is good practice to add a **persistent**, **unique** id to the component:

```tsx
const PERSISTENT_ID = "product-inventory-table";

export const InventoryTable = () => (
  <Table.Root id={PERSISTENT_ID}>
    <Table.Header>
      <Table.Row>
        <Table.ColumnHeader>Product</Table.ColumnHeader>
        <Table.ColumnHeader>Stock</Table.ColumnHeader>
      </Table.Row>
    </Table.Header>
    <Table.Body>
      {/* table rows */}
    </Table.Body>
  </Table.Root>
);
```

## Compound component API

The Table component uses a compound component pattern with multiple sub-components that work together. Each part accepts standard HTML table element props plus Chakra style props.

### Available sub-components

| Component | Description |
|-----------|-------------|
| `Table.Root` | Main container that provides styling and configuration for the entire table |
| `Table.Header` | Container for the table header row(s) (renders `<thead>`) |
| `Table.Body` | Container for the table data rows (renders `<tbody>`) |
| `Table.Footer` | Container for footer rows with summary or totals (renders `<tfoot>`) |
| `Table.Row` | Individual table row (renders `<tr>`) |
| `Table.ColumnHeader` | Header cell for column labels (renders `<th>`) |
| `Table.Cell` | Data cell for table content (renders `<td>`) |
| `Table.Caption` | Table caption for providing a title or description (renders `<caption>`) |
| `Table.ScrollArea` | Wrapper for scrollable tables with sticky header support |

## API reference

<PropsTable id="Table" />

## Common patterns

### Data density

Use size variants to control information density based on use case:

```tsx
// Dense data tables (dashboards, reports)
<Table.Root size="sm">
  {/* Compact spacing for scanning many rows */}
</Table.Root>

// Standard tables (most use cases)
<Table.Root size="md">
  {/* Balanced spacing */}
</Table.Root>

// Spacious tables (forms, configuration)
<Table.Root size="lg">
  {/* More whitespace for interaction */}
</Table.Root>
```

### Empty states

Handle empty data gracefully with a message in the table body:

```tsx
<Table.Root>
  <Table.Header>
    <Table.Row>
      <Table.ColumnHeader>Name</Table.ColumnHeader>
      <Table.ColumnHeader>Email</Table.ColumnHeader>
    </Table.Row>
  </Table.Header>
  <Table.Body>
    {data.length === 0 ? (
      <Table.Row>
        <Table.Cell colSpan={2} textAlign="center" py="600">
          <Text color="fg.muted">No data available</Text>
        </Table.Cell>
      </Table.Row>
    ) : (
      data.map((row) => (
        <Table.Row key={row.id}>
          <Table.Cell>{row.name}</Table.Cell>
          <Table.Cell>{row.email}</Table.Cell>
        </Table.Row>
      ))
    )}
  </Table.Body>
</Table.Root>
```

### Loading states

Show loading states while fetching data:

```tsx
const [isLoading, setIsLoading] = useState(true);
const [data, setData] = useState([]);

return (
  <Table.Root>
    <Table.Header>
      <Table.Row>
        <Table.ColumnHeader>Name</Table.ColumnHeader>
        <Table.ColumnHeader>Status</Table.ColumnHeader>
      </Table.Row>
    </Table.Header>
    <Table.Body>
      {isLoading ? (
        <Table.Row>
          <Table.Cell colSpan={2} textAlign="center" py="600">
            <Text>Loading...</Text>
          </Table.Cell>
        </Table.Row>
      ) : (
        data.map((row) => (
          <Table.Row key={row.id}>
            <Table.Cell>{row.name}</Table.Cell>
            <Table.Cell>{row.status}</Table.Cell>
          </Table.Row>
        ))
      )}
    </Table.Body>
  </Table.Root>
);
```

### Numeric alignment

Align numeric columns to the right for better readability:

```tsx
<Table.Root>
  <Table.Header>
    <Table.Row>
      <Table.ColumnHeader>Product</Table.ColumnHeader>
      <Table.ColumnHeader textAlign="end">Price</Table.ColumnHeader>
      <Table.ColumnHeader textAlign="end">Quantity</Table.ColumnHeader>
      <Table.ColumnHeader textAlign="end">Total</Table.ColumnHeader>
    </Table.Row>
  </Table.Header>
  <Table.Body>
    {items.map((item) => (
      <Table.Row key={item.id}>
        <Table.Cell>{item.product}</Table.Cell>
        <Table.Cell textAlign="end">{item.price}</Table.Cell>
        <Table.Cell textAlign="end">{item.quantity}</Table.Cell>
        <Table.Cell textAlign="end">{item.total}</Table.Cell>
      </Table.Row>
    ))}
  </Table.Body>
</Table.Root>
```

## Testing your implementation

These examples demonstrate how to test your implementation when using Table within your application. As the component's internal functionality is already tested by Nimbus, these patterns help you verify your integration and application-specific logic.

{{docs-tests: table.docs.spec.tsx}}

## Resources

- [Chakra UI - Table Documentation](https://chakra-ui.com/docs/components/table)
- [MDN - HTML Table Element](https://developer.mozilla.org/en-docs/Web/HTML/Element/table)
- [WCAG - Table Accessibility](https://www.w3.org/WAI/tutorials/tables/)

**Related components**

- **[DataTable Component](/components/data-display/data-table)** - Upgrade to DataTable when you need sorting, filtering, selection, pagination, or other interactive features for complex data management
