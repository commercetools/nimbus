---
id: Components-FieldErrors
title: FieldErrors
description:
  Renders error messages based on error object configuration for form validation feedback
documentState: InitialDraft
order: 999
menu:
  - Components
  - Forms
  - FieldErrors
tags:
  - component
  - form
  - validation
  - errors
---

# Field errors

Context specific, localized error messages for individual form fields.

## Overview

The field errors component is a vital utility for user-friendly form validation, responsible for displaying context-specific, localized error messages for individual form fields. It ensures users receive clear, immediate feedback on validation issues, maintaining a consistent and accessible experience.

### Resources

Deep dive into implementation details and access the Nimbus design library.

[Figma library](https://www.figma.com/design/AvtPX6g7OGGCRvNlatGOIY/NIMBUS-design-system?m=auto&node-id=5818-15877)
[Storybook](https://nimbus-storybook.vercel.app/?path=/docs/components-fielderrors--docs)


## Variables

Get familiar with the features.

### Visual elements
**Color:** Default critical red color is typical for field errors, and a yellow warning color for issues that are less critical. Custom colors can be added, but make sure that there is a reason to use something different from known error best practices.

**Placement:** Field errors are located below the field that it is associated with.


```jsx-live
const App = () => (
    <Stack direction="column" gap="200">
      <FieldErrors
        errors={{ critical: true }}
        isVisible={true}
        renderError={(key) => {
          if (key === "critical") {
            return "This is an error with a critical color.";
          }
          return null;
        }}
      />
      <FieldErrors
        errors={{ warning: true }}
        isVisible={true}
        colorPalette="warning"
        renderError={(key) => {
          if (key === "warning") {
            return "This is an error with a warning color.";
          }
          return null;
        }}
      />
    </Stack>
);
```


## Built-in error types
These error types are included for `aboveMax`, `belowMin`, `blocked`, `duplicate`, `empty`, `format`, `fractions`, `invalid`, `invalidFromServer`, `max`, `min`, `missing`, `negative`, `notFound`, `outOfRange`.

```jsx-live
const App = () => (
  <FieldErrors
    errors={{
      missing: true,
      invalid: true,
      empty: true,
      min: true,
      max: true,
      format: true,
      duplicate: true,
      negative: true,
      fractions: true,
      belowMin: true,
      aboveMax: true,
      outOfRange: true,
      invalidFromServer: true,
      notFound: true,
      blocked: true,
    }}
    isVisible={true}
  />
);
```

### With custom errors
You may use custom error text, read best practices with custom text recommendations within the guideline section. 


```jsx-live
const App = () => (
  <Box>
    <FieldErrors
      errors={{
        customError: true,
        lengthError: true,
        formatError: true,
        duplicateError: true,
        positiveError: true,
        serverError: true,
      }}
      isVisible={true}
      renderError={(key) => {
        let message;
        let icon;
        switch (key) {
          case "customError":
            message = "Hey! You forgot something important!";
            icon = <Icons.Whatshot/>;
            break;
          case "lengthError":
            message = "This needs to be longer!";
            icon = <Icons.Straighten />;
            break;
          case "formatError":
            message = "Please use the correct format!";
            icon = <Icons.TheaterComedy />;
            break;
          case "duplicateError":
            message = "This value is already taken!";
            icon = <Icons.RepeatOn />;
            break;
          case "positiveError":
            message = "Only positive numbers allowed!";
            icon = <Icons.BarChart />;
            break;
          case "serverError":
            message = "Server says no-no!";
            icon = <Icons.Announcement />;
            break;
          default:
            return null; // Return null to fall back to built-in error handling
        }
        return (
          <Flex gap="100" alignItems="center">
            <Icon color="critical.11">
              {icon}
            </Icon>
            {message}
          </Flex>
        );
      }}
    />
  </Box>
);
```

## Accessibility

Accessibility ensures that digital content and functionality are usable by everyone, including people with disabilities, by addressing visual, auditory, cognitive, and physical limitations.


```jsx-live
const App = () => (
  <FieldErrors
    errors={{ critical: true }}
    isVisible={true}
    renderError={(key) => {
      if (key === "critical") {
        return "Provide your name to continue.";
      }
      return null;
    }}
  />
);
```

### Accessibility standards

 - **Instant announcement:** The root container uses `role="alert"` to trigger screen readers to immediately announce error messages when they become visible, providing critical, instant feedback to the user.
 - **WCAG contrast:** The default critical color palette provides sufficient contrast for the error text to meet WCAG AA standards. This must be maintained when using custom colors.
 - **Actionable messaging:** Error messages should use clear, plain language that focuses on what the user needs to do to fix the problem, not just what went wrong (e.g., "Password must be at least 8 characters" instead of "Length validation failed").
 - **Association:** When integrated with the FormField component, errors are automatically associated with their input fields via ARIA, helping screen readers clearly link the error message to the field that caused it.
 - **Color is supplemental:** Color (red tones) is used as a supplemental indicator; the text content itself provides the error information, meeting WCAG requirements for users with color vision deficiencies.
 - **Visibility control:** Always tie `isVisible` to the field's interaction state (touched or blurred) to prevent users from hearing confusing announcements before they've had a chance to input data.