---
id: Components-FieldErrors
title: FieldErrors
description:
  Renders error messages based on error object configuration for form validation feedback
documentState: InitialDraft
order: 999
menu:
  - Components
  - Forms
  - FieldErrors
tags:
  - component
  - form
  - validation
  - errors
---

# FieldErrors

Renders error messages based on error object configuration, providing localized
validation feedback for form fields. Designed for seamless integration with form
libraries like Formik while maintaining backwards compatibility with UI-Kit FieldErrors.

## Overview

The FieldErrors component is a utility component that takes an error object and
renders user-friendly error messages. It supports built-in localized messages for
common validation scenarios, custom error renderers for application-specific
validation rules, and flexible customization options.

Unlike standalone UI components, FieldErrors is designed to integrate with form
state management and reduce the burden of localizing and displaying validation
errors across multiple applications.

## Basic Usage

The simplest usage renders built-in error messages for common validation scenarios:

```jsx-live
const App = () => {
  const [errors, setErrors] = React.useState({ missing: true });

  return (
    <Stack direction="column" gap="16px">
      <div>
        <label htmlFor="example-field">Required Field *</label>
        <input
          id="example-field"
          type="text"
          style={{
            marginLeft: "8px",
            padding: "4px 8px",
            border: "1px solid #ccc",
            borderRadius: "4px"
          }}
        />
        <FieldErrors
          id="example-field-errors"
          errors={errors}
          isVisible={true}
        />
      </div>

      <Button
        variant="outline"
        onPress={() => setErrors(prev => ({ ...prev, missing: !prev.missing }))}
      >
        Toggle Missing Error
      </Button>
    </Stack>
  );
};
```

## Built-in Error Types

FieldErrors includes comprehensive built-in error types organized by category:

### Basic Validation Errors

```jsx-live
const App = () => (
  <Stack direction="column" gap="16px">
    <div>
      <strong>Missing Required Field:</strong>
      <FieldErrors errors={{ missing: true }} isVisible={true} />
    </div>

    <div>
      <strong>Invalid Value:</strong>
      <FieldErrors errors={{ invalid: true }} isVisible={true} />
    </div>

    <div>
      <strong>Empty Value:</strong>
      <FieldErrors errors={{ empty: true }} isVisible={true} />
    </div>
  </Stack>
);
```

### Length Validation Errors

```jsx-live
const App = () => (
  <Stack direction="column" gap="16px">
    <div>
      <strong>Value Too Short:</strong>
      <FieldErrors errors={{ min: true }} isVisible={true} />
    </div>

    <div>
      <strong>Value Too Long:</strong>
      <FieldErrors errors={{ max: true }} isVisible={true} />
    </div>
  </Stack>
);
```

### Format Validation Errors

```jsx-live
const App = () => (
  <Stack direction="column" gap="16px">
    <div>
      <strong>Invalid Format:</strong>
      <FieldErrors errors={{ format: true }} isVisible={true} />
    </div>

    <div>
      <strong>Duplicate Value:</strong>
      <FieldErrors errors={{ duplicate: true }} isVisible={true} />
    </div>
  </Stack>
);
```

### Numeric Validation Errors

```jsx-live
const App = () => (
  <Stack direction="column" gap="16px">
    <div>
      <strong>Negative Number Not Allowed:</strong>
      <FieldErrors errors={{ negative: true }} isVisible={true} />
    </div>

    <div>
      <strong>Whole Number Required:</strong>
      <FieldErrors errors={{ fractions: true }} isVisible={true} />
    </div>

    <div>
      <strong>Value Below Minimum:</strong>
      <FieldErrors errors={{ belowMin: true }} isVisible={true} />
    </div>

    <div>
      <strong>Value Above Maximum:</strong>
      <FieldErrors errors={{ aboveMax: true }} isVisible={true} />
    </div>

    <div>
      <strong>Value Out of Range:</strong>
      <FieldErrors errors={{ outOfRange: true }} isVisible={true} />
    </div>
  </Stack>
);
```

### Server/Async Validation Errors

```jsx-live
const App = () => (
  <Stack direction="column" gap="16px">
    <div>
      <strong>Server Validation Failed:</strong>
      <FieldErrors errors={{ invalidFromServer: true }} isVisible={true} />
    </div>

    <div>
      <strong>Resource Not Found:</strong>
      <FieldErrors errors={{ notFound: true }} isVisible={true} />
    </div>

    <div>
      <strong>Value Blocked:</strong>
      <FieldErrors errors={{ blocked: true }} isVisible={true} />
    </div>
  </Stack>
);
```

## Custom Error Messages

For application-specific validation rules, use the `renderError` prop to provide
custom error messages:

```jsx-live
const App = () => {
  const errors = {
    missing: true,
    duplicate: true,
    minLength: true,
    format: true
  };

  const renderCustomError = (key) => {
    switch (key) {
      case "duplicate":
        return "This value is already in use. Please choose a unique value.";
      case "minLength":
        return "This field requires at least 3 characters.";
      case "format":
        return "Please use only letters and numbers.";
      default:
        return null; // Fall back to built-in error handling
    }
  };

  return (
    <div>
      <strong>Custom Error Messages:</strong>
      <FieldErrors
        errors={errors}
        isVisible={true}
        renderError={renderCustomError}
      />
    </div>
  );
};
```

## Hierarchical Error Handling

FieldErrors supports a three-tier error handling system for maximum flexibility:

1. **Custom errors** (via `renderError`) - highest priority
2. **Default errors** (via `renderDefaultError`) - fallback for custom errors
3. **Built-in errors** - fallback for unhandled errors

```jsx-live
const App = () => {
  const errors = {
    critical: true,    // Handled by renderError
    warning: true,     // Handled by renderDefaultError
    missing: true,     // Handled by built-in error system
    unknown: true      // Not handled - won't render
  };

  return (
    <div>
      <strong>Hierarchical Error Handling:</strong>
      <FieldErrors
        errors={errors}
        isVisible={true}
        renderError={(key) => {
          if (key === "critical") {
            return "ðŸš¨ Critical validation error!";
          }
          return null; // Pass to renderDefaultError
        }}
        renderDefaultError={(key) => {
          if (key === "warning") {
            return "âš ï¸ This field has a warning.";
          }
          return null; // Pass to built-in error handling
        }}
      />
    </div>
  );
};
```

## Custom Messages for Built-in Types

Override the default messages for built-in error types while maintaining their
validation logic:

```jsx-live
const App = () => (
  <Stack direction="column" gap="24px">
    <div>
      <strong>Custom Messages for Basic Validation:</strong>
      <FieldErrors
        errors={{ missing: true, invalid: true, empty: true }}
        isVisible={true}
        customMessages={{
          missing: "ðŸ”¥ Hey, you forgot something important!",
          invalid: "âŒ That doesn't look right to me!",
          empty: "ðŸ“ Please add some content here!"
        }}
      />
    </div>

    <div>
      <strong>Custom Messages for Length Validation:</strong>
      <FieldErrors
        errors={{ min: true, max: true }}
        isVisible={true}
        customMessages={{
          min: "ðŸ“ This needs to be longer!",
          max: "âœ‚ï¸ This is too long, please shorten it!"
        }}
      />
    </div>

    <div>
      <strong>Custom Messages for Format Validation:</strong>
      <FieldErrors
        errors={{ format: true, duplicate: true }}
        isVisible={true}
        customMessages={{
          format: "ðŸŽ­ Please use the correct format!",
          duplicate: "ðŸ”„ This value is already taken!"
        }}
      />
    </div>

    <div>
      <strong>Custom Messages for Numeric Validation:</strong>
      <FieldErrors
        errors={{ negative: true, belowMin: true, outOfRange: true }}
        isVisible={true}
        customMessages={{
          negative: "ðŸ“Š Only positive numbers allowed!",
          belowMin: "ðŸ“ˆ Value must be at least 10!",
          outOfRange: "ðŸŽ¯ Please enter a value between 1 and 100!"
        }}
      />
    </div>
  </Stack>
);
```

## Form Integration Example

Real-world example showing integration with form state:

```jsx-live
const App = () => {
  const [formData, setFormData] = React.useState({
    email: "",
    age: ""
  });
  const [errors, setErrors] = React.useState({});
  const [touched, setTouched] = React.useState({});

  const validateField = (name, value) => {
    const fieldErrors = {};

    if (name === "email") {
      if (!value) {
        fieldErrors.missing = true;
      } else if (!/\S+@\S+\.\S+/.test(value)) {
        fieldErrors.format = true;
      }
    }

    if (name === "age") {
      if (!value) {
        fieldErrors.missing = true;
      } else if (isNaN(value) || parseInt(value) < 0) {
        fieldErrors.negative = true;
      } else if (value.includes('.')) {
        fieldErrors.fractions = true;
      }
    }

    return fieldErrors;
  };

  const handleChange = (name, value) => {
    setFormData(prev => ({ ...prev, [name]: value }));
    setErrors(prev => ({ ...prev, [name]: validateField(name, value) }));
  };

  const handleBlur = (name) => {
    setTouched(prev => ({ ...prev, [name]: true }));
  };

  return (
    <Stack direction="column" gap="16px" maxWidth="400px">
      <div>
        <label htmlFor="email-field">Email Address *</label>
        <input
          id="email-field"
          type="email"
          value={formData.email}
          onChange={(e) => handleChange("email", e.target.value)}
          onBlur={() => handleBlur("email")}
          style={{
            display: "block",
            width: "100%",
            padding: "8px 12px",
            border: "1px solid #ccc",
            borderRadius: "4px",
            marginTop: "4px"
          }}
        />
        <FieldErrors
          id="email-errors"
          errors={errors.email}
          isVisible={touched.email}
          renderError={(key) => {
            if (key === "format") {
              return "Please enter a valid email address.";
            }
            return null;
          }}
        />
      </div>

      <div>
        <label htmlFor="age-field">Age *</label>
        <input
          id="age-field"
          type="number"
          value={formData.age}
          onChange={(e) => handleChange("age", e.target.value)}
          onBlur={() => handleBlur("age")}
          style={{
            display: "block",
            width: "100%",
            padding: "8px 12px",
            border: "1px solid #ccc",
            borderRadius: "4px",
            marginTop: "4px"
          }}
        />
        <FieldErrors
          id="age-errors"
          errors={errors.age}
          isVisible={touched.age}
        />
      </div>
    </Stack>
  );
};
```

## Migration from UI-Kit

FieldErrors maintains full backwards compatibility with the UI-Kit version.
Existing code will work without changes:

```jsx
// UI-Kit usage (still works)
<FieldErrors
  errors={{ missing: true, duplicate: true }}
  isVisible={formik.touched.fieldName}
  renderError={(key) => {
    switch (key) {
      case 'duplicate':
        return 'This value must be unique.';
      default:
        return null;
    }
  }}
/>
```

### Enhanced API

The Nimbus version adds optional enhancements while maintaining compatibility:

- **customMessages** - Override built-in error messages
- **Automatic visibility** - Future versions will handle visibility automatically
- **Better TypeScript support** - Enhanced type definitions
- **Improved styling** - Integration with Nimbus design tokens

<PropsTable id="FieldErrors" />

## Accessibility

- Uses `role="alert"` to announce errors to screen readers
- Provides proper ARIA labeling when `id` prop is used
- Maintains focus management integration with form fields
- Supports high contrast and reduced motion preferences

## Best Practices

### Do's
- Use built-in error types for common validation scenarios
- Provide clear, actionable error messages
- Combine with proper form field labeling and ARIA attributes
- Test error messages with screen readers

### Don'ts
- Don't duplicate error handling logic across components
- Avoid overly technical error messages for end users
- Don't show all errors at once - respect the `isVisible` pattern
- Don't forget to handle the `null` return case in custom renderers

## Related Components

- **FormField** - Wrapper for form inputs with integrated error display
- **TextInput** - Text input component that works with FieldErrors
- **NumberInput** - Number input with built-in validation support