---
title: PasswordInput Component
tab-title: Implementation
tab-order: 3
---

## Getting started

### Import

```tsx
import { PasswordInput, type PasswordInputProps } from '@commercetools/nimbus';
```

### Basic usage

The simplest implementation uses uncontrolled mode:

```jsx-live-dev
const App = () => (
  <PasswordInput placeholder="Enter your password" />
)
```

## Usage examples

### Size options

The `sm` and `md` size variants are available to match your interface density:

```jsx-live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <PasswordInput size="sm" placeholder="Small password input" />
    <PasswordInput size="md" placeholder="Medium password input (default)" />
  </Stack>
)
```

### Visual variants

Choose between `solid` and `ghost` variants to match your design context:

```jsx-live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <PasswordInput variant="solid" placeholder="Solid variant (default)" />
    <PasswordInput variant="ghost" placeholder="Ghost variant" />
  </Stack>
)
```

### With leading element

Add an icon or other element at the start of the input:

```jsx-live-dev
const App = () => {
  const { Lock } = Icons;

  return (
    <Stack direction="column" gap="400">
      <PasswordInput
        size="sm"
        leadingElement={<Icon as={Lock} />}
        placeholder="Small with icon"
      />
      <PasswordInput
        size="md"
        leadingElement={<Icon as={Lock} />}
        placeholder="Medium with icon"
      />
    </Stack>
  );
}
```

**Behavioral notes:**
- Leading element automatically respects text direction (LTR/RTL)
- Icon sizing automatically adjusts based on the `size` prop
- The visibility toggle button always appears at the end of the input

### Disabled state

Disable input interaction with the `isDisabled` prop:

```jsx-live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <PasswordInput placeholder="Enabled input" />
    <PasswordInput placeholder="Disabled input" isDisabled />
    <PasswordInput
      value="SecretPassword123"
      isDisabled
      onChange={() => {}}
    />
  </Stack>
)
```

### Invalid state

Mark inputs as invalid for validation feedback:

```jsx-live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <PasswordInput
      placeholder="Valid password"
      value="StrongPass123!"
      onChange={() => {}}
    />
    <PasswordInput
      placeholder="Invalid password"
      value="weak"
      isInvalid
      onChange={() => {}}
    />
  </Stack>
)
```

### Read-only state

Use `isReadOnly` to display values without allowing editing:

```jsx-live-dev
const App = () => (
  <Stack direction="column" gap="400">
    <PasswordInput
      value="EditablePassword123"
      onChange={() => {}}
      placeholder="Editable password"
    />
    <PasswordInput
      value="ReadOnlyPassword456"
      isReadOnly
      onChange={() => {}}
      placeholder="Read-only password"
    />
  </Stack>
)
```

### Uncontrolled mode

For simpler use cases, use uncontrolled mode with `defaultValue` and `onChange`:

```jsx-live-dev
const App = () => {
  const [displayValue, setDisplayValue] = useState<string>('');

  return (
    <Stack direction="column" gap="400">
      <PasswordInput
        placeholder="Type your password..."
        defaultValue=""
        onChange={(value) => {
          setDisplayValue(value);
        }}
      />
      <Text fontSize="sm">Current value: {displayValue || '(empty)'}</Text>
    </Stack>
  );
}
```

Use uncontrolled mode when you need to capture the password value without managing state yourself.

**Note:** PasswordInput's `onChange` receives the string value directly, not an event object.

### Controlled mode

For scenarios requiring programmatic control or validation, use controlled mode:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<string>('');

  return (
    <Stack direction="column" gap="400">
      <PasswordInput
        value={value}
        onChange={(value) => setValue(value)}
        placeholder="Controlled password"
      />
      <Text fontSize="sm">
        {value ? `You typed: ${value}` : 'Start typing...'}
      </Text>
      <Button onClick={() => setValue('')} size="xs">
        Clear
      </Button>
    </Stack>
  );
}
```

Use controlled mode when you need to:
- Synchronize the value with external state
- Validate password strength in real-time
- Clear or programmatically set the value
- Coordinate with other form fields

## Component requirements

### Accessibility

The PasswordInput handles most accessibility requirements internally, including the show/hide password button with internationalized labels. However, you must always associate an internationalized label with the component. Visual labels are preferable, and can be set by using the [`PasswordInputField`](patterns/fields/passwordinputfield) pattern component.

If your design requires that the label should not be visible, the label should be set using the `aria-label` prop:

```tsx
<PasswordInput aria-label={intl.formatMessage(passwordMessage)} />
```

If your use case requires tracking and analytics for this component, it is good practice to add a **persistent**, **unique** id to the component:

```tsx
const PERSISTENT_ID = "example-password-input";

export const Example = () => (
  <PasswordInput id={PERSISTENT_ID} aria-label="Password" />
);
```

#### Keyboard navigation

The component supports full keyboard interaction:
- `Tab` / `Shift+Tab`: Move focus to/from the input field and visibility toggle button
- `Enter` / `Space`: When the visibility toggle button is focused, toggles password visibility
- Standard text input editing: All standard keyboard shortcuts for text editing work in the input field

## API reference

<PropsTable id="PasswordInput" />

## Common patterns

### Password confirmation

A common pattern for password entry with confirmation:

```jsx-live-dev
const App = () => {
  const [password, setPassword] = useState<string>('');
  const [confirmPassword, setConfirmPassword] = useState<string>('');

  const passwordsMatch = password === confirmPassword && password !== "";
  const showMismatch = confirmPassword !== "" && !passwordsMatch;

  return (
    <Stack direction="column" gap="400">
      <PasswordInput
        value={password}
        onChange={setPassword}
        placeholder="Enter password"
      />
      <PasswordInput
        value={confirmPassword}
        onChange={setConfirmPassword}
        isInvalid={showMismatch}
        placeholder="Confirm password"
      />
      {showMismatch && (
        <Text fontSize="sm" color="critical.11">
          Passwords do not match
        </Text>
      )}
      {passwordsMatch && (
        <Text fontSize="sm" color="positive.11">
          Passwords match
        </Text>
      )}
    </Stack>
  );
}
```

### Password strength indicator

Integrate with password strength validation:

```jsx-live-dev
const App = () => {
  const [password, setPassword] = useState<string>('');

  const getStrength = (pass: string) => {
    if (!pass) return { label: "No password", color: "neutral.11" };
    if (pass.length < 6) return { label: "Weak", color: "critical.11" };
    if (pass.length < 10) return { label: "Medium", color: "warning.11" };
    return { label: "Strong", color: "positive.11" };
  };

  const strength = getStrength(password);

  return (
    <Stack direction="column" gap="400">
      <PasswordInput
        value={password}
        onChange={setPassword}
        placeholder="Enter password"
      />
      <Text fontSize="sm" color={strength.color}>
        Strength: {strength.label}
      </Text>
      <Text fontSize="xs" color="neutral.11">
        Use at least 10 characters for a strong password
      </Text>
    </Stack>
  );
}
```

## Testing your implementation

These examples demonstrate how to test your implementation when using PasswordInput in your application. The component's internal functionality is already tested by Nimbus - these patterns help you verify your integration and application-specific logic.

### Basic rendering tests

Verify the component renders with expected elements:

```tsx
import { render, screen } from '@testing-library/react';
import { PasswordInput } from '@commercetools/nimbus';

describe('PasswordInput', () => {
  it('renders password input field', () => {
    render(<PasswordInput aria-label="Password" />);

    // Verify input is present with password type
    const input = screen.getByLabelText('Password');
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute('type', 'password');
  });

  it('renders visibility toggle button', () => {
    render(<PasswordInput aria-label="Password" />);

    // Verify toggle button is present
    const toggleButton = screen.getByRole('button');
    expect(toggleButton).toBeInTheDocument();
  });
});
```

### Interaction tests

Test user interactions with the component:

```tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { PasswordInput } from '@commercetools/nimbus';

describe('PasswordInput interactions', () => {
  it('toggles password visibility when button is clicked', async () => {
    const user = userEvent.setup();
    render(<PasswordInput aria-label="Password" />);

    const input = screen.getByLabelText('Password');
    const toggleButton = screen.getByRole('button');

    // Initially type is password
    expect(input).toHaveAttribute('type', 'password');

    // Click to show password
    await user.click(toggleButton);
    expect(input).toHaveAttribute('type', 'text');

    // Click again to hide password
    await user.click(toggleButton);
    expect(input).toHaveAttribute('type', 'password');
  });

  it('calls onChange with entered value', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();
    render(<PasswordInput aria-label="Password" onChange={handleChange} />);

    const input = screen.getByLabelText('Password');
    await user.type(input, 'Secret123');

    expect(handleChange).toHaveBeenCalled();
    expect(input).toHaveValue('Secret123');
  });
});
```

### Testing controlled mode

Test controlled state management:

```tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { useState } from 'react';
import { PasswordInput } from '@commercetools/nimbus';

const ControlledPasswordInput = () => {
  const [value, setValue] = useState('');
  return (
    <>
      <PasswordInput
        aria-label="Password"
        value={value}
        onChange={setValue}
      />
      <div data-testid="value-display">{value}</div>
    </>
  );
};

describe('PasswordInput controlled mode', () => {
  it('updates controlled value', async () => {
    const user = userEvent.setup();
    render(<ControlledPasswordInput />);

    const input = screen.getByLabelText('Password');
    const valueDisplay = screen.getByTestId('value-display');

    await user.type(input, 'MyPassword');

    expect(input).toHaveValue('MyPassword');
    expect(valueDisplay).toHaveTextContent('MyPassword');
  });

  it('clears controlled value', async () => {
    const user = userEvent.setup();
    render(<ControlledPasswordInput />);

    const input = screen.getByLabelText('Password');

    await user.type(input, 'Test');
    expect(input).toHaveValue('Test');

    await user.clear(input);
    expect(input).toHaveValue('');
  });
});
```

### Testing keyboard navigation

Test keyboard interactions:

```tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { PasswordInput } from '@commercetools/nimbus';

describe('PasswordInput keyboard navigation', () => {
  it('toggles visibility with Enter key', async () => {
    const user = userEvent.setup();
    render(<PasswordInput aria-label="Password" />);

    const input = screen.getByLabelText('Password');
    const toggleButton = screen.getByRole('button');

    // Focus the toggle button
    toggleButton.focus();
    expect(toggleButton).toHaveFocus();

    // Press Enter to toggle
    await user.keyboard('{Enter}');
    expect(input).toHaveAttribute('type', 'text');

    // Press Space to toggle back
    await user.keyboard(' ');
    expect(input).toHaveAttribute('type', 'password');
  });

  it('moves focus between input and button with Tab', async () => {
    const user = userEvent.setup();
    render(<PasswordInput aria-label="Password" />);

    const input = screen.getByLabelText('Password');
    const toggleButton = screen.getByRole('button');

    // Tab to input
    await user.tab();
    expect(input).toHaveFocus();

    // Tab to toggle button
    await user.tab();
    expect(toggleButton).toHaveFocus();
  });
});
```

## Resources

- [Storybook](https://nimbus-storybook.vercel.app/?path=/docs/components-passwordinput--docs)
- [PasswordInputField Pattern](/patterns/fields/passwordinputfield)
- [TextInput Component](/components/inputs/textinput)
- [React Aria TextField](https://react-spectrum.adobe.com/react-aria/TextField.html)
