---
id: DataDisplay-DataTable
title: DataTable
description: A component that renders data sets in a tabular format
documentState: InitialDraft
order: 999
menu:
  - Components
  - Data Display
  - DataTable
tags:
  - component
  - table
  - data
figmaLink: >-
  https://www.figma.com/design/gHbAJGfcrCv7f2bgzUQgHq/NIMBUS-Guidelines?node-id=4256-4285&m=dev
---

## Data Table

Data tables display sets of data across rows and columns. Use them to organize information, enable comparisons, and allow users to inspect and interact with large datasets.

### Overview

Data tables are essential tools for presenting sets of data in a structured format, utilizing rows and columns to enhance clarity. 
They serve multiple purposes: organizing information systematically, facilitating comparisons between different data points, 
and providing users with the ability to thoroughly inspect and interact with extensive datasets. By incorporating features such as sorting,
 filtering, and pagination, data tables empower users to navigate through large volumes of information efficiently, 
 making them invaluable in data analysis and reporting.


## Resources

Deep dive into details and access the Nimbus design library

[Figma library](https://www.figma.com/design/gHbAJGfcrCv7f2bgzUQgHq/NIMBUS-Guidelines?node-id=4256-4285&m=dev)

### Variables

Get familiar with the features. 

#### Visual options

**Data table base:**
Click on any row to open the product details modal. Edit the fields and click Save to see the changes reflected in the data table. Table is sorted by Date Modified (newest first) by default. 

**Bulk selection:**
Users can make bulk selections by selecting the checkbox in the table header to select all visible rows, or by choosing multiple rows at once. 
To clear, users can uncheck the boxes or click on the header checkbox to select all and then unselect all at once.

**Text highlight and copy:**
We’ve made improvements to this feature, you can now highlight text to make easier to copy and use for users workflows. 
Clicking outside the text within the box will open details, but clicks made over the text will allow for selection, highlight and copying.

**Column resizing**

This component allows for columns to be resized. It is helpful when there is a lot of data and columns can be restricted or grown by the user to show more information.

```jsx-live
const App = () => {
  const data = [
    { id: 1, name: 'Product A', modified: '2023-10-27' },
    { id: 2, name: 'Product B', modified: '2023-10-26' },
  ];
  const columns = [
    { 
      id: 'name',
      header: "Name",
      accessor: (row) => row.name, 
      isResizable: true, 
    },
    { 
      id: 'modified',
      header: "Date Modified",
      accessor: (row) => row.modified, 
      isResizable: true,
    },
  ];
  return <DataTable rows={data} columns={columns} />;
}
```

**Search and highlight**

Adding a search field close to the data table that will refine the shown data to show the user relevant information is extremely helpful to users.


```jsx-live
const App = () => {
  const data = [
    { id: 1, name: 'Product A', modified: '2023-10-27' },
    { id: 2, name: 'Product B', modified: '2023-10-26' },
  ];
  const columns = [
    { 
      id: 'name',
      header: "Name",
      accessor: (row) => row.name, 
    },
    { 
      id: 'modified',
      header: "Date Modified",
      accessor: (row) => row.modified, 
    },
  ];

  const [search, setSearch] = useState("");

  return <Stack gap={16}>
    <TextInput
      value={search}
      onChange={setSearch}
      placeholder="Search..."
      width="1/3"
      aria-label="search-rows"
      data-testid="search-input"
    />
    <DataTable
      rows={data}
      columns={columns}
      search={search}
    />
  </Stack>
}
```

**Controlled sorting**

The sorting state is controlled externally and can be programmatically changed. This can be applied to some and not all the headers if more control is needed, or to simplify if the need is less for some columns of data.


```jsx-live
const App = () => {
  const data = [
    { id: 1, name: 'Product A', modified: '2023-10-27' },
    { id: 2, name: 'Product B', modified: '2023-10-26' },
  ];
  const columns = [
    { 
      id: 'name',
      header: "Name",
      accessor: (row) => row.name, 
      isSortable: true,
    },
    { 
      id: 'modified',
      header: "Date Modified",
      accessor: (row) => row.modified, 
      isSortable: true,
    },
  ];
  const [sortDescriptor, setSortDescriptor] = useState({
      column: "modified",
      direction: "ascending",
    });

  return <Stack gap={16}>
    <Button
      onPress={() =>
        setSortDescriptor({ column: "name", direction: "ascending" })
      }
      variant="outline"
      width="2xs"
    >
    Sort by Name (A-Z)
    </Button>
    <DataTable
      rows={data}
      columns={columns}
      onSortChange={setSortDescriptor}
      sortDescriptor={sortDescriptor}
    />
  </Stack>
}
```

**Condensed**

To show more data in smaller spaces, condense the vertical padding. This setting is also included in the data table manager if giving control to users to choose a more condensed styling is appealing for the placement of a data table. 

```jsx-live
const App = () => {
  const data = [
    { id: 1, name: 'Product A', modified: '2023-10-27' },
    { id: 2, name: 'Product B', modified: '2023-10-26' },
  ];
  
  const columns = [
    { 
      id: 'name',
      header: "Name",
      accessor: (row) => row.name, 
    },
    { 
      id: 'modified',
      header: "Date Modified",
      accessor: (row) => row.modified, 
    },
  ];

  const [condensed, setCondensed] = useState(false);

  return <Stack gap={16}>
    <Checkbox
      isSelected={condensed}
      onChange={setCondensed}
    >
      Condensed
    </Checkbox>
    <DataTable
      rows={data}
      columns={columns}
      density={condensed ? "condensed" : "default"}
    />
  </Stack>
}
```

**Sticky header**

We encourage using sticky headers as default on data tables. Keeping context by utilizing sticky users is important when scrolling long rows of data. 
Make sure to give it a maxHeight value when you use the sticky header feature.

```jsx-live
const App = () => {
  const data = [
    { id: 1, name: 'Product A', modified: '2023-10-27' },
    { id: 2, name: 'Product B', modified: '2023-10-26' },
  ];
  
  const columns = [
    { 
      id: 'name',
      header: "Name",
      accessor: (row) => row.name, 
    },
    { 
      id: 'modified',
      header: "Date Modified",
      accessor: (row) => row.modified, 
    },
  ];

  const [sticky, setSticky] = useState(false);

  return <Stack gap={16}>
    <Checkbox
      isSelected={sticky}
      onChange={setSticky}
    >
      Sticky header (with max height)
    </Checkbox>
    <DataTable
      rows={data}
      columns={columns}
      maxHeight={sticky ? "400px" : undefined}
    />
  </Stack>
}
```

**Nested content**

Nested tables can be used to show related or detailed information about a given row in a data table. Make it obvious to users that there is more information in this area.

```jsx-live
const App = () => {
  const data = [
    { 
      id: 1, 
      name: 'Product A', 
      modified: '2023-10-27',
      children: (
        <Box p={16}>
          <DataTable
            rows={[
              { id: 'a1', variant: 'Size S', stock: 150 },
              { id: 'a2', variant: 'Size M', stock: 200 },
              { id: 'a3', variant: 'Size L', stock: 180 },
            ]}
            columns={[
              { id: 'variant', header: 'Variant', accessor: (row) => row.variant },
              { id: 'stock', header: 'Stock', accessor: (row) => row.stock },
            ]}
          />
        </Box>
      ),
    },
    { 
      id: 2, 
      name: 'Product B', 
      modified: '2023-10-26',
      children: (
        <Box p={16}>
          <DataTable
            rows={[
              { id: 'b1', variant: 'Color Red', stock: 75 },
              { id: 'b2', variant: 'Color Blue', stock: 90 },
            ]}
            columns={[
              { id: 'variant', header: 'Variant', accessor: (row) => row.variant },
              { id: 'stock', header: 'Stock', accessor: (row) => row.stock },
            ]}
          />
        </Box>
      ),
    },
  ];
  const columns = [
    { 
      id: 'name',
      header: "Name",
      accessor: (row) => row.name, 
      isResizable: true, 
    },
    { 
      id: 'modified',
      header: "Date Modified",
      accessor: (row) => row.modified, 
      isResizable: true,
    },
  ];
  return <DataTable rows={data} columns={columns} nestedKey="children" />;
}
```

**Pinned rows**

Using pins can allow users to keep certain rows of data to the top of the data table. These keep commonly referenced information in a predictable areas for users to return to often. 

```jsx-live
const App = () => {
  const data = [
    { id: 1, name: 'Product A', modified: '2023-10-27' },
    { id: 2, name: 'Product B', modified: '2023-10-26' },
  ];
  const columns = [
    { 
      id: 'name',
      header: "Name",
      accessor: (row) => row.name, 
      isResizable: true, 
    },
    { 
      id: 'modified',
      header: "Date Modified",
      accessor: (row) => row.modified, 
      isResizable: true,
    },
  ];
  return <DataTable rows={data} columns={columns} />;
}
```

### Guidelines
---

These guidelines provide comprehensive direction for designing and developing data tables within Nimbus.

#### Best practices

- **Display relevant data:** Only include columns and data necessary for the user's current task. Avoid overwhelming users with excessive information.

- **Allow for customization:** Allow users to organize and display important information in a way that suits their preferences, whether that means viewing more data on a single screen or having a table manager to add or reorder columns.
The more customizable the workspace, the more effective users will be in completing their tasks.

- **Keep column headers concise:** Use clear, brief labels for column headers to ensure quick understanding.

- **Use sticky column headers:** Keep headers visible when users scroll vertically through a long table.
Offer sorting and filtering: Include mechanisms to sort data by any column and filter the dataset to help users find specific information.

#### Usage

Data tables are great for displaying large sets of information that can have different statuses or data that needs to be compared. Users can click through for more information held in modals or further detail pages. 

> [!TIP]\
> When to use

- Presenting complex, structured data.
- Comparing different attributes of multiple items.
- Allowing users to analyze and manipulate large datasets.
- Where bulk actions are being made, it can make sense to have users make selections from a data table.

> [!CAUTION]\
> When not to use

- Presenting simple lists of items.
- Displaying content with complex, varying layouts (use card or a grid layout).
- Presenting an action-focused list where the primary interaction is on the whole item.
- Within a small space where a user will need to scroll multiple directions in a frustrating way to understand the information presented.
- To display information that is not meant to be read in the format of a data table like long blocks of text.

#### Tags and tag group in use 

> [!TIP]\
> **Do**
> - Do keep the table design simple and focused on data.
> - Do provide clear visual feedback on the currently sorted column.
> - Do ensure all interactive elements within the table are accessible (e.g., buttons, links).
> - Do allow users to select one or multiple rows where needed.

```jsx-live
const App = () => {
  const data = [
    { id: 1, name: 'Product A', modified: '2023-10-27', status: "Published" },
    { id: 2, name: 'Product B', modified: '2023-10-26', status: "Modified" },
  ];
  const columns = [
    { 
      id: 'name',
      header: "Name",
      accessor: (row) => row.name, 
      isSortable: true,
    },
    { 
      id: 'modified',
      header: "Date Modified",
      accessor: (row) => row.modified, 
      isSortable: true,
    },
    {
      id: "status",
      header: "Status",
      isSortable: true,
      accessor: (row) => row.status,
      render: ({ value }) => {
        let colorPalette;
        switch (value) {
          case "Published":
            colorPalette = "positive";
            break;
          case "Modified":
            colorPalette = "warning";
            break;
          default:
            colorPalette = "neutral";
        }

        return (
          <Badge colorPalette={colorPalette} size="xs">
            {value}
          </Badge>
        );
      },
  },
  ];
  return <DataTable
    rows={data}
    columns={columns}
    selectionMode={"multiple"} 
  />;
}
```

> [!CAUTION]\
> **Don't**
> - Don’t overcomplicate the layout with too many visual elements or unnecessary actions.
> - Don’t force horizontal scrolling on the user unless absolutely necessary for the data.
> - Don’t use tables only for layout purposes; they are for data only.

```jsx-live
const App = () => {
  const data = [
  {
    id: 1,
    blogTitle: "How to increase sales with abandoned cart discounts.",
    readBlog:
      "One highly effective strategy to recover revenue from abandoned shopping carts is the targeted use of cart discounts, which serve as a final, personalized incentive to encourage conversion. By analyzing the items in the abandoned cart and the customer's shopping history, retailers can deploy an automated, time-sensitive email offering a specific discount—such as a percentage off, a fixed dollar amount, or free shipping—designed to overcome the specific price sensitivity or hesitation that caused the abandonment. This direct appeal mitigates the perceived cost or barrier, making the original purchase seem more valuable and urgent, significantly increasing the likelihood that the customer will return to complete their transaction...",
  },
  {
    id: 2,
    blogTitle :"Want to know how Buy One Get One works? ",
    readBlog:
      "Want to know how Buy One Get One works? ', readBlog: 'You know those Buy One, Get One (BOGO) deals? They're super popular because they're basically magic for getting people to shop. The idea is simple: you buy one thing at the regular price and get the second one for free or maybe half-off. It works so well because everyone loves getting something for nothing, which makes us buy more than we planned. That's a win-win: the customer feels like they got a steal, and the store boosts its sales and clears out all that extra stuff that's just sitting on the shelves.",
  },
];
  const columns = [
    { 
      id: 'blogTitle',
      header: "Blog title",
      accessor: (row) => row.blogTitle, 
      render: ({value}) => {
         return (
          <Box fontWeight="800">
            {value}
          </Box>
        );
      },
      isResizable: true, 
    },
    { 
      id: 'readBlog',
      header: "Read blog",
      accessor: (row) => row.readBlog, 
      isResizable: true,
    },
  ];
  return <DataTable 
    rows={data} 
    columns={columns} 
    selectionMode={"multiple"} 
  />;
}
```
