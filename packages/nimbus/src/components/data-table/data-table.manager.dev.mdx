---
title: DataTable.Manager Component
tab-title: Implementation
tab-order: 3
---

## Getting started

### Import

```tsx
import { DataTable } from '@commercetools/nimbus';
```

### Basic usage

The DataTable.Manager component provides a settings drawer for managing table configuration. It must be used within a DataTable.Root to access table state and columns:

```jsx-live-dev
const App = () => {
  const columns = [
    { id: 'name', header: 'Name', accessor: (row) => row.name },
    { id: 'email', header: 'Email', accessor: (row) => row.email },
    { id: 'role', header: 'Role', accessor: (row) => row.role },
  ];

  const rows = [
    { id: '1', name: 'Alice Johnson', email: 'alice@example.com', role: 'Admin' },
    { id: '2', name: 'Bob Smith', email: 'bob@example.com', role: 'User' },
    { id: '3', name: 'Carol Williams', email: 'carol@example.com', role: 'Editor' },
  ];

  return (
    <DataTable.Root columns={columns} rows={rows}>
      <Stack direction="row" justifyContent="space-between" mb="400">
        <Text fontSize="lg" fontWeight="600">Users</Text>
        <DataTable.Manager />
      </Stack>
      <DataTable.Table>
        <DataTable.Header />
        <DataTable.Body />
      </DataTable.Table>
    </DataTable.Root>
  );
}
```

## Usage examples

### Column visibility management

The Manager provides a dual-list interface for managing visible and hidden columns. Users can drag columns between lists, reorder visible columns, and search hidden columns:

```jsx-live-dev
const App = () => {
  const [visibleColumns, setVisibleColumns] = useState(['name', 'email']);

  const columns = [
    { id: 'name', header: 'Name', accessor: (row) => row.name },
    { id: 'email', header: 'Email', accessor: (row) => row.email },
    { id: 'role', header: 'Role', accessor: (row) => row.role },
    { id: 'department', header: 'Department', accessor: (row) => row.department },
  ];

  const rows = [
    { id: '1', name: 'Alice Johnson', email: 'alice@example.com', role: 'Admin', department: 'Engineering' },
    { id: '2', name: 'Bob Smith', email: 'bob@example.com', role: 'User', department: 'Sales' },
  ];

  return (
    <DataTable.Root
      columns={columns}
      rows={rows}
      visibleColumns={visibleColumns}
      onColumnsChange={(updatedColumns) => {
        setVisibleColumns(updatedColumns.map(col => col.id));
      }}
    >
      <Stack direction="row" justifyContent="space-between" mb="400">
        <Text fontSize="lg" fontWeight="600">Team Members</Text>
        <DataTable.Manager />
      </Stack>
      <DataTable.Table>
        <DataTable.Header />
        <DataTable.Body />
      </DataTable.Table>
    </DataTable.Root>
  );
}
```

### Layout settings

The Layout Settings tab allows users to control text truncation and row density. These settings update the table's visual appearance in real-time:

```jsx-live-dev
const App = () => {
  const [isTruncated, setIsTruncated] = useState(false);
  const [density, setDensity] = useState('default');

  const columns = [
    { id: 'name', header: 'Name', accessor: (row) => row.name },
    { id: 'description', header: 'Description', accessor: (row) => row.description },
  ];

  const rows = [
    {
      id: '1',
      name: 'Product A',
      description: 'This is a very long description that will demonstrate text truncation when enabled'
    },
    {
      id: '2',
      name: 'Product B',
      description: 'Another lengthy description to show how the layout settings affect content display'
    },
  ];

  const handleSettingsChange = (action) => {
    if (action === 'TOGGLE_TEXT_VISIBILITY') {
      setIsTruncated(!isTruncated);
    } else if (action === 'TOGGLE_ROW_DENSITY') {
      setDensity(density === 'default' ? 'condensed' : 'default');
    }
  };

  return (
    <DataTable.Root
      columns={columns}
      rows={rows}
      isTruncated={isTruncated}
      density={density}
      onSettingsChange={handleSettingsChange}
    >
      <Stack direction="row" justifyContent="space-between" mb="400">
        <Text fontSize="lg" fontWeight="600">Products</Text>
        <DataTable.Manager />
      </Stack>
      <DataTable.Table>
        <DataTable.Header />
        <DataTable.Body />
      </DataTable.Table>
    </DataTable.Root>
  );
}
```

### Custom settings tab

Add a custom settings tab by providing the `customSettings` prop to DataTable.Root. This allows extending the Manager with application-specific configuration:

```jsx-live-dev
const App = () => {
  const [filterStatus, setFilterStatus] = useState('all');

  const columns = [
    { id: 'name', header: 'Name', accessor: (row) => row.name },
    { id: 'status', header: 'Status', accessor: (row) => row.status },
  ];

  const allRows = [
    { id: '1', name: 'Task A', status: 'Active' },
    { id: '2', name: 'Task B', status: 'Inactive' },
    { id: '3', name: 'Task C', status: 'Active' },
  ];

  const filteredRows = filterStatus === 'all'
    ? allRows
    : allRows.filter(row => row.status.toLowerCase() === filterStatus);

  const customSettingsPanel = (
    <Stack direction="column" gap="400">
      <Text fontWeight="600">Filter Options</Text>
      <ToggleButtonGroup.Root
        selectedKeys={[filterStatus]}
        onSelectionChange={(keys) => setFilterStatus(Array.from(keys)[0])}
      >
        <ToggleButton id="all">All</ToggleButton>
        <ToggleButton id="active">Active</ToggleButton>
        <ToggleButton id="inactive">Inactive</ToggleButton>
      </ToggleButtonGroup.Root>
    </Stack>
  );

  return (
    <DataTable.Root
      columns={columns}
      rows={filteredRows}
      customSettings={{
        label: 'Filters',
        icon: <Icons.FilterList />,
        panel: customSettingsPanel,
      }}
    >
      <Stack direction="row" justifyContent="space-between" mb="400">
        <Text fontSize="lg" fontWeight="600">Tasks</Text>
        <DataTable.Manager />
      </Stack>
      <DataTable.Table>
        <DataTable.Header />
        <DataTable.Body />
      </DataTable.Table>
    </DataTable.Root>
  );
}
```

### Controlled column state with persistence

Manage column configuration externally for features like saving user preferences:

```jsx-live-dev
const App = () => {
  const [visibleColumns, setVisibleColumns] = useState(['name', 'email', 'role']);

  const columns = [
    { id: 'name', header: 'Name', accessor: (row) => row.name },
    { id: 'email', header: 'Email', accessor: (row) => row.email },
    { id: 'role', header: 'Role', accessor: (row) => row.role },
    { id: 'department', header: 'Department', accessor: (row) => row.department },
    { id: 'location', header: 'Location', accessor: (row) => row.location },
  ];

  const rows = [
    {
      id: '1',
      name: 'Alice Johnson',
      email: 'alice@example.com',
      role: 'Admin',
      department: 'Engineering',
      location: 'New York'
    },
  ];

  const handleColumnsChange = (updatedColumns) => {
    const newVisibleColumns = updatedColumns.map(col => col.id);
    setVisibleColumns(newVisibleColumns);

    // Example: Save to localStorage
    localStorage.setItem('tableColumns', JSON.stringify(newVisibleColumns));
  };

  return (
    <Stack direction="column" gap="400">
      <DataTable.Root
        columns={columns}
        rows={rows}
        visibleColumns={visibleColumns}
        onColumnsChange={handleColumnsChange}
      >
        <Stack direction="row" justifyContent="space-between" mb="400">
          <Text fontSize="lg" fontWeight="600">Team Directory</Text>
          <DataTable.Manager />
        </Stack>
        <DataTable.Table>
          <DataTable.Header />
          <DataTable.Body />
        </DataTable.Table>
      </DataTable.Root>
      <Text fontSize="sm" color="gray.9">
        Visible columns: {visibleColumns.join(', ')}
      </Text>
    </Stack>
  );
}
```

## Component requirements

### Accessibility

The DataTable.Manager handles most accessibility requirements internally. The settings button has a proper accessible label and the drawer content is keyboard navigable.

The Manager drawer provides:
- **Proper ARIA labels** for all interactive elements
- **Keyboard navigation** throughout all tabs and controls
- **Screen reader announcements** for state changes
- **Focus management** when opening and closing the drawer

If your use case requires tracking and analytics for this component, it is good practice to add a **persistent**, **unique** id to the DataTable.Root:

```tsx
const PERSISTENT_ID = "users-data-table";

export const Example = () => (
  <DataTable.Root id={PERSISTENT_ID} columns={columns} rows={rows}>
    <DataTable.Manager />
    <DataTable.Table>
      <DataTable.Header />
      <DataTable.Body />
    </DataTable.Table>
  </DataTable.Root>
);
```

#### Keyboard navigation

The Manager and its drawer support full keyboard interaction:
- `Tab` / `Shift+Tab`: Navigate between the settings button, tabs, and controls
- `Enter` / `Space`: Open the Manager drawer, activate tabs, toggle buttons
- `Arrow keys`: Navigate between tab panels, reorder items in drag-and-drop lists
- `Escape`: Close the Manager drawer
- Drag-and-drop keyboard operations: `Space` to pick up, arrow keys to move, `Space` to drop

### Context requirements

DataTable.Manager **must** be used within a DataTable.Root component. It relies on the DataTable context for:
- Column configuration (`columns`, `visibleColumns`)
- Layout settings (`isTruncated`, `density`)
- Callbacks (`onColumnsChange`, `onSettingsChange`)
- Custom settings configuration

Using Manager outside of DataTable.Root will throw an error.

## API reference

<PropsTable id="DataTableManager" />

## Common patterns

### Save user preferences

Persist column visibility and layout settings across sessions:

```jsx-live-dev
const App = () => {
  // Load saved preferences on mount
  const [visibleColumns, setVisibleColumns] = useState(() => {
    const saved = localStorage.getItem('userTableColumns');
    return saved ? JSON.parse(saved) : ['name', 'email'];
  });

  const [isTruncated, setIsTruncated] = useState(() => {
    const saved = localStorage.getItem('userTableTruncated');
    return saved ? JSON.parse(saved) : false;
  });

  const columns = [
    { id: 'name', header: 'Name', accessor: (row) => row.name },
    { id: 'email', header: 'Email', accessor: (row) => row.email },
    { id: 'role', header: 'Role', accessor: (row) => row.role },
  ];

  const rows = [
    { id: '1', name: 'Alice Johnson', email: 'alice@example.com', role: 'Admin' },
  ];

  const handleColumnsChange = (updatedColumns) => {
    const ids = updatedColumns.map(col => col.id);
    setVisibleColumns(ids);
    localStorage.setItem('userTableColumns', JSON.stringify(ids));
  };

  const handleSettingsChange = (action) => {
    if (action === 'TOGGLE_TEXT_VISIBILITY') {
      const newValue = !isTruncated;
      setIsTruncated(newValue);
      localStorage.setItem('userTableTruncated', JSON.stringify(newValue));
    }
  };

  return (
    <DataTable.Root
      columns={columns}
      rows={rows}
      visibleColumns={visibleColumns}
      isTruncated={isTruncated}
      onColumnsChange={handleColumnsChange}
      onSettingsChange={handleSettingsChange}
    >
      <Stack direction="row" justifyContent="space-between" mb="400">
        <Text fontSize="lg" fontWeight="600">My Dashboard</Text>
        <DataTable.Manager />
      </Stack>
      <DataTable.Table>
        <DataTable.Header />
        <DataTable.Body />
      </DataTable.Table>
    </DataTable.Root>
  );
}
```

### Reset to defaults

Provide a way for users to restore default column configuration:

```jsx-live-dev
const App = () => {
  const defaultColumns = ['name', 'email'];
  const [visibleColumns, setVisibleColumns] = useState(defaultColumns);

  const columns = [
    { id: 'name', header: 'Name', accessor: (row) => row.name },
    { id: 'email', header: 'Email', accessor: (row) => row.email },
    { id: 'role', header: 'Role', accessor: (row) => row.role },
    { id: 'department', header: 'Department', accessor: (row) => row.department },
  ];

  const rows = [
    { id: '1', name: 'Alice Johnson', email: 'alice@example.com', role: 'Admin', department: 'Engineering' },
  ];

  const handleColumnsChange = (updatedColumns) => {
    setVisibleColumns(updatedColumns.map(col => col.id));
  };

  const handleReset = () => {
    setVisibleColumns(defaultColumns);
  };

  return (
    <Stack direction="column" gap="400">
      <DataTable.Root
        columns={columns}
        rows={rows}
        visibleColumns={visibleColumns}
        onColumnsChange={handleColumnsChange}
      >
        <Stack direction="row" justifyContent="space-between" mb="400">
          <Text fontSize="lg" fontWeight="600">Employees</Text>
          <Stack direction="row" gap="200">
            <Button variant="ghost" size="xs" onClick={handleReset}>
              Reset Columns
            </Button>
            <DataTable.Manager />
          </Stack>
        </Stack>
        <DataTable.Table>
          <DataTable.Header />
          <DataTable.Body />
        </DataTable.Table>
      </DataTable.Root>
      <Text fontSize="sm" color="gray.9">
        {visibleColumns.length} of {columns.length} columns visible
      </Text>
    </Stack>
  );
}
```

## Testing your implementation

These examples demonstrate how to test your implementation when using DataTable.Manager in your application. As the component's internal functionality is already tested by Nimbus, these patterns help you verify your integration and application-specific logic.

{{docs-tests: data-table.manager.docs.spec.tsx}}

## Resources

- [Storybook](link-tbd)
- [DataTable Component](/components/data-display/datatable)
- [Drawer Component](/components/overlay/drawer)
- [DraggableList Component](/components/data-display/draggablelist)
