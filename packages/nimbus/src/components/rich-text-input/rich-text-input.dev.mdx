---
title: Rich text input component
tab-title: Implementation
tab-order: 3
---

## Getting started

### Import

```tsx
import { RichTextInput, type RichTextInputProps } from '@commercetools/nimbus';
```

### Basic usage

The simplest implementation uses uncontrolled mode:

```jsx live-dev
const App = () => (
  <RichTextInput placeholder="Start typing..." />
)
```

## Working with Slate.js and HTML values

The RichTextInput relies on Slate.js for rich text editing capabilities. Slate.js is a customizable framework for building rich text editors in React. While Slate.js uses its own internal data structure, RichTextInput handles conversion to and from HTML automatically.

### HTML value format

RichTextInput accepts and returns HTML strings for the `value`, `defaultValue`, and `onChange` props:

```tsx
// Example HTML value
const htmlValue = `
<p>This is a <strong>paragraph</strong> with formatting.</p>
<h2>This is a heading</h2>
<ul>
  <li>List item 1</li>
  <li>List item 2</li>
</ul>
`;
```

### Supported HTML elements

RichTextInput supports these HTML elements through the formatting toolbar:

- **Paragraphs**: `<p>`
- **Headings**: `<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`
- **Text formatting**: `<strong>` (bold), `<em>` (italic), `<u>` (underline), `<del>` (strikethrough)
- **Lists**: `<ul>` (unordered), `<ol>` (ordered), `<li>` (list items)
- **Code**: `<code>` (inline), `<pre><code>` (code block)
- **Quotes**: `<blockquote>`
- **Links**: `<a href="...">`
- **Subscript/Superscript**: `<sub>`, `<sup>`

### Internal conversion

RichTextInput automatically handles conversion between HTML and Slate.js's internal format:

1. **Input**: HTML string → Slate.js structure (when setting `value` or `defaultValue`)
2. **Output**: Slate.js structure → HTML string (when calling `onChange`)

You don't need to work with Slate.js types directly - just provide and receive HTML strings.

> [!TIP]\
> For advanced use cases requiring direct Slate.js manipulation, see the [Slate.js documentation](https://docs.slatejs.org/) for complete API reference.

## Usage examples

### Uncontrolled mode

Use `defaultValue` for simple forms where you don't need to control the value:

```jsx live-dev
const App = () => {
  const handleSubmit = (event) => {
    event.preventDefault();
    const formData = new FormData(event.currentTarget);
    const content = formData.get('content');
    console.log('Submitted content:', content);
  };

  return (
    <form onSubmit={handleSubmit}>
      <Stack direction="column" gap="400">
        <RichTextInput
          name="content"
          defaultValue="<p>Edit this <strong>content</strong>!</p>"
          placeholder="Enter your content..."
        />
        <Button type="submit">Submit</Button>
      </Stack>
    </form>
  );
};
```

### Controlled mode

Use `value` and `onChange` when you need to manage the editor state:

```jsx live-dev
const App = () => {
  const [value, setValue] = React.useState<RichTextInputProps['value']>(
    '<p>This is <strong>controlled</strong> content.</p>'
  );

  return (
    <Stack direction="column" gap="400">
      <RichTextInput
        value={value}
        onChange={setValue}
        placeholder="Type something..."
      />
      <Stack direction="column" gap="200">
        <Text fontWeight="600">Current HTML value:</Text>
        <Box
          padding="300"
          backgroundColor="neutral.2"
          borderRadius="200"
          maxHeight="200px"
          overflow="auto"
        >
          <Text fontFamily="mono" fontSize="300">
            {value}
          </Text>
        </Box>
      </Stack>
    </Stack>
  );
};
```

### With placeholder

Show helpful placeholder text when the editor is empty:

```jsx live-dev
const App = () => (
  <RichTextInput placeholder="Enter your blog post content here..." />
)
```

### With default value

Initialize the editor with existing content:

```jsx live-dev
const App = () => (
  <RichTextInput
    defaultValue={`
      <h2>Welcome to Rich Text Editing</h2>
      <p>This editor supports <strong>bold</strong>, <em>italic</em>, and <u>underlined</u> text.</p>
      <ul>
        <li>Create bullet lists</li>
        <li>Format text with the toolbar</li>
        <li>Use keyboard shortcuts</li>
      </ul>
    `}
  />
)
```

### Disabled state

Prevent editing with the `isDisabled` prop:

```jsx live-dev
const App = () => (
  <RichTextInput
    isDisabled
    defaultValue="<p>This editor is <strong>disabled</strong> and cannot be edited.</p>"
  />
)
```

### Read-only state

Display content without editing capabilities (toolbar is hidden):

```jsx live-dev
const App = () => (
  <RichTextInput
    isReadOnly
    defaultValue={`
      <h3>Read-Only Content</h3>
      <p>This content can be <strong>selected</strong> but not <em>edited</em>.</p>
      <p>Note: The toolbar is hidden in read-only mode.</p>
    `}
  />
)
```

### Invalid state

Show validation errors with the `isInvalid` prop:

```jsx live-dev
const App = () => (
  <Stack direction="column" gap="200">
    <RichTextInput
      isInvalid
      placeholder="This field is required..."
    />
    <Text color="critical.11" fontSize="350">
      Content is required
    </Text>
  </Stack>
)
```

## Component requirements

## Accessibility

RichTextInput is built with accessibility in mind and follows WCAG 2.1 AA guidelines.

#### Role

The editor exposes a `textbox` role with `contenteditable` for keyboard and screen reader accessibility.

#### Labeling

When using RichTextInput in forms, provide a visible label using FormField or a custom label element:

```jsx live-dev
const App = () => (
  <FormField.Root>
    <FormField.Label>Article Content</FormField.Label>
    <FormField.Input>
      <RichTextInput placeholder="Write your article..." />
    </FormField.Input>
    <FormField.Description>
      Use the toolbar to format your content
    </FormField.Description>
  </FormField.Root>
)
```

#### Keyboard shortcuts

RichTextInput supports standard keyboard shortcuts for formatting:

| Shortcut | Action |
|----------|--------|
| `Cmd/Ctrl + B` | Toggle bold |
| `Cmd/Ctrl + I` | Toggle italic |
| `Cmd/Ctrl + U` | Toggle underline |
| `Cmd/Ctrl + K` | Insert/edit link |
| `Cmd/Ctrl + Z` | Undo |
| `Cmd/Ctrl + Shift + Z` | Redo |
| `Tab` | Navigate between toolbar buttons |
| `Enter` | Activate focused toolbar button |

#### Persistent ID

If your use case requires tracking and analytics for this component, it is good practice to add a **persistent**, **unique** id to the component:

```tsx
<RichTextInput id="article-content-editor" />
```

## API reference

<PropsTable id="RichTextInput" />

## Common patterns

### Form integration with validation

Integrate RichTextInput with form libraries:

```jsx live-dev
const App = () => {
  const [content, setContent] = React.useState('');
  const [touched, setTouched] = React.useState(false);
  const [submitted, setSubmitted] = React.useState(false);

  const isEmpty = (html) => {
    const text = html.replace(/<[^>]*>/g, '').trim();
    return text.length === 0;
  };

  const error = (touched || submitted) && isEmpty(content)
    ? 'Content is required'
    : null;

  const handleSubmit = (event) => {
    event.preventDefault();
    setSubmitted(true);

    if (!isEmpty(content)) {
      console.log('Submitted:', content);
      alert('Form submitted successfully!');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <Stack direction="column" gap="400">
        <FormField.Root isInvalid={!!error}>
          <FormField.Label isRequired>
            Article Content
          </FormField.Label>
          <FormField.Input>
            <RichTextInput
              value={content}
              onChange={setContent}
              onBlur={() => setTouched(true)}
              placeholder="Write your article..."
              isInvalid={!!error}
            />
          </FormField.Input>
          <FormField.Description>
            Minimum 10 characters required
          </FormField.Description>
          {error && (
            <FormField.Error>{error}</FormField.Error>
          )}
        </FormField.Root>
        <Button type="submit">Submit Article</Button>
      </Stack>
    </form>
  );
};
```

### Content length validation

Validate content length by parsing HTML:

```jsx live-dev
const App = () => {
  const [content, setContent] = React.useState('');

  const getTextLength = (html) => {
    return html.replace(/<[^>]*>/g, '').trim().length;
  };

  const textLength = getTextLength(content);
  const minLength = 10;
  const maxLength = 500;
  const isValid = textLength >= minLength && textLength <= maxLength;

  return (
    <Stack direction="column" gap="400">
      <FormField.Root isInvalid={!isValid && textLength > 0}>
        <FormField.Label>Post Content</FormField.Label>
        <FormField.Input>
          <RichTextInput
            value={content}
            onChange={setContent}
            placeholder="Write your post..."
            isInvalid={!isValid && textLength > 0}
          />
        </FormField.Input>
        <Stack direction="row" justifyContent="space-between">
          <FormField.Description>
            {textLength < minLength && textLength > 0
              ? `${minLength - textLength} more characters needed`
              : textLength > maxLength
              ? `${textLength - maxLength} characters over limit`
              : 'Character count within range'}
          </FormField.Description>
          <Text
            fontSize="350"
            color={isValid || textLength === 0 ? 'neutral.11' : 'critical.11'}
          >
            {textLength} / {maxLength}
          </Text>
        </Stack>
      </FormField.Root>
    </Stack>
  );
};
```

## Testing your implementation

These examples demonstrate how to test your implementation when using RichTextInput in your application. As the component's internal functionality is already tested by Nimbus, these patterns help you verify your integration and application-specific logic.

{{docs-tests: rich-text-input.docs.spec.tsx}}

## Resources

- [RichTextInput Storybook](https://nimbus-storybook.vercel.app/?path=/docs/components-richtextinput--docs)
- [Slate.js Documentation](https://docs.slatejs.org/)
- [FormField Component](/components/inputs/formfield)
