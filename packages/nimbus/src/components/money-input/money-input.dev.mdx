---
title: MoneyInput Component
tab-title: Implementation
tab-order: 3
---

## Getting started

### Import

```tsx
import { MoneyInput, type MoneyInputProps, type MoneyInputValue } from '@commercetools/nimbus';
```

### Basic usage

The `MoneyInput` is a controlled component that manages both an amount and a currency code. It requires a `value` object and an `onValueChange` handler.

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<MoneyInputValue>({
    amount: "",
    currencyCode: "USD"
  });

  return (
    <Stack direction="column" gap="400">
      <MoneyInput
        value={value}
        currencies={["USD", "EUR", "GBP"]}
        onValueChange={setValue}
      />
      <Text fontSize="sm">
        Value: {value.amount} {value.currencyCode}
      </Text>
    </Stack>
  );
}
```

## Usage examples

### Size options

The `sm` and `md` size variants are available to match your interface density:

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<MoneyInputValue>({
    amount: "123.45",
    currencyCode: "USD"
  });

  return (
    <Stack direction="column" gap="400">
      <MoneyInput
        size="sm"
        value={value}
        currencies={["USD", "EUR"]}
        onValueChange={setValue}
      />
      <MoneyInput
        size="md"
        value={value}
        currencies={["USD", "EUR"]}
        onValueChange={setValue}
      />
    </Stack>
  );
}
```

### Currency configuration

The `currencies` prop controls the available options in the dropdown. If no currencies are provided (or an empty array is passed), the component renders a static label for the currency code instead of a dropdown.

```jsx-live-dev
const App = () => {
  const [value1, setValue1] = useState<MoneyInputValue>({
    amount: "100.00",
    currencyCode: "USD"
  });

  const [value2, setValue2] = useState<MoneyInputValue>({
    amount: "50.00",
    currencyCode: "EUR"
  });

  return (
    <Stack direction="column" gap="400">
      <Text fontWeight="bold">Multiple currencies (Dropdown)</Text>
      <MoneyInput
        value={value1}
        currencies={["USD", "EUR", "GBP", "JPY"]}
        onValueChange={setValue1}
      />

      <Text fontWeight="bold">No currencies list (Static Label)</Text>
      <MoneyInput
        value={value2}
        currencies={[]}
        onValueChange={setValue2}
      />
    </Stack>
  );
}
```

### High precision support

The `MoneyInput` automatically detects high precision values (more decimal places than standard for the currency) and displays a "High Precision" badge. This feature can be toggled with `hasHighPrecisionBadge`.

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<MoneyInputValue>({
    amount: "123.4567",
    currencyCode: "USD"
  });

  return (
    <Stack direction="column" gap="400">
      <Text fontSize="sm">
        Try entering more than 2 decimal places for USD (e.g., 123.4567)
      </Text>
      <MoneyInput
        value={value}
        currencies={["USD", "EUR"]}
        onValueChange={setValue}
        hasHighPrecisionBadge={true}
      />
    </Stack>
  );
}
```

### State variations

The component supports standard interactive states including disabled, read-only, and invalid.

```jsx-live-dev
const App = () => {
  const value = { amount: "123.45", currencyCode: "USD" };

  return (
    <Stack direction="column" gap="400">
      <MoneyInput
        aria-label="Disabled"
        value={value}
        currencies={["USD"]}
        isDisabled
      />
      <MoneyInput
        aria-label="Read-only"
        value={value}
        currencies={["USD"]}
        isReadOnly
      />
      <MoneyInput
        aria-label="Invalid"
        value={value}
        currencies={["USD"]}
        isInvalid
      />
    </Stack>
  );
}
```

### Currency input control

Use `isCurrencyInputDisabled` to disable only the currency selector while keeping the amount input editable. This is useful when the currency is predetermined but the amount should still be modifiable.

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<MoneyInputValue>({
    amount: "123.45",
    currencyCode: "USD"
  });

  return (
    <Stack direction="column" gap="400">
      <Text fontWeight="bold">Currency selector enabled</Text>
      <MoneyInput
        aria-label="Price with currency selection"
        value={value}
        currencies={["USD", "EUR", "GBP"]}
        onValueChange={setValue}
      />

      <Text fontWeight="bold">Currency selector disabled</Text>
      <MoneyInput
        aria-label="Price with fixed currency"
        value={value}
        currencies={["USD", "EUR", "GBP"]}
        onValueChange={setValue}
        isCurrencyInputDisabled
      />

      <Text fontSize="sm">
        Current value: {value.amount} {value.currencyCode}
      </Text>
    </Stack>
  );
}
```

### Modern event handlers

The component provides granular event handlers for modern integration patterns:
- `onValueChange`: Called when either amount or currency changes (recommended)
- `onAmountChange`: Called when only the amount changes
- `onCurrencyChange`: Called when only the currency changes

```jsx-live-dev
const App = () => {
  const [value, setValue] = useState<MoneyInputValue>({
    amount: "",
    currencyCode: "USD"
  });
  const [lastAmountChange, setLastAmountChange] = useState<string>("-");
  const [lastCurrencyChange, setLastCurrencyChange] = useState<string>("-");

  return (
    <Stack direction="column" gap="400">
      <MoneyInput
        value={value}
        currencies={["USD", "EUR", "GBP"]}
        onValueChange={(newValue) => {
          setValue(newValue);
        }}
        onAmountChange={(amount) => setLastAmountChange(amount || "(empty)")}
        onCurrencyChange={(code) => setLastCurrencyChange(code)}
      />
      <Stack direction="column" gap="200">
        <Text fontSize="sm">Current value: {value.amount} {value.currencyCode}</Text>
        <Text fontSize="sm">Last amount change: {lastAmountChange}</Text>
        <Text fontSize="sm">Last currency change: {lastCurrencyChange}</Text>
      </Stack>
    </Stack>
  );
}
```

## Component requirements

### Value type requirements

The `value` prop must be an object matching the `MoneyInputValue` interface:

```tsx
type MoneyInputValue = {
  amount: string;
  currencyCode: string;
};
```

Note that `amount` is a string to preserve precision and avoid floating-point errors.

### Accessibility

The `MoneyInput` handles accessibility requirements for its internal input and select components. However, you must always associate a label with the component.

Using `aria-label`:

```tsx
<MoneyInput
  aria-label="Product Price"
  value={value}
  // ...
/>
```

Using `aria-labelledby`:

```tsx
<label id="price-label">Product Price</label>
<MoneyInput
  aria-labelledby="price-label"
  value={value}
  // ...
/>
```

If your use case requires tracking and analytics for this component, it is good practice to add a **persistent**, **unique** id to the component:

```tsx
const PERSISTENT_ID = "product-price-input";

export const Example = () => (
  <MoneyInput id={PERSISTENT_ID} value={value} />
);
```

#### Keyboard navigation

The component supports full keyboard interaction:
- `Tab`: Moves focus between the currency dropdown and the amount input.
- `Arrow Keys` (in Dropdown): Navigates between currency options.
- `Enter` / `Space` (in Dropdown): Selects the currency.
- `Arrow Keys` (in Input): Adjusts the cursor position.

## API reference

<PropsTable id="MoneyInput" />

## Common patterns

### Working with locales

The `MoneyInput` uses the application's locale (via `NimbusI18nProvider`) to format numbers appropriately (e.g., using commas for decimals in German).

```jsx-live-dev
const App = () => {
  // Note: In a real app, NimbusI18nProvider would wrap the entire app
  // This example simulates different locales
  return (
    <Stack direction="column" gap="400">
      <Text fontWeight="bold">German Locale (de-DE)</Text>
      <NimbusI18nProvider locale="de-DE">
        <MoneyInput
          value={{ amount: "1234.56", currencyCode: "EUR" }}
          currencies={["EUR"]}
          isReadOnly
        />
      </NimbusI18nProvider>

      <Text fontWeight="bold">US Locale (en-US)</Text>
      <NimbusI18nProvider locale="en-US">
        <MoneyInput
          value={{ amount: "1234.56", currencyCode: "USD" }}
          currencies={["USD"]}
          isReadOnly
        />
      </NimbusI18nProvider>
    </Stack>
  );
}
```

## Testing your implementation

These examples demonstrate how to test your implementation when using MoneyInput in your application. The component's internal functionality is already tested by Nimbus - these patterns help you verify your integration and application-specific logic.

### Basic rendering tests

Verify the component renders with expected elements:

```tsx
import { render, screen } from '@testing-library/react';
import { MoneyInput } from '@commercetools/nimbus';

describe('MoneyInput', () => {
  it('renders with initial value', () => {
    const value = { amount: "100.00", currencyCode: "USD" };
    render(
      <MoneyInput
        value={value}
        currencies={["USD", "EUR"]}
        aria-label="Price"
      />
    );

    const input = screen.getByRole('textbox', { name: /price/i });
    expect(input).toHaveValue("100.00");
    expect(screen.getByText("USD")).toBeInTheDocument();
  });
});
```

### Interaction tests

Test user interactions with the currency selector and amount input:

```tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { MoneyInput } from '@commercetools/nimbus';

describe('MoneyInput interactions', () => {
  it('updates amount on type', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();
    const value = { amount: "", currencyCode: "USD" };

    render(
      <MoneyInput
        value={value}
        currencies={["USD"]}
        onValueChange={handleChange}
        aria-label="Price"
      />
    );

    const input = screen.getByRole('textbox', { name: /price/i });
    await user.type(input, "50.00");
    await user.tab(); // Blur to trigger final change if needed

    // Verify the handler was called with the new amount
    expect(handleChange).toHaveBeenCalledWith(
      expect.objectContaining({ amount: "50.00" })
    );
  });

  it('updates currency on selection', async () => {
    const user = userEvent.setup();
    const handleChange = jest.fn();
    const value = { amount: "100", currencyCode: "USD" };

    render(
      <MoneyInput
        value={value}
        currencies={["USD", "EUR"]}
        onValueChange={handleChange}
        aria-label="Price"
      />
    );

    // Open dropdown
    const trigger = screen.getByRole('button');
    await user.click(trigger);

    // Select EUR
    const option = screen.getByRole('option', { name: "EUR" });
    await user.click(option);

    expect(handleChange).toHaveBeenCalledWith(
      expect.objectContaining({ currencyCode: "EUR" })
    );
  });
});
```

### High precision tests

Test that high precision values are handled correctly:

```tsx
import { render, screen } from '@testing-library/react';
import { MoneyInput } from '@commercetools/nimbus';

describe('MoneyInput high precision', () => {
  it('shows badge for high precision values', () => {
    // USD typically has 2 decimal places. 4 decimals is high precision.
    const value = { amount: "100.1234", currencyCode: "USD" };

    render(
      <MoneyInput
        value={value}
        currencies={["USD"]}
        hasHighPrecisionBadge={true}
        aria-label="Price"
      />
    );

    const badge = screen.getByLabelText(/High precision price/i);
    expect(badge).toBeInTheDocument();
  });
});
```

## Resources

- [Storybook](https://nimbus-storybook.vercel.app/?path=/docs/components-moneyinput--docs)
- [React Aria NumberField](https://react-spectrum.adobe.com/react-aria/NumberField.html)
- [React Aria Select](https://react-spectrum.adobe.com/react-aria/Select.html)
