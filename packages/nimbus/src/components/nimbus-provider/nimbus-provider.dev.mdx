---
title: Nimbus provider component
tab-title: Implementation
tab-order: 3
---

NimbusProvider is the foundational wrapper component that provides theming, internationalization, and routing context to all Nimbus components. It must be placed at the root of your application to enable Nimbus components to function correctly.

## Getting started

### Import

```tsx
import { NimbusProvider, type NimbusProviderProps } from '@commercetools/nimbus';
```

### Minimal setup

At minimum, wrap your application root with NimbusProvider. Without configuration, it will:
- Use the default Nimbus theme with light mode
- Infer locale from the user's browser (`navigator.language`)
- Use standard anchor tag navigation (no client-side routing)

```tsx
// app/layout.tsx (Next.js) or main.tsx (Vite/CRA)
import { NimbusProvider } from '@commercetools/nimbus';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <NimbusProvider>
          {children}
        </NimbusProvider>
      </body>
    </html>
  );
}
```

## Setup guides

### Locale configuration

`NimbusProvider` accepts a `locale` prop and forwards it to `NimbusI18nProvider` internally. Specify a locale using a [BCP47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to control the language for all Nimbus components with internationalized text (date pickers, form validation messages, etc.).

```tsx
import { NimbusProvider } from '@commercetools/nimbus';

export default function App() {
  return (
    <NimbusProvider locale="de-DE">
      {/* All Nimbus components will use German locale */}
      <YourApp />
    </NimbusProvider>
  );
}
```

**Nimbus i18n supported locales:**
- `en` - English (default)
- `de` - German
- `es` - Spanish
- `fr-FR` - French (France)
- `pt-BR` - Portuguese (Brazil)

> **Note:** These are the locales supported by Nimbus component translations (compiled message dictionaries). React Aria components support many more BCP47 locale codes for date/number formatting.

**Fallback behavior:**
If no locale is provided, NimbusProvider uses `navigator.language`. If the detected locale is not available, it falls back to English.

### Font loading (Inter)

By default, NimbusProvider automatically loads the Inter font family from Google Fonts CSS API v2 with optimal settings for performance:

```tsx
import { NimbusProvider } from '@commercetools/nimbus';

export default function App() {
  return (
    <NimbusProvider>
      {/* Inter font loads automatically */}
      <YourApp />
    </NimbusProvider>
  );
}
```

**Default behavior:**
- Loads Inter with all 9 weights (100-900) to match Nimbus design tokens
- Uses `display=swap` to minimize FOUT (Flash of Unstyled Text)
- Includes preconnect links to Google Fonts origins for optimal performance
- Gracefully falls back to system fonts if Google Fonts is unavailable
- Automatically deduplicated across multiple provider instances

**Disabling font loading:**

If your application already loads the Inter font (e.g., via a separate stylesheet or Merchant Center/app-kit), set `loadFonts={false}` to avoid duplicate loading:

```tsx
import { NimbusProvider } from '@commercetools/nimbus';

export default function App() {
  return (
    <NimbusProvider loadFonts={false}>
      {/* Fonts loaded by host application */}
      <YourApp />
    </NimbusProvider>
  );
}
```

**When to disable font loading:**
- Your application already loads Inter font globally
- You're using Nimbus within Merchant Center (app-kit loads fonts)
- You want to self-host fonts instead of using Google Fonts
- You're using a different font family (not recommended for visual consistency)

**Multiple NimbusProvider instances:**

If you have nested or multiple providers on the same page, fonts are automatically deduplicated - only one set of font links is injected regardless of how many providers are rendered.

### Color mode configuration

NimbusProvider integrates with `next-themes` for color mode management. Configure color mode behavior through props inherited from `ThemeProviderProps`:

```tsx
import { NimbusProvider } from '@commercetools/nimbus';

export default function App() {
  return (
    <NimbusProvider
      defaultTheme="light"
      enableSystem={false}
      disableTransitionOnChange={false}
    >
      <YourApp />
    </NimbusProvider>
  );
}
```

**Common color mode props:**
- `defaultTheme`: `"light" | "dark" | "system"` - Initial theme (default: `"light"`)
- `enableSystem`: `boolean` - Respect system color preference (default: `false`)
- `disableTransitionOnChange`: `boolean` - Disable CSS transitions when changing themes (default: `false`)
- `storageKey`: `string` - LocalStorage key for persisting theme preference (default: `"theme"`)

To toggle color mode in your application, use the `useColorMode` hook from Chakra UI:

```tsx
import { useColorMode } from '@chakra-ui/react';

function ThemeToggle() {
  const { colorMode, toggleColorMode } = useColorMode();

  return (
    <Button onClick={toggleColorMode}>
      Switch to {colorMode === 'light' ? 'dark' : 'light'} mode
    </Button>
  );
}
```

## Framework integration

NimbusProvider's `router` prop enables client-side navigation for all Nimbus components with `href` props (Link, Button with href, Menu items, etc.). Configure it to match your routing framework.

### React Router (v6)

```tsx
// app/providers.tsx
import { NimbusProvider } from '@commercetools/nimbus';
import { useNavigate, useHref } from 'react-router-dom';

export function Providers({ children }: { children: React.ReactNode }) {
  const navigate = useNavigate();

  return (
    <NimbusProvider
      router={{
        navigate,
        useHref // Optional: for href transformation
      }}
    >
      {children}
    </NimbusProvider>
  );
}

// main.tsx
import { BrowserRouter } from 'react-router-dom';
import { Providers } from './providers';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <BrowserRouter>
    <Providers>
      <App />
    </Providers>
  </BrowserRouter>
);
```

**Important:** NimbusProvider must be a child of `BrowserRouter` to access React Router's hooks.

### Next.js App Router

```tsx
// app/providers.tsx
'use client';

import { NimbusProvider } from '@commercetools/nimbus';
import { useRouter } from 'next/navigation';

export function Providers({
  children,
  locale
}: {
  children: React.ReactNode;
  locale?: string;
}) {
  const router = useRouter();

  return (
    <NimbusProvider
      locale={locale}
      router={{
        navigate: router.push
      }}
    >
      {children}
    </NimbusProvider>
  );
}

// app/layout.tsx
import { Providers } from './providers';

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <Providers>
          {children}
        </Providers>
      </body>
    </html>
  );
}
```

**Note:** The `'use client'` directive is required because `useRouter` is a client-side hook.

### Next.js with internationalization

```tsx
// app/[locale]/providers.tsx
'use client';

import { NimbusProvider } from '@commercetools/nimbus';
import { useRouter } from 'next/navigation';

export function Providers({
  children,
  locale
}: {
  children: React.ReactNode;
  locale: string;
}) {
  const router = useRouter();

  return (
    <NimbusProvider
      locale={locale}
      router={{
        navigate: router.push
      }}
    >
      {children}
    </NimbusProvider>
  );
}

// app/[locale]/layout.tsx
import { Providers } from './providers';

export default function LocaleLayout({
  children,
  params
}: {
  children: React.ReactNode;
  params: { locale: string };
}) {
  return (
    <html lang={params.locale}>
      <body>
        <Providers locale={params.locale}>
          {children}
        </Providers>
      </body>
    </html>
  );
}
```

### Next.js with base path

If your Next.js app uses a base path, transform hrefs using the `useHref` option:

```tsx
'use client';

import { NimbusProvider } from '@commercetools/nimbus';
import { useRouter } from 'next/navigation';

export function Providers({ children }: { children: React.ReactNode }) {
  const router = useRouter();
  const basePath = process.env.NEXT_PUBLIC_BASE_PATH || '';

  const useHref = (href: string) => `${basePath}${href}`;

  return (
    <NimbusProvider
      router={{
        navigate: router.push,
        useHref
      }}
    >
      {children}
    </NimbusProvider>
  );
}
```

### Next.js Pages Router

```tsx
// pages/_app.tsx
import type { AppProps } from 'next/app';
import { NimbusProvider } from '@commercetools/nimbus';
import { useRouter } from 'next/router';

export default function App({ Component, pageProps }: AppProps) {
  const router = useRouter();

  return (
    <NimbusProvider
      locale={router.locale}
      router={{
        navigate: (href) => router.push(href)
      }}
    >
      <Component {...pageProps} />
    </NimbusProvider>
  );
}
```

### Remix

```tsx
// app/root.tsx
import { NimbusProvider } from '@commercetools/nimbus';
import { useNavigate } from '@remix-run/react';

export default function App() {
  const navigate = useNavigate();

  return (
    <html>
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <NimbusProvider router={{ navigate }}>
          <Outlet />
        </NimbusProvider>
        <Scripts />
      </body>
    </html>
  );
}
```

## Advanced configuration

### Dynamic locale switching

Allow users to change the application language at runtime by managing locale state:

```tsx
'use client';

import { useState } from 'react';
import { NimbusProvider, useLocale } from '@commercetools/nimbus';
import { useRouter } from 'next/navigation';

export function Providers({
  children,
  initialLocale = 'en'
}: {
  children: React.ReactNode;
  initialLocale?: string;
}) {
  const [locale, setLocale] = useState(initialLocale);
  const router = useRouter();

  return (
    <NimbusProvider
      locale={locale}
      router={{ navigate: router.push }}
    >
      <LocaleSwitcher setLocale={setLocale} />
      {children}
    </NimbusProvider>
  );
}

function LocaleSwitcher({
  setLocale
}: {
  setLocale: (locale: string) => void;
}) {
  // Read current locale from React Aria context
  const { locale } = useLocale();

  return (
    <Select.Root value={locale} onValueChange={setLocale}>
      <Select.Trigger>{locale}</Select.Trigger>
      <Select.Content>
        <Select.Item value="en">English</Select.Item>
        <Select.Item value="de-DE">Deutsch</Select.Item>
        <Select.Item value="fr-FR">Français</Select.Item>
      </Select.Content>
    </Select.Root>
  );
}
```

**Note:** For deeply nested components, you can use React Context to avoid prop drilling, but for most cases, passing `setLocale` as a prop is sufficient.

### TypeScript: Router options type augmentation

If you need type-safe router options (like React Router's `NavigateOptions` or Next.js router options), use TypeScript module augmentation:

```tsx
// types/nimbus.d.ts
import type { NavigateOptions } from 'react-router-dom';

declare module '@commercetools/nimbus' {
  interface NimbusRouterOptionsBase {
    routerOptions?: NavigateOptions;
  }
}

// Now the router config is fully typed
import { NimbusProvider } from '@commercetools/nimbus';
import { useNavigate } from 'react-router-dom';

function Providers({ children }) {
  const navigate = useNavigate();

  const typedNavigate = (href: string, options?: NavigateOptions) => {
    navigate(href, options);
  };

  return (
    <NimbusProvider router={{ navigate: typedNavigate }}>
      {children}
    </NimbusProvider>
  );
}
```

**For Next.js App Router:**

```tsx
// types/nimbus.d.ts
import type { AppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime';

declare module '@commercetools/nimbus' {
  interface NimbusRouterOptionsBase {
    routerOptions?: Parameters<AppRouterInstance['push']>[1];
  }
}
```

### Server-side rendering considerations

**Hydration warnings:**
If you see hydration mismatches related to color mode or locale, ensure the server and client render the same initial state:

```tsx
// Next.js App Router
import { cookies } from 'next/headers';

export default function RootLayout({ children }) {
  const cookieStore = cookies();
  const theme = cookieStore.get('theme')?.value || 'light';

  return (
    <html className={theme}>
      <body>
        <Providers defaultTheme={theme}>
          {children}
        </Providers>
      </body>
    </html>
  );
}
```

**Script for SSR color mode:**
To prevent flash of incorrect theme, add a blocking script in your HTML head:

```tsx
// app/layout.tsx
export default function RootLayout({ children }) {
  return (
    <html suppressHydrationWarning>
      <head>
        <script
          dangerouslySetInnerHTML={{
            __html: `
              try {
                const theme = localStorage.getItem('theme') || 'light';
                document.documentElement.classList.add(theme);
              } catch (e) {}
            `,
          }}
        />
      </head>
      <body>
        <NimbusProvider enableSystem={false}>
          {children}
        </NimbusProvider>
      </body>
    </html>
  );
}
```

### Accessing provider context

Components can access the router context provided by NimbusProvider through React Aria's `RouterProvider`:

```tsx
import { useRouter } from 'react-aria';

function CustomLink({ href, children }) {
  const router = useRouter();

  const handleClick = () => {
    if (router) {
      router.navigate(href);
    } else {
      window.location.href = href;
    }
  };

  return (
    <button onClick={handleClick}>
      {children}
    </button>
  );
}
```

**Note:** Most Nimbus components handle routing automatically. You typically don't need to access router context directly.

## Migration guides

### Merchant Center integration

> [!WARNING]
> **Action Required for Merchant Center Applications**
>
> If you're using Nimbus within Merchant Center or any application where app-kit/ui-kit already loads the Inter font, you **must** add `loadFonts={false}` to prevent duplicate font loading and performance regressions.

**Before (causes duplicate font loading):**
```tsx
<NimbusProvider locale={locale} router={router}>
  <App />
</NimbusProvider>
```

**After (prevents duplicates):**
```tsx
<NimbusProvider locale={locale} router={router} loadFonts={false}>
  <App />
</NimbusProvider>
```

**Impact of not updating:**
- Duplicate network requests for Inter font files (performance regression)
- Increased page load time due to redundant font downloads
- Potential FOUT (Flash of Unstyled Text) issues
- Unnecessary bandwidth consumption for users

**How to verify fonts are loaded:**

Open your browser's DevTools and check the Network tab:
1. Filter by "fonts" or search for "googleapis"
2. If you see Inter font requests from Google Fonts, fonts are being loaded
3. If `loadFonts={false}` is set, no Google Fonts requests should appear
4. Check the Elements tab → `<head>` for `<link rel="stylesheet" data-nimbus-fonts>` - this link should not exist when disabled

**Testing:**

After adding `loadFonts={false}`:
1. Verify no duplicate font network requests in DevTools
2. Run visual regression tests to ensure fonts still render correctly
3. Confirm Inter font is visible in the computed styles (DevTools → Elements → Computed)

### Upgrading from previous Nimbus versions

If you're upgrading from a version before font loading was added:

**No action required for most applications:**
- Fonts will automatically load with default behavior
- Existing applications will work without changes

**Action required for Merchant Center:**
- Add `loadFonts={false}` to prevent duplicate font loading
- See "Merchant Center integration" above for details

**If you experience issues:**
- Font flash (FOUT): This is expected with Google Fonts; minimize by preloading
- Multiple font loads: Check for multiple NimbusProvider instances or conflicting font loaders
- See "Troubleshooting" section below for common issues

## Troubleshooting

### Fonts not loading

**Issue:** Text renders in system fonts instead of Inter.

**Solution:**
1. Verify `loadFonts` is not explicitly set to `false`
2. Check browser DevTools Network tab for Google Fonts requests
3. Look for `<link data-nimbus-fonts>` in document head
4. Verify Google Fonts is not blocked by ad blockers or CSP policies
5. Check that the fallback font stack includes Inter:
   ```css
   font-family: Inter, -apple-system, BlinkMacSystemFont, sans-serif;
   ```

### Duplicate font loading

**Issue:** Multiple font requests or warnings about duplicate stylesheet links.

**Solution:**
1. Check for multiple NimbusProvider instances on the same page
2. If using Merchant Center/app-kit, set `loadFonts={false}` on all providers
3. Verify no manual `<link>` tags for Google Fonts in your HTML
4. Check that only one version of Nimbus is installed (`npm ls @commercetools/nimbus`)

**Note:** Built-in deduplication prevents duplicate injection from multiple providers, but manual font loading elsewhere needs to be managed.

### Font flash (FOUT)

**Issue:** Brief flash of system font before Inter loads.

**Explanation:** This is expected behavior with web fonts. The `display=swap` strategy shows text immediately with fallback fonts, then swaps to Inter when loaded.

**Mitigation strategies:**
1. Accept FOUT as expected behavior (preferred - better UX than invisible text)
2. Preload fonts in document head (reduces flash duration):
   ```html
   <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" as="style">
   ```
3. Use a font loading library to add custom loading states
4. Self-host fonts for faster loading (requires disabling Google Fonts)

### Missing provider error

**Error:** `Cannot read properties of undefined (reading 'theme')` or similar context errors.

**Solution:** Ensure NimbusProvider wraps your entire application, including the component tree where Nimbus components are used.

```tsx
// ❌ Wrong: Provider missing
function App() {
  return <Button>Click me</Button>; // Error!
}

// ✅ Correct: Provider wraps app
function App() {
  return (
    <NimbusProvider>
      <Button>Click me</Button>
    </NimbusProvider>
  );
}
```

### Router navigation not working

**Issue:** Links use full page reload instead of client-side navigation.

**Solution:** Verify that:
1. The `router` prop is correctly configured
2. The router framework's context is available (e.g., inside `BrowserRouter` for React Router)
3. The navigate function is not undefined

```tsx
// Debug: Check if router is available
function DebugRouter() {
  const router = useRouter(); // from react-aria
  console.log('Router available:', !!router);
  return null;
}
```

### Locale not applying

**Issue:** Nimbus components still show English text despite setting locale.

**Solution:**
1. Verify the locale is supported by Nimbus i18n: `en`, `de`, `es`, `fr-FR`, or `pt-BR`
2. Note that the `useLocalizedStringFormatter` hook automatically normalizes locale codes (e.g., `"en-US"` → `"en"`, `"de-DE"` → `"de"`)
3. Check that compiled message dictionaries are included in your build
4. React Aria components (DatePicker, NumberInput) support any BCP47 locale, but Nimbus component translations (buttons, labels) only support the locales listed above

```tsx
// Debug: Check current locale from React Aria context
import { useLocale } from 'react-aria-components';

function DebugLocale() {
  const { locale } = useLocale();
  console.log('Current locale:', locale);
  return null;
}
```

### Hydration mismatch with color mode

**Issue:** Console warning about hydration mismatch or flash of wrong theme.

**Solution:** Use `suppressHydrationWarning` on the `<html>` tag and ensure server renders with the same theme:

```tsx
<html suppressHydrationWarning>
  <body>
    <NimbusProvider defaultTheme={serverTheme}>
      {children}
    </NimbusProvider>
  </body>
</html>
```

### TypeScript errors with router config

**Issue:** Type errors when passing router options.

**Solution:** Use module augmentation to extend the router options type (see "TypeScript: Router options type augmentation" above).

## Component requirements

### Placement

NimbusProvider **must** be placed at or near the root of your application component tree. It should wrap all components that use Nimbus.

**Correct placement hierarchy:**
```html
<html>
  <body>
    <NimbusProvider>          ← Provider at root
      <YourApp>               ← Your app components
        <Button />            ← Nimbus components work
      </YourApp>
    </NimbusProvider>
  </body>
</html>
```

**For framework-specific routing:**
```
<BrowserRouter>               ← React Router context
  <NimbusProvider router={{}} ← Provider inside router
    <YourApp />
  </NimbusProvider>
</BrowserRouter>
```

### Nesting providers

NimbusProvider **can** be nested, but it's rarely necessary. For most applications, a single provider at the root is sufficient.

**What works with nesting:**
- ✅ **Locale** - Inner provider's locale overrides outer provider (uses React Context)
- ✅ **Router** - Inner provider's router overrides outer provider (uses React Context)
- ❌ **Color mode** - Cannot be scoped to nested providers (uses global state via next-themes)

```tsx
// Nesting works for locale and router contexts
<NimbusProvider locale="en" router={outerRouter}>
  <Page1 /> {/* Uses English locale and outerRouter */}

  <NimbusProvider locale="de-DE" router={innerRouter}>
    <Page2 /> {/* Uses German locale and innerRouter */}
  </NimbusProvider>

  <Page3 /> {/* Back to English locale and outerRouter */}
</NimbusProvider>

// ✅ Recommended: Single provider at root
<NimbusProvider locale={currentLocale} router={router}>
  <Page1 />
  <Page2 />
  <Page3 />
</NimbusProvider>
```

**Note:** Color mode cannot be scoped because `next-themes` operates globally on the document element. Nested providers will change the global theme, not create a scoped theme for their subtree.

#### Locale-only changes with NimbusI18nProvider

For cases where you only need to change the locale (without affecting router or theme), use `NimbusI18nProvider` directly. This is more lightweight than nesting a full `NimbusProvider`:

```tsx
import { NimbusProvider, NimbusI18nProvider } from '@commercetools/nimbus';

export default function App() {
  return (
    <NimbusProvider locale="en">
      <MainContent /> {/* Uses English locale */}

      <NimbusI18nProvider locale="de">
        <GermanSection /> {/* Uses German locale */}
      </NimbusI18nProvider>

      <NimbusI18nProvider locale="es">
        <SpanishSection /> {/* Uses Spanish locale */}
      </NimbusI18nProvider>

      <MoreContent /> {/* Back to English locale */}
    </NimbusProvider>
  );
}
```

**When to use which:**
- Use **nested `NimbusProvider`** when you need to change locale AND router configuration
- Use **`NimbusI18nProvider`** when you only need to change locale (more efficient)

## Accessibility

NimbusProvider itself has no accessibility requirements as it's a pure context provider with no visual rendering. However, it enables accessibility features across Nimbus components:

- **Internationalization**: Provides locale context for date/time formatting and translated messages
- **Router integration**: Enables proper link semantics and navigation announcements
- **Theme context**: Ensures consistent color contrast and visual theming

## Testing your application

When writing tests for components that use Nimbus, wrap them with NimbusProvider in your test utilities:

### Test utilities setup

Create a custom render function that includes NimbusProvider:

```tsx
// test-utils.tsx
import { render, RenderOptions } from '@testing-library/react';
import { NimbusProvider } from '@commercetools/nimbus';

interface CustomRenderOptions extends RenderOptions {
  locale?: string;
  router?: {
    navigate?: jest.Mock;
    useHref?: (href: string) => string;
  };
}

export function renderWithProvider(
  ui: React.ReactElement,
  options?: CustomRenderOptions
) {
  const { locale = 'en', router, ...renderOptions } = options || {};

  return render(
    <NimbusProvider locale={locale} router={router}>
      {ui}
    </NimbusProvider>,
    renderOptions
  );
}

// Re-export everything from @testing-library/react
export * from '@testing-library/react';
```

### Testing with router mocks

```tsx
// MyComponent.test.tsx
import { renderWithProvider, screen } from './test-utils';
import { MyComponent } from './MyComponent';

describe('MyComponent', () => {
  it('navigates when link is clicked', async () => {
    const mockNavigate = jest.fn();

    renderWithProvider(
      <MyComponent />,
      {
        router: { navigate: mockNavigate }
      }
    );

    const link = screen.getByRole('link', { name: 'Go to page' });
    await userEvent.click(link);

    expect(mockNavigate).toHaveBeenCalledWith('/page');
  });
});
```

### Testing with different locales

```tsx
// LocalizedComponent.test.tsx
import { renderWithProvider, screen } from './test-utils';
import { DatePicker } from '@commercetools/nimbus';

describe('LocalizedComponent', () => {
  it('displays dates in German format', () => {
    renderWithProvider(
      <DatePicker value={new Date('2024-03-15')} />,
      { locale: 'de-DE' }
    );

    // Verify German date format
    expect(screen.getByText(/15\.03\.2024/)).toBeInTheDocument();
  });

  it('displays dates in English format', () => {
    renderWithProvider(
      <DatePicker value={new Date('2024-03-15')} />,
      { locale: 'en-US' }
    );

    // Verify English date format
    expect(screen.getByText(/03\/15\/2024/)).toBeInTheDocument();
  });
});
```

### Vitest setup

If using Vitest, add NimbusProvider to your test setup file:

```tsx
// vitest.setup.ts
import { afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import '@testing-library/jest-dom/vitest';

// Cleanup after each test
afterEach(() => {
  cleanup();
});

// Optional: Set default test environment variables
process.env.NODE_ENV = 'test';
```

## API reference

<PropsTable id="NimbusProvider" />

## Resources

- [Storybook](https://nimbus-storybook.vercel.app/?path=/docs/components-nimbusprovider--docs)
- [next-themes Documentation](https://github.com/pacocoursey/next-themes)
- [React Aria RouterProvider](https://react-spectrum.adobe.com/react-aria/routing.html)
- [React Aria I18nProvider](https://react-spectrum.adobe.com/react-aria/I18nProvider.html)
