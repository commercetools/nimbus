---
id: NimbusProvider
title: NimbusProvider
description: provides an environment for the rest of the components to work in
lifecycleState: Beta
order: 999
menu:
  - Components
  - Utilities
  - NimbusProvider
tags:
  - system
  - required
  - setup

---

# NimbusProvider

The `NimbusProvider` component provides the foundational context for all Nimbus components, including theming, internationalization, and optional client-side routing configuration.

## Basic usage

Without configuration, the `NimbusProvider` will provide the default theme and color mode (light)
and infer the locale from the browser.

```tsx
import { NimbusProvider } from "@commercetools/nimbus";

function App() {
  return (
    <NimbusProvider>
      <YourApp />
    </NimbusProvider>
  );
}
```

## Set up translation messages

To enable translations for Nimbus components, you need to load and provide translation messages to the `NimbusProvider`. This is a **one-time setup at your application's root level**. Once configured, all Nimbus components throughout your application will automatically use the correct translations. Nimbus provides utilities to load these messages from the `@commercetools/nimbus-i18n` package.

You can specify a [BCP47 language tag](https://en.wikipedia.org/wiki/IETF_language_tag) (e.g., `"en-US"`, `"de-DE"`, `"fr-FR"`) via the `locale` prop. If no locale is provided, it defaults to the user's browser locale.

### Using the useNimbusMessages hook (Recommended)

The easiest way to load translation messages is using the `useNimbusMessages` hook:

```tsx
import { NimbusProvider, useNimbusMessages } from "@commercetools/nimbus";

function App() {
  const locale = navigator.language || "en";
  const { messages, isLoading } = useNimbusMessages(locale);

  if (isLoading) {
    return <div>Loading translations...</div>;
  }

  return (
    <NimbusProvider locale={locale} messages={messages}>
      <YourApp />
    </NimbusProvider>
  );
}
```

### Using getMessagesForLocale directly

For more control, you can use `getMessagesForLocale` directly:

```tsx
import { useEffect, useState } from "react";
import { NimbusProvider, getMessagesForLocale, type IntlMessages } from "@commercetools/nimbus";

function App() {
  const locale = navigator.language || "en";
  const [messages, setMessages] = useState<IntlMessages>({});

  useEffect(() => {
    getMessagesForLocale(locale).then(setMessages);
  }, [locale]);

  return (
    <NimbusProvider locale={locale} messages={messages}>
      <YourApp />
    </NimbusProvider>
  );
}
```

### Supported locales

The following locales are supported:
- `en` (English) - default fallback
- `de` (German)
- `es` (Spanish)
- `fr-FR` (French)
- `pt-BR` (Portuguese - Brazil)

Region-specific codes (e.g., `en-US`, `de-DE`) are automatically normalized to their base locale. If a locale is not supported, it falls back to English.

> [!NOTE]\
> Without providing `messages`, Nimbus components will still work but may show `MISSING_TRANSLATION` errors in the console for components that require translations.

### Using components with translations

Once you've provided `messages` to `NimbusProvider` at your app's root level, all Nimbus components throughout your entire application will automatically use the correct translations based on the `locale` prop. **No additional configuration is needed for individual components**s.

```tsx
import { Alert } from "@commercetools/nimbus";

function MyComponent() {
  return (
    <Alert.Root colorPalette="info" variant="outline">
      <Alert.Title>Success!</Alert.Title>
      <Alert.Description>
        Your changes have been saved successfully.
      </Alert.Description>
      <Alert.DismissButton />
      {/* The dismiss button automatically uses the correct translation */}
    </Alert.Root>
  );
}
```

The `Alert.DismissButton` will automatically display the translated text (e.g., "Dismiss" in English, "Schlie√üen" in German) based on the locale you set in `NimbusProvider`. This same pattern applies to all Nimbus components that use translations.

## Set up router

The `NimbusProvider` can be configured with client-side routing to enable seamless navigation for all Nimbus components that support links (like `Link`, `Button` with href, etc.).

### React router

```tsx
import { useNavigate, useHref } from 'react-router-dom';
import { NimbusProvider } from "@commercetools/nimbus";

function App() {
  const navigate = useNavigate();

  return (
    <NimbusProvider 
      router={{ 
        navigate,
        useHref 
      }}
    >
      <YourApp />
    </NimbusProvider>
  );
}
```

### Next.js app router

```tsx
'use client';
import { useRouter } from 'next/navigation';
import { NimbusProvider } from "@commercetools/nimbus";

function ClientProviders({ children }) {
  const router = useRouter();

  return (
    <NimbusProvider 
      router={{ 
        navigate: router.push 
      }}
    >
      {children}
    </NimbusProvider>
  );
}
```

### Next.js with base path

```tsx
'use client';
import { useRouter } from 'next/navigation';
import { NimbusProvider } from "@commercetools/nimbus";

function ClientProviders({ children }) {
  const router = useRouter();
  const useHref = (href: string) => process.env.BASE_PATH + href;

  return (
    <NimbusProvider 
      router={{ 
        navigate: router.push,
        useHref 
      }}
    >
      {children}
    </NimbusProvider>
  );
}
```

## Props

<PropsTable id="NimbusProvider" />
