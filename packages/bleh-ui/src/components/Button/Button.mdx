---
id: Forms-Button
title: Button
description: Display a Button.
menu: ["Components", "Inputs", "Button"]
order: 999
tags:
  - document
---

# Button

Displays a Button.

> [!NOTE]  
> The `<Button/>` component uses the native [HTML button element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button) as native DOM element.
>
> You can freely use native button attributes and customize its styling with the props below.

## Basic Usage

No props are required to use the Button component. If unconfigured it will pick up defaults
for `variant`, `size`, and `colorPalette`. Defaults can be set in the `recipe`-file.

```jsx-live
const App = () => <Button>I am a Button</Button>
```

## Features

### Accessibility

To abstract away the differences between mouse, touch and keyboard interactions, the Button component
supports `onPress*` props. The misc `onPress*` props (`onPress`, `onPressStart`, `onPressEnd`, etc.) provide a more seamless and inclusive user experience
across different devices and input methods:

```jsx-live
const App = () => <Button aria-label="ne need to click this" onPress={()=>alert()} onPressEnd={()=>{}}>I am still a button</Button>
```

### Change the underlying DOM-element

The Button component uses the native [HTML button element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button)
by default, but supports rendering as a different tag to the dom. Use the `asChild` and the tag you want to render as only child.

```jsx-live
const App = () => (
  <Button asChild>
    <a href="http://www.commercetools.com" target="_blank">I am a button in disguise</a>
  </Button>
)
```

### Data-Attributes

The Button component supports forwarding arbitrary `data-*` attributes. This can be useful for tracking tools.

```jsx-live
const App = () => <Button data-foo="bar">I can have data-attributes</Button>
```

## Customizing the look

### Sizes

Buttons come in different sizes, sizing a button is done by setting the `size` prop. Setting the size
has no effect on the variant or color of the Button.

```jsx-live
const App = () => {

  const sizes = ['2xs', 'xs', 'sm', 'md', 'lg', 'xl', '2xl'].reverse();

  return (
    <Stack direction="horizontal" alignItems="center">
      {sizes.map(size => (
        <Button key={size} size={size}>'{size}' Button</Button>
      ))}
    </Stack>
  )
}
```

### Variants

Look how the buttons change their appearance but not their size. It is important
that the variant has no effect on the size. Only then it can be guaranteed that
buttons with different variants can be used and displayed next to each other.

```jsx-live
const App = () => {

  const variants = ['solid', 'subtle', 'outline', 'ghost', 'plain']

  return (
    <Stack direction="horizontal">
      {variants.map(variant => (
        <Button key={variant} variant={variant}>'{variant}' Button</Button>
      ))}
    </Stack>
  )
}
```

### Colors

Since the different `variants` operate purely on contrast level differences (think: dark & light elements),
the `colorPalette` prop can be used to colorize the Button.

```jsx-live
const App = () => {
  const variants = ["solid", "subtle", "outline", "ghost", "link", "plain"];
  const colors = ["neutral", "primary", "info", "success", "danger", "error"];

  return (
    <Stack>
      {colors.map((color) => (
        <Stack key={color} direction="horizontal">
          {variants.map((variant) => (
            <Button colorPalette={color} key={variant} variant={variant}>
              '{variant}' Button
            </Button>
          ))}
        </Stack>
      ))}
    </Stack>
  );
};
```

## Responsive widths

The [`width` style-prop](/style-props/sizing#width) can be used to set the width of the `Button`.
In combination with a `Stack` you could display the `Button`s side-by-side or on top of each other
depending on the available screen-estate.

```jsx-live
const App = () => {
  return (
    <Stack direction={{
      base: "column",
      md: "row"
    }}>
      <Button width={{
        base: 'full',
        md: '1/2'
      }} colorPalette="success" variant="solid">
        <Icons.Check /> Yes
      </Button>
      <Button width={{
        base: 'full',
        md: '1/2'
      }} colorPalette="error" variant="solid">
        <Icons.X /> No
      </Button>
    </Stack>
  );
};
```

## Icons

Right now icons can be just dropped into the button, they are sized like regular text and thus
adjust their own-size according to the `size` prop.

```jsx-live
const App = () => {
  const sizes = ["2xs", "xs", "sm", "md", "lg", "xl", "2xl"].reverse();

  return (
    <Stack>
      {sizes.map((size) => (
        <Stack key={size} direction="horizontal">
          <Button size={size} colorPalette="success" variant="solid">
            <Icons.Check /> Yes
          </Button>
          <Button size={size} colorPalette="error" variant="solid">
            <Icons.X /> No
          </Button>
          <Button size={size} colorPalette="neutral" variant="ghost">
            <Box animation="spin" asChild><Icons.Loader/></Box> Maybe
          </Button>
        </Stack>
      ))}
    </Stack>
  );
};
```

## Props

Here is still chaos. I am not sure if parsing the types is the right way to do it. This is already a filtered selection, but there is still a lot
of "bycatch" (native HTML element props, style-props, chakra-specifics ...) in the types that is not needed.
Maybe cherry-picking the props to display is the way to go.

<PropTable id="Button" />
