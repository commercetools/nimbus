# Component Rendering Service Implementation

## Executive Summary

The **Component Rendering Service** is a backend API service that provides authenticated access to server-side rendering (SSR) of high-complexity, interactive Nimbus components. Specifically designed for **LLM response UIs** where chat interfaces need to display rich, interactive components (forms, tables, dashboards) in iframes with mandatory client-side hydration.

**Critical Integration**: The service integrates with **commercetools-identity** for authentication and the **Theme Service API** to dynamically apply project/organization-specific themes during SSR, ensuring brand consistency across all rendered components.

**Architecture**:
- **Phase 1**: Production-ready Node.js service
  - commercetools-identity OAuth2 authentication
  - Theme Service integration (dynamic per-project/org themes)
  - Server-Side Rendering (SSR) to HTML strings + CSS
  - Observability (Falcon LogScale/Humio + Prometheus)
  - Extensible middleware (rate limiting ready)

- **Phase 2**: Kubernetes deployment
  - Horizontal scaling
  - Optional rate limiting
  - Enhanced monitoring

**Key Capabilities**:
- ğŸ” JWT/OAuth2 authentication with scope-based authorization
- ğŸ¨ Server-Side Rendering (React SSR to HTML/CSS)
- ğŸ­ **Theme Service Integration** - Dynamic theme application per project/organization
- âš¡ Mandatory client-side hydration for full interactivity
- ğŸ“Š Production observability (logs, metrics, alerts)
- ğŸš€ Kubernetes-ready architecture
- ğŸ–¼ï¸ Instant visual display (SSR) + interactive after hydration

**Target Use Cases** (LLM Response UIs):
- MCP servers rendering interactive forms in chat responses
- Complex data tables in AI agent responses
- Multi-step wizards generated by LLMs
- Dashboard components in conversational interfaces
- Real-time data visualizations in assistant responses

**Component Complexity Examples**:
- Interactive forms with validation and submission
- Sortable/filterable data tables with pagination
- Multi-step wizards with state persistence
- Modal dialogs with complex workflows
- Drag-and-drop interfaces

---

## Architecture Overview

### Service Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Client/MCP      â”‚
â”‚  Server          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ HTTP POST /render
         â”‚ Authorization: Bearer <api-key>
         â”‚ { type: "button", props: {...}, themeId: "project-123" }
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Component Rendering Service        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  1. Authentication Middleware â”‚  â”‚
â”‚  â”‚     - Validate API key        â”‚  â”‚
â”‚  â”‚     - Load client config      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  2. Rate Limiting (Optional)  â”‚  â”‚
â”‚  â”‚     - Placeholder for future  â”‚  â”‚
â”‚  â”‚     - Easy to activate later  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  3. Validation                â”‚  â”‚
â”‚  â”‚     - Validate request schema â”‚  â”‚
â”‚  â”‚     - Check element type      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  4. Theme Resolution          â”‚  â”‚
â”‚  â”‚     - Call Theme Service API  â”‚  â”‚
â”‚  â”‚     - Get project/org theme   â”‚  â”‚
â”‚  â”‚     - Apply brand colors      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚           â”‚                          â”‚
â”‚           â–¼                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚  Theme Service     â”‚              â”‚
â”‚  â”‚  (External API)    â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚           â”‚                          â”‚
â”‚           â”‚ { colors, tokens, ... }  â”‚
â”‚           â–¼                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  5. SSR Engine                â”‚  â”‚
â”‚  â”‚     - Create React Element    â”‚  â”‚
â”‚  â”‚     - Apply theme to provider â”‚  â”‚
â”‚  â”‚     - renderToString()        â”‚  â”‚
â”‚  â”‚     - Extract CSS             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ 200 OK
         â”‚ { html: "<button class='...'>Click me</button>",
         â”‚   css: ".nimbus-button { ... }" }
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Client/MCP      â”‚
â”‚  Receives HTML   â”‚
â”‚  + CSS           â”‚
â”‚  (iframe ready)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Technology Stack

**Core**:
- Node.js 20+ / Express.js / TypeScript

**Authentication**:
- commercetools-identity (OAuth2 provider)
- JWT token validation
- API keys (optional fallback)

**Rendering** (Server-Side):
- React 18+ (renderToString)
- @commercetools/nimbus (component library)
- @chakra-ui/react (styling system)
- Emotion/CSS extraction
- Zod validation

**Theme Integration** (CRITICAL):
- Theme Service API client
- Theme resolution per project/organization
- Dynamic token/color application
- Theme caching layer

**Observability**:
- Winston â†’ Falcon LogScale/Humio
- Prometheus metrics
- Health/readiness probes

**Future** (Phase 2):
- Redis (rate limiting, HTML caching, theme caching)
- Kubernetes manifests

## High-Level Architecture

```
src/
â”œâ”€â”€ middleware/        # Auth, validation, logging, (rate limiting placeholder)
â”œâ”€â”€ services/          # Rendering, auth, theme resolution, (rate limiter)
â”‚   â”œâ”€â”€ rendering/     # SSR engine, hydration metadata
â”‚   â”œâ”€â”€ theme/         # Theme Service API client, cache
â”‚   â””â”€â”€ auth/          # JWT/OAuth2 validation
â”œâ”€â”€ routes/            # /render, /health, /metrics
â””â”€â”€ utils/             # Logger, errors, validation
```

---

## Key Implementation Patterns

### Authentication Middleware

**Pattern**: commercetools-identity OAuth2 validation

```typescript
export async function authenticate(req, res, next) {
  const token = req.headers.authorization?.replace('Bearer ', '');

  // Validate JWT with commercetools-identity
  const client = await verifyCommercetoolsIdentityToken(token);

  if (!client || !client.isActive) {
    throw new UnauthorizedError('Invalid token');
  }

  // Attach client context (includes projectId, orgId for theme resolution)
  req.client = client;
  next();
}
```

**Client context includes**:
- User/service ID
- Scopes for authorization
- `projectId` and `orgId` for theme resolution

### Rate Limiting (Future)

**Pattern**: Placeholder middleware for easy activation

```typescript
// Currently pass-through, ready for implementation
export async function rateLimit(req, res, next) {
  // TODO: Add rate limiting when needed
  // Options: in-memory, Redis, token bucket
  next();
}
```

### Theme Service Integration

**Pattern**: Resolve and apply themes before rendering

```typescript
export class ThemeService {
  async resolveTheme(themeId: string, projectId?: string, orgId?: string): Promise<Theme> {
    // 1. Check cache first
    const cached = this.cache.get(themeId);
    if (cached) return cached;

    // 2. Call Theme Service API
    const theme = await this.themeServiceClient.getTheme({
      themeId,
      projectId,
      orgId
    });

    // 3. Cache for subsequent requests
    this.cache.set(themeId, theme, { ttl: 300 }); // 5 min cache

    return theme;
  }
}
```

**Theme Service API Response**:
```typescript
{
  themeId: "project-123",
  colors: {
    primary: { 1: "#...", 2: "#...", /* ... */ 12: "#..." },
    neutral: { /* ... */ }
  },
  tokens: {
    fontFamily: "Inter, sans-serif",
    borderRadius: { /* ... */ }
  },
  metadata: { projectId: "123", orgId: "456" }
}
```

### Rendering Service

**Pattern**: Server-Side Rendering with Theme Application

```typescript
export class RenderingService {
  constructor(private themeService: ThemeService) {}

  async render(request: RenderRequest): Promise<RenderResponse> {
    // 1. Validate component type
    validateComponent(request.type);

    // 2. CRITICAL: Resolve theme BEFORE rendering
    const theme = await this.themeService.resolveTheme(
      request.themeId,
      request.projectId,
      request.orgId
    );

    // 3. Get component from registry
    const Component = getComponent(request.type);

    // 4. Wrap in providers with theme applied
    const element = wrapWithProviders(Component, request.props, theme);

    // 5. Render to HTML string (React SSR)
    const html = renderToString(element);

    // 6. Extract critical CSS (Emotion)
    const css = extractCriticalCSS(html);

    return { html, css, metadata: { theme: theme.themeId } };
  }
}
```

**Key dependencies**:
- `react-dom/server` - SSR rendering
- `@emotion/server` - CSS extraction
- `@commercetools/nimbus` - Component library
- `@chakra-ui/react` - Theming/providers
- Theme Service API client - Theme resolution


---

## API Endpoints

### POST /render
Server-side render a Nimbus component to HTML + CSS with theme applied

**Auth**: Required (JWT/API key)

**Request**:
```json
{
  "type": "button",
  "props": { "variant": "solid" },
  "children": "Click me",
  "themeId": "project-123",
  "projectId": "123",
  "orgId": "456"
}
```

**Request Parameters**:
- `type` (required): Component type to render
- `props` (optional): Component props
- `children` (optional): Component children
- `themeId` (required): Theme identifier for Theme Service lookup
- `projectId` (optional): Project identifier for theme context
- `orgId` (optional): Organization identifier for theme context

**Response (200)**:
```json
{
  "html": "<button class='nimbus-button'>Click me</button>",
  "css": ".nimbus-button { /* styles with theme colors */ }",
  "metadata": {
    "renderedAt": "...",
    "version": "1.0.0",
    "theme": "project-123"
  }
}
```

**Client usage**:
```javascript
// Fetch rendered component with theme
const { html, css } = await fetch('/render', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer <token>',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    type: 'button',
    props: { variant: 'solid' },
    children: 'Click me',
    themeId: 'project-123',  // Theme applied during SSR
    projectId: '123'
  })
}).then(r => r.json());

// Inject into iframe/DOM
iframe.contentDocument.body.innerHTML = `<style>${css}</style>${html}`;
```

**Errors**:
- 401 (auth) - Invalid/missing authentication
- 400 (invalid) - Malformed request
- 422 (validation) - Invalid component type or props
- 424 (failed dependency) - Theme Service unavailable or theme not found

### GET /health
Health check (no auth required)

```typescript
{ status: "healthy", uptime: 3600 }
```

### GET /metrics
Prometheus metrics endpoint (auth required)

---

## Client Rendering Strategy: SSR with Mandatory Hydration

### Overview

The service uses **Server-Side Rendering (SSR) with mandatory client-side hydration** to provide:
1. **Instant display** - HTML renders immediately in iframe
2. **Full interactivity** - React hydration enables event handlers and state

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  External App   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ 1. POST /render
         â”‚ { type: "button", props: { onClick: "..." } }
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Rendering Service  â”‚
â”‚  - renderToString() â”‚
â”‚  - Extract CSS      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ 2. Returns HTML + CSS + hydration data
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  External App   â”‚
â”‚  Injects HTML   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ 3. Display immediately (SSR benefit)
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  iframe shows static â”‚
â”‚  HTML (instant)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ 4. Load hydration runtime
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Nimbus Hydration    â”‚
â”‚  Runtime (React +    â”‚
â”‚  components)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ 5. hydrateRoot()
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Fully interactive   â”‚
â”‚  component           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Two-Phase Rendering

**Phase 1: Instant Display (SSR)**
- Service returns pre-rendered HTML + CSS
- Client injects into iframe immediately
- User sees styled component instantly
- No interactivity yet

**Phase 2: Hydration (Client-Side)**
- Client loads Nimbus hydration runtime
- Runtime attaches React event handlers
- Component becomes fully interactive
- Matches server-rendered HTML exactly

### API Response Format

The service returns HTML, CSS, and hydration metadata:

```json
{
  "html": "<button class='nimbus-button' data-hydrate-id='btn-123'>Click me</button>",
  "css": ".nimbus-button { /* styles */ }",
  "hydration": {
    "componentType": "button",
    "props": { "variant": "solid", "onClick": "handleClick" },
    "hydrateId": "btn-123"
  },
  "metadata": { "renderedAt": "...", "version": "1.0.0" }
}
```

### Client Implementation Pattern

**External apps must**:
1. Inject HTML + CSS for instant display (with theme already applied)
2. Load Nimbus hydration runtime
3. Call hydration API with hydration metadata

```javascript
// 1. Fetch rendered component with theme
const { html, css, hydration } = await fetch('/render', {
  method: 'POST',
  headers: { 'Authorization': 'Bearer <token>' },
  body: JSON.stringify({
    type: 'button',
    props: { variant: 'solid', onClick: () => alert('clicked') },
    themeId: 'project-123',  // Theme applied during SSR
    projectId: '123'
  })
}).then(r => r.json());

// 2. Inject HTML + CSS immediately (instant display)
iframe.contentDocument.body.innerHTML = `
  <style>${css}</style>
  <div id="root">${html}</div>
`;

// 3. Load Nimbus hydration runtime
const script = iframe.contentDocument.createElement('script');
script.src = 'https://cdn.commercetools.com/nimbus-hydration-runtime.js';
script.onload = () => {
  // 4. Hydrate component (makes it interactive)
  iframe.contentWindow.NimbusRuntime.hydrate({
    rootId: 'root',
    hydration: hydration
  });
};
iframe.contentDocument.head.appendChild(script);
```

### Hydration Runtime Requirements

**Client must load**:
- `nimbus-hydration-runtime.js` (~150KB gzipped)
  - React 18 (for hydrateRoot)
  - Minimal Nimbus components registry
  - Chakra UI providers
  - Event handler serialization/deserialization

**Runtime provides**:
```javascript
window.NimbusRuntime = {
  hydrate(config: {
    rootId: string;
    hydration: HydrationMetadata;
  }): void;
};
```

### Service Implementation Changes

The rendering service must:
1. Track hydration points with unique IDs
2. Serialize component metadata for hydration
3. Return hydration instructions alongside HTML

```typescript
export class RenderingService {
  async render(request: RenderRequest): Promise<RenderResponse> {
    // Generate unique hydration ID
    const hydrateId = `hydrate-${uuid()}`;

    // Create React element with hydration metadata
    const element = createElement(Component, {
      ...request.props,
      'data-hydrate-id': hydrateId
    });

    // SSR to HTML
    const html = renderToString(wrapWithProviders(element));

    // Extract CSS
    const css = extractCriticalCSS(html);

    // Return HTML + hydration metadata
    return {
      html,
      css,
      hydration: {
        hydrateId,
        componentType: request.type,
        props: request.props
      }
    };
  }
}
```

### Benefits of This Approach

âœ… **Instant visual feedback** - SSR displays immediately
âœ… **Full interactivity** - Hydration enables all React features
âœ… **Consistent rendering** - Server and client match exactly
âœ… **Progressive enhancement** - Works even if hydration is delayed

### Requirements for External Apps

External applications **must**:
- âœ… Support iframe injection
- âœ… Load Nimbus hydration runtime (CDN or bundled)
- âœ… Call hydration API after HTML injection
- âœ… Handle hydration errors gracefully

### Trade-offs vs Pure SSR

**Pros**:
- Full interactivity (event handlers, state management)
- Single source of truth (Nimbus components)
- Supports complex components (forms, modals, etc.)

**Cons**:
- Client must load ~150KB runtime
- Hydration delay (instant HTML â†’ interactive after runtime loads)
- Requires JavaScript execution in iframe

---

## Kubernetes Deployment (Phase 2)

**High-level approach**:
- Deployment with 3+ replicas
- HPA (CPU/memory-based scaling)
- Liveness/readiness probes on `/health`
- ConfigMap for env vars
- Secrets for JWT keys
- Optional: Redis for rate limiting

**Example**:
```yaml
# Simplified deployment
apiVersion: apps/v1
kind: Deployment
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: service
        image: component-rendering-service
        ports: [3000]
        livenessProbe:
          httpGet: { path: /health, port: 3000 }
        resources:
          requests: { memory: "256Mi", cpu: "100m" }
          limits: { memory: "512Mi", cpu: "500m" }
```

---

## Implementation Roadmap

### Context: LLM Response UIs

This service is **specifically for rendering high-complexity, interactive components** in LLM response UIs (chat interfaces, MCP tools, etc.). Target components include:
- Interactive forms with validation
- Data tables with sorting/filtering
- Multi-step wizards
- Complex dashboards
- Real-time data displays

### Phase 1: Production Node.js + Hydration Runtime (4 weeks)

**Week 1 - Core Service**:
- Setup (TypeScript, Express, Zod)
- **commercetools-identity authentication integration**
- **Theme Service API client**
- SSR engine (renderToString + CSS extraction)
- POST /render with theme resolution
- Support complex component trees

**Week 2 - Theme Integration & Hydration Runtime**:
- **Theme caching layer (in-memory/Redis)**
- **Theme resolution flow (themeId â†’ Theme Service â†’ SSR)**
- **Test theme application in rendered components**
- Create `nimbus-hydration-runtime` package
- Support high-complexity components (forms, tables, modals)
- Event handler serialization/deserialization

**Week 3 - Integration Testing**:
- **Test multi-project theme rendering**
- Test complex component hydration
- Validate event handlers work post-hydration
- Test LLM workflow integration
- Browser compatibility (iframe contexts)

**Week 4 - Production Readiness**:
- Observability (logs, metrics, alerts)
- **Theme Service API health monitoring**
- Docker + compose
- Documentation (MCP server integration)

### Phase 2: Kubernetes + CDN (2-3 weeks)

**Service Deployment**:
- K8s manifests
- CDN for hydration runtime
- Monitoring

**Optional**:
- Rate limiting
- Redis (HTML caching)
- Component prewarming

---

## Success Criteria

**Phase 1**:
- âœ… **commercetools-identity auth working**
- âœ… **Theme Service integration functional**
- âœ… **Theme resolution and caching working**
- âœ… **Themes correctly applied per project/organization**
- âœ… SSR rendering functional (HTML + CSS + hydration data)
- âœ… Hydration runtime working in iframes
- âœ… Complex components hydrate correctly (forms, tables, modals)
- âœ… Event handlers functional post-hydration
- âœ… Tests passing (service + runtime + integration + theme resolution)
- âœ… Logs â†’ Humio, Metrics â†’ Prometheus
- âœ… Docker containerized
- âœ… P95 latency < 150ms (SSR + CSS extraction + theme resolution)
- âœ… Hydration success rate > 99%
- âœ… **Theme Service availability > 99.9%**
- âœ… LLM integration validated (MCP workflow)

**Phase 2**:
- âœ… Kubernetes deployment stable
- âœ… HPA scaling functional
- âœ… CDN serving hydration runtime
- âœ… Zero-downtime updates
- âœ… Monitoring dashboards live

---

## Security

**Phase 1**:
- HTTPS only (TLS termination)
- commercetools-identity OAuth2 validation
- Theme Service API authentication
- Input validation (Zod)
- Request size limits
- Secure error messages (no data leaks)

**Phase 2**:
- Kubernetes secrets (auth credentials, API keys)
- Network policies (pod isolation)
- RBAC for service accounts
- Redis TLS (if used)

---

## Observability

**Logging** (Falcon LogScale/Humio):
- Structured JSON logs
- Request/response logs
- Auth events, errors

**Metrics** (Prometheus):
- `http_requests_total` - Request rate
- `http_request_duration_seconds` - SSR latency (p50/p95/p99)
- `auth_failures_total` - Failed auth
- `render_errors_total` - SSR rendering errors
- **`theme_resolution_duration_seconds`** - Theme Service API call latency
- **`theme_cache_hit_rate`** - Theme cache efficiency
- **`theme_service_errors_total`** - Failed Theme Service calls
- `hydration_success_total` - Successful hydrations (client-reported)
- `hydration_errors_total` - Hydration failures (client-reported)
- `hydration_latency_seconds` - Time to interactive (client-reported)
- `css_extraction_duration_seconds` - CSS extraction time
- `component_complexity_score` - Component tree depth/nodes

**Alerts** (Prometheus):
- **Critical**: Service down >2min, SSR error rate >5%, p99 >500ms, hydration failure rate >5%, **Theme Service unavailable**
- **Warning**: SSR error rate >1%, memory >80%, p95 >200ms, hydration failure rate >1%, time-to-interactive >3s, **Theme Service error rate >1%, theme cache hit rate <80%**

---

## Next Steps

### Service Development
1. **Project setup** (TypeScript, Express, Zod)
2. **Auth implementation** (commercetools-identity OAuth2)
3. **Theme Service integration** (API client + caching)
4. **SSR engine** (React renderToString + Emotion CSS extraction + theme application)
5. **Hydration metadata** (component serialization, unique IDs)
6. **Testing** (unit + integration + E2E + theme resolution)
7. **Observability** (Humio + Prometheus + Theme Service monitoring)

### Hydration Runtime Development
7. **Runtime package** (`nimbus-hydration-runtime`)
8. **Component registry** (map string names to Nimbus components)
9. **Hydration API** (`NimbusRuntime.hydrate()`)
10. **Event handler rehydration** (serialize/deserialize)
11. **Browser testing** (Playwright in iframe contexts)
12. **CDN build** (bundle, minify, versioning)

### Integration & Deployment
13. **LLM workflow integration** (MCP server testing)
14. **Containerization** (Docker + compose)
15. **Kubernetes deployment**
16. **Production validation** (complex components in LLM UIs)

---

## Appendix

### JWT Token Example

```json
{
  "sub": "client-id",
  "iss": "nimbus-rendering-service",
  "scope": "render:read render:write",
  "exp": 1735689600
}
```

**Scopes**:
- `render:read` - Health/metrics
- `render:write` - POST /render
- `admin` - Full access

### Key Environment Variables

```bash
# Core
PORT=3000
JWT_SECRET=<secret>
JWT_ISSUER=nimbus-rendering-service

# Observability
PROMETHEUS_PORT=9090
HUMIO_ENDPOINT=https://cloud.humio.com
HUMIO_INGEST_TOKEN=<token>

# Phase 2
REDIS_URL=redis://localhost:6379
```
