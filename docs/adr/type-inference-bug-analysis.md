# Type Inference Bug Analysis: SlotRecipeProps in Consumer Applications

## Executive Summary

Nimbus components display incorrect TypeScript types in consumer applications
(like Merchant Center). Props work correctly at runtime, but IDEs show wrong
type definitions, causing false TypeScript errors and broken autocomplete.

**Root Cause (Verified):** Type definitions reference Chakra UI's theme system
(`SlotRecipeProps<"drawer">`), which resolves against Chakra's **default** types
in consumer apps instead of Nimbus's custom types. This was empirically verified
by comparing the published `@chakra-ui/react` npm package against the Nimbus
workspace.

**Solution (POC Validated):** Export variant types directly from recipe files
using `keyof typeof` and consume them wrapped in `ConditionalValue`. This
approach was validated through POC testing on Drawer and Alert components,
confirming it preserves PropsTable documentation extraction while fixing
consumer type inference.

**Impact:** 47 components affected (all components using `RecipeProps` or
`SlotRecipeProps` for variant type definitions).

**Quick Start:** For each affected component:

1. Extract variants to `const myComponentVariants = { /* ... */ } as const`
2. Export types: `export type MyProp = keyof typeof myComponentVariants.myProp`
3. Use in types file: `myProp?: ConditionalValue<MyProp>` (import from recipe)

**Visual Example:**

```diff
// drawer.recipe.ts
+ const drawerVariants = {
+   placement: { left: {}, right: {}, top: {}, bottom: {} },
+ } as const;

  export const drawerSlotRecipe = defineSlotRecipe({
-   variants: {
-     placement: { left: {}, right: {}, top: {}, bottom: {} },
-   },
+   variants: drawerVariants,
  });

+ export type DrawerPlacement = keyof typeof drawerVariants.placement;

// drawer.types.ts
- import type { SlotRecipeProps } from "@chakra-ui/react";
+ import type { ConditionalValue } from "@chakra-ui/react";
+ import type { DrawerPlacement } from "./drawer.recipe";

  type DrawerRecipeProps = {
-   placement?: SlotRecipeProps<"drawer">["placement"];
+   placement?: ConditionalValue<DrawerPlacement>;
  };
```

---

## Table of Contents

1. [Understanding the Problem](#understanding-the-problem)
2. [How TypeScript Types Flow](#how-typescript-types-flow)
3. [Root Cause Analysis](#root-cause-analysis)
4. [Empirical Verification](#empirical-verification)
5. [POC Implementation Results](#poc-implementation-results)
6. [Affected Components](#affected-components)
7. [Proposed Solution](#proposed-solution)
8. [Implementation Guide](#implementation-guide)
9. [Appendix](#appendix)

---

## Understanding the Problem

### What Users See

When developers use Nimbus components in their applications, their IDE shows
incorrect type suggestions:

```tsx
// In a consumer application (e.g., Merchant Center)

<Drawer.Root placement="left">
  {" "}
  // âŒ TypeScript Error!
  {/* ... */}
</Drawer.Root>
```

**Error message:**

```
Type '"left"' is not assignable to type 'ConditionalValue<"bottom" | "top" | "start" | "end" | undefined>'.
```

But the Nimbus documentation says `placement` accepts
`"left" | "right" | "top" | "bottom"`, and the component works correctly at
runtime with `placement="left"`.

### The Disconnect

| Context          | What Types Show                          | Works at Runtime? |
| ---------------- | ---------------------------------------- | ----------------- |
| Nimbus workspace | `"left" \| "right" \| "top" \| "bottom"` | âœ… Yes            |
| Consumer app IDE | `"start" \| "end" \| "top" \| "bottom"`  | âœ… Yes            |
| Nimbus docs site | `"left" \| "right" \| "top" \| "bottom"` | âœ… Yes            |

The types are wrong only in consumer applications' development environments.

---

## How TypeScript Types Flow

To understand this bug, we need to understand how types travel from Nimbus to
consumer applications.

### Step 1: Types Are Defined in Nimbus

In the Nimbus codebase, component types are defined like this:

```typescript
// packages/nimbus/src/components/drawer/drawer.types.ts

import type { SlotRecipeProps } from "@chakra-ui/react";

type DrawerRecipeProps = {
  placement?: SlotRecipeProps<"drawer">["placement"];
};
```

The key here is `SlotRecipeProps<"drawer">["placement"]`. This is a **type
lookup** that says:

> "Go find the drawer recipe configuration and get the type of its placement
> property."

### Step 2: Types Are Generated by Chakra CLI

When Nimbus runs `pnpm build-theme-typings`, Chakra's CLI tool:

1. Reads all recipe definitions (like `drawerSlotRecipe`)
2. Generates a `recipes.gen.d.ts` file with concrete types
3. Places this in `node_modules/@chakra-ui/react/`

This generated file contains:

```typescript
// Generated in Nimbus workspace
export interface DrawerVariant {
  placement?: "left" | "right" | "top" | "bottom" | undefined;
}
```

### Step 3: Nimbus Is Published

When Nimbus is published to npm:

- âœ… Component source code is included
- âœ… Type definition files (`.d.ts`) are included
- âŒ **The generated `recipes.gen.d.ts` is NOT included** (it's in
  `node_modules/`)

### Step 4: Consumer Installs Nimbus

When a consumer app installs `@commercetools/nimbus`:

```bash
npm install @commercetools/nimbus
```

They get:

- Nimbus components and types
- Their **own** `@chakra-ui/react` package with **Chakra's default**
  `recipes.gen.d.ts`

### Step 5: Types Resolve Against Wrong Definitions

When TypeScript compiles the consumer's code:

```typescript
// Consumer's node_modules/@chakra-ui/react/recipes.gen.d.ts
// This is Chakra's DEFAULT, not Nimbus's custom types!

export interface DrawerVariant {
  placement?: "start" | "end" | "top" | "bottom" | undefined; // Chakra defaults!
}
```

The `SlotRecipeProps<"drawer">["placement"]` in Nimbus's type definitions now
resolves against Chakra's defaults, not Nimbus's custom values.

### Visual Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         NIMBUS WORKSPACE                                 â”‚
â”‚                                                                          â”‚
â”‚  drawer.types.ts                     node_modules/@chakra-ui/react/     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ SlotRecipeProps<    â”‚ â”€â”€resolvesâ”€â”€â–¶â”‚ DrawerVariant {             â”‚    â”‚
â”‚  â”‚   "drawer"          â”‚     to      â”‚   placement?: "left" |      â”‚    â”‚
â”‚  â”‚ >["placement"]      â”‚             â”‚     "right" | "top" |       â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚     "bottom"                â”‚    â”‚
â”‚                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                      (Generated by Nimbus theme)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â”‚ npm publish
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        CONSUMER APPLICATION                              â”‚
â”‚                                                                          â”‚
â”‚  node_modules/@commercetools/nimbus/   node_modules/@chakra-ui/react/   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ SlotRecipeProps<    â”‚ â”€â”€resolvesâ”€â”€â–¶ â”‚ DrawerVariant {             â”‚  â”‚
â”‚  â”‚   "drawer"          â”‚     to        â”‚   placement?: "start" |     â”‚  â”‚
â”‚  â”‚ >["placement"]      â”‚    WRONG!     â”‚     "end" | "top" |         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚     "bottom"                â”‚  â”‚
â”‚                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                        (Chakra's DEFAULT theme)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Root Cause Analysis

### The Core Issue

**Type definitions use a reference (`SlotRecipeProps<"drawer">`) instead of
concrete values (`"left" | "right" | "top" | "bottom"`).**

This reference resolves at **compile time in the consumer's environment**, not
at Nimbus build time.

### Why It Works in Some Places

| Environment          | Why It Works/Fails                                                         |
| -------------------- | -------------------------------------------------------------------------- |
| **Nimbus workspace** | âœ… Theme typings are generated locally                                     |
| **Nimbus docs site** | âœ… `react-docgen-typescript` extracts types at build time within workspace |
| **Consumer apps**    | âŒ Types resolve against consumer's Chakra package                         |
| **Runtime**          | âœ… JavaScript doesn't care about types                                     |

### Components Most Affected

Components are affected when:

1. They use `SlotRecipeProps<"recipeName">["propName"]` pattern
2. Chakra has a built-in recipe with the **same name** but **different
   variants**

High-risk overlaps with Chakra defaults:

- `drawer` (placement values differ)
- `alert` (variant values differ)
- `dialog` (placement values differ)
- `tabs` (variant values differ)
- `accordion`, `checkbox`, `switch`, `menu` (may have variant differences)

---

## Empirical Verification

The root cause hypothesis was verified by comparing the actual type definitions
between Chakra's default npm package and the Nimbus workspace.

### Methodology

To prove that consumer applications receive different types than the Nimbus
workspace, we:

1. Downloaded the published `@chakra-ui/react@3.31.0` package directly from npm
2. Extracted its `recipes.gen.d.ts` file (Chakra's default theme types)
3. Compared it against the same file in the Nimbus workspace (which has been
   overwritten by `pnpm build-theme-typings`)

### Commands Used

```bash
# Download and extract Chakra's default package from npm registry
curl -sL "https://registry.npmjs.org/@chakra-ui/react/-/react-3.31.0.tgz" | tar -xzf -

# Compare the DrawerVariant interface
grep -A6 "export interface DrawerVariant" package/dist/types/styled-system/generated/recipes.gen.d.ts
```

### Results: Drawer Component

**Chakra's Default Types (from npm registry):**

```typescript
export interface DrawerVariant {
  /** @default "xs" */
  size?: "xs" | "sm" | "md" | "lg" | "xl" | "full" | undefined;
  /** @default "end" */
  placement?: "start" | "end" | "top" | "bottom" | undefined;
  contained?: boolean | undefined;
}
```

**Nimbus Workspace Types (after `build-theme-typings`):**

```typescript
export interface DrawerVariant {
  /** @default true */
  showBackdrop?: boolean | undefined;
  /** @default "right" */
  placement?: "left" | "right" | "top" | "bottom" | undefined;
}
```

| Property       | Chakra Default                                   | Nimbus Workspace                         |
| -------------- | ------------------------------------------------ | ---------------------------------------- |
| `placement`    | `"start" \| "end" \| "top" \| "bottom"`          | `"left" \| "right" \| "top" \| "bottom"` |
| `size`         | `"xs" \| "sm" \| "md" \| "lg" \| "xl" \| "full"` | _(not defined)_                          |
| `showBackdrop` | _(not defined)_                                  | `boolean`                                |
| `contained`    | `boolean`                                        | _(not defined)_                          |

**Key finding:** Chakra uses RTL-aware `"start" | "end"` while Nimbus uses
directional `"left" | "right"`.

### Results: Alert Component

**Chakra's Default Types:**

```typescript
export interface AlertVariant {
  /** @default "info" */
  status?: "info" | "warning" | "success" | "error" | "neutral" | undefined;
  /** @default false */
  inline?: boolean | undefined;
}
```

**Nimbus Workspace Types:**

```typescript
export interface AlertVariant {
  variant?: "flat" | "outlined" | undefined;
}
```

| Property  | Chakra Default                                             | Nimbus Workspace       |
| --------- | ---------------------------------------------------------- | ---------------------- |
| `status`  | `"info" \| "warning" \| "success" \| "error" \| "neutral"` | _(not defined)_        |
| `variant` | _(not defined)_                                            | `"flat" \| "outlined"` |
| `inline`  | `boolean`                                                  | _(not defined)_        |

**Key finding:** The variant structures are completely different. Chakra's Alert
uses `status` while Nimbus uses `variant`.

### Conclusion

This empirical comparison **confirms the root cause**:

1. âœ… Chakra's published npm package contains default theme types
2. âœ… Nimbus's `build-theme-typings` overwrites these with custom types locally
3. âœ… The overwritten types are NOT published with Nimbus (they're in
   `node_modules/`)
4. âœ… Consumer applications install Chakra's defaults, not Nimbus's
   customizations
5. âœ… `SlotRecipeProps<"drawer">` resolves against the wrong type definitions

---

## POC Implementation Results

A proof-of-concept implementation was completed on Drawer and Alert components
to validate the proposed solution. **Note:** This POC work was for validation
purposes and has not been committed to the main codebase. The findings and
approach documented here should be used for the full rollout.

### Implementation Approach

The POC implementation used the following pattern:

1. **Extract variants to const** with `as const` assertion
2. **Export types using direct `keyof typeof`** (not utility type)
3. **Wrap in `ConditionalValue`** in types file to preserve responsive props

### Code Changes

**Drawer Recipe (`drawer.recipe.ts`):**

```typescript
const drawerVariants = {
  placement: {
    left: {
      /* ... */
    },
    right: {
      /* ... */
    },
    top: {
      /* ... */
    },
    bottom: {
      /* ... */
    },
  },
  showBackdrop: {
    true: {
      /* ... */
    },
    false: {
      /* ... */
    },
  },
} as const;

export const drawerSlotRecipe = defineSlotRecipe({
  // ...
  variants: drawerVariants,
});

// Direct keyof typeof - no utility type needed
export type DrawerPlacement = keyof typeof drawerVariants.placement;
export type DrawerShowBackdrop = boolean;
```

**Drawer Types (`drawer.types.ts`):**

```typescript
import type { ConditionalValue } from "@chakra-ui/react";
import type { DrawerPlacement } from "./drawer.recipe";

type DrawerRecipeProps = {
  placement?: ConditionalValue<DrawerPlacement>;
  showBackdrop?: boolean;
};
```

### Verification Results

After rebuilding both Nimbus package and docs site, PropsTable extraction was
verified:

**âœ… DrawerRoot Props - Preserved:**

| Property       | Before                                                     | After                                                      | Status        |
| -------------- | ---------------------------------------------------------- | ---------------------------------------------------------- | ------------- |
| `placement`    | `ConditionalValue<"bottom" \| "left" \| "right" \| "top">` | `ConditionalValue<"bottom" \| "left" \| "right" \| "top">` | âœ… Identical  |
| `showBackdrop` | `ConditionalValue<boolean> & boolean`                      | `boolean`                                                  | âœ… Simplified |

**âœ… AlertRoot Props - Preserved:**

| Property  | Before                                   | After                                    | Status       |
| --------- | ---------------------------------------- | ---------------------------------------- | ------------ |
| `variant` | `ConditionalValue<"flat" \| "outlined">` | `ConditionalValue<"flat" \| "outlined">` | âœ… Identical |

### Key Findings

1. **`react-docgen-typescript` successfully extracts concrete types** from
   `keyof typeof` expressions
2. **`ConditionalValue` wrapper is preserved** in the extracted types
3. **Responsive prop support is maintained** (can still use
   `{{ base: "bottom", md: "left" }}`)
4. **Documentation quality is unchanged** - PropsTable shows the same type
   information

### Why Direct `keyof typeof` Works Better Than Utility Type

Initial approach attempted to use an `ExtractVariantKeys` utility type:

```typescript
export type ExtractVariantKeys<T> = keyof T extends "true" | "false"
  ? boolean
  : keyof T;
```

However, `react-docgen-typescript` cannot fully resolve complex utility types
across file boundaries. Using direct `keyof typeof` produces the same result but
allows the type parser to resolve it correctly:

```typescript
// âŒ Parser can't fully resolve this
export type DrawerPlacement = ExtractVariantKeys<
  typeof drawerVariants.placement
>;

// âœ… Parser resolves this correctly
export type DrawerPlacement = keyof typeof drawerVariants.placement;
```

For boolean variants, we explicitly type as `boolean` rather than computing it:

```typescript
// Direct boolean type (not derived)
export type DrawerShowBackdrop = boolean;
```

### POC Conclusion

**The solution has been validated and is ready for full rollout:**

- âœ… **Fixes consumer type inference** - Types will be baked into `.d.ts` files
- âœ… **Preserves documentation extraction** - PropsTable continues to work
- âœ… **Maintains responsive prop support** - `ConditionalValue` wrapper
  preserved
- âœ… **Single source of truth** - Variant values defined once in recipe
- âœ… **No breaking changes** - Component API unchanged, types only
- âœ… **No runtime impact** - JavaScript behavior unchanged

**Status:** POC validated on 2 components (Drawer, Alert). Implementation needs
to be applied to remaining 45 components following the patterns documented in
this proposal.

---

## Affected Components

### Summary: 47 Components Require Updates

**Complete inventory:**

- **30 components** use `SlotRecipeProps<"recipeName">` (multi-element recipes)
- **17 components** use `RecipeProps<"recipeName">` (single-element recipes)
- **Both patterns have the same bug** - type lookups resolve against consumer's
  Chakra installation

### Why Both Recipe Types Are Affected

Both `RecipeProps` and `SlotRecipeProps` use the same lookup mechanism:

```typescript
// From Chakra's type system
type RecipeProps<T> = T extends keyof ConfigRecipes
  ? ConfigRecipes[T]["__type"]  // â† Lookup happens at consumer compile time
  : ...

type SlotRecipeProps<T> = T extends keyof ConfigSlotRecipes
  ? ConfigSlotRecipes[T]["__type"]  // â† Lookup happens at consumer compile time
  : ...
```

**Example - Icon component (uses `RecipeProps`):**

| Source           | `size` values                                                |
| ---------------- | ------------------------------------------------------------ |
| Chakra default   | `"inherit" \| "xs" \| "sm" \| "md" \| "lg" \| "xl" \| "2xl"` |
| Nimbus workspace | `"2xs" \| "xs" \| "sm" \| "md" \| "lg" \| "xl"`              |

Consumers would see Chakra's values, not Nimbus's.

### Components NOT Affected (21 components)

These components have no recipe variants and don't need updates:

- `box`, `flex`, `grid`, `simple-grid`, `stack`
- `spacer`, `visually-hidden`, `image`, `text`
- `icon-button`, `icon-toggle-button`, `inline-svg`
- `nimbus-i18n-provider`, `nimbus-provider`, `pagination`, `password-input`
- Plus a few others without recipe-based styling

See the
[Complete Component Reference Table](#complete-component-reference-table) in the
Rollout Strategy section for the full list of 47 components requiring updates.

---

## Proposed Solution

### Approach: Export Variant Types from Recipe Definitions

Instead of referencing `SlotRecipeProps`, we derive and export concrete types
directly from the recipe definition. This ensures types are "baked in" at Nimbus
build time.

### Before (Current Pattern)

```typescript
// drawer.recipe.ts
export const drawerSlotRecipe = defineSlotRecipe({
  variants: {
    placement: {
      left: {
        /* styles */
      },
      right: {
        /* styles */
      },
      top: {
        /* styles */
      },
      bottom: {
        /* styles */
      },
    },
  },
});

// drawer.types.ts
import type { SlotRecipeProps } from "@chakra-ui/react";

type DrawerRecipeProps = {
  placement?: SlotRecipeProps<"drawer">["placement"]; // âŒ Resolves at consumer compile time
};
```

### After (Proposed Pattern)

```typescript
// drawer.recipe.ts
const drawerVariants = {
  placement: {
    left: {
      /* styles */
    },
    right: {
      /* styles */
    },
    top: {
      /* styles */
    },
    bottom: {
      /* styles */
    },
  },
  showBackdrop: {
    true: {
      /* styles */
    },
    false: {
      /* styles */
    },
  },
} as const; // ğŸ‘ˆ Important: preserves literal types

export const drawerSlotRecipe = defineSlotRecipe({
  slots: [
    /* ... */
  ],
  variants: drawerVariants,
});

// Export derived types using direct keyof typeof
export type DrawerPlacement = keyof typeof drawerVariants.placement;
// Result: "left" | "right" | "top" | "bottom"

export type DrawerShowBackdrop = boolean;
// For boolean variants (true/false keys), explicitly type as boolean

// drawer.types.ts
import type { ConditionalValue } from "@chakra-ui/react";
import type { DrawerPlacement } from "./drawer.recipe";

type DrawerRecipeProps = {
  placement?: ConditionalValue<DrawerPlacement>; // âœ… Concrete type + responsive support
  showBackdrop?: boolean;
};
```

### Why This Works

1. **`as const`** tells TypeScript to preserve the exact literal types instead
   of widening to `string`
2. **`keyof typeof`** extracts the keys as a union type that TypeScript and
   tooling can fully resolve
3. **Types are computed at Nimbus build time** and embedded in the `.d.ts` files
   as concrete unions
4. **Consumer apps receive concrete types** that don't depend on their Chakra
   installation
5. **`react-docgen-typescript` can extract these types** for documentation
   generation

### Important: Preserving ConditionalValue Wrapper

The current types use Chakra's `ConditionalValue` wrapper to support responsive
props:

```tsx
// This responsive syntax is enabled by ConditionalValue
<Drawer.Root placement={{ base: "bottom", md: "left" }} />
```

**Current extracted type (from PropsTable):**

```
ConditionalValue<"bottom" | "left" | "right" | "top">
```

To preserve this functionality AND the PropsTable output, wrap the derived type
in `ConditionalValue`:

```typescript
// drawer.types.ts
import type { ConditionalValue } from "@chakra-ui/react";
import type { DrawerPlacement } from "./drawer.recipe";

type DrawerRecipeProps = {
  placement?: ConditionalValue<DrawerPlacement>; // âœ… Preserves responsive support
  showBackdrop?: boolean;
};
```

**Why `ConditionalValue` doesn't have the same resolution problem:**

`ConditionalValue` is a generic utility type, not a theme-dependent lookup:

```typescript
// Same definition in ALL Chakra installations
export type ConditionalValue<V> =
  | V
  | Array<V | null>
  | {
      [K in keyof Conditions]?: ConditionalValue<V>;
    };
```

It takes a type parameter `V` and doesn't reference `ConfigSlotRecipes` or any
generated theme types. This means it resolves identically in both the Nimbus
workspace and consumer applications.

| Type                        | Depends on Theme?                   | Safe to Use? |
| --------------------------- | ----------------------------------- | ------------ |
| `SlotRecipeProps<"drawer">` | âœ… Yes (looks up ConfigSlotRecipes) | âŒ No        |
| `ConditionalValue<T>`       | âŒ No (generic utility)             | âœ… Yes       |

---

## Implementation Guide

Follow these steps to update each affected component. The patterns below were
validated through POC testing on Drawer and Alert components.

**Implementation Status:** All 47 components are pending implementation. Use the
patterns documented here for each component, referring to the POC code examples
in the Appendix.

### Step 1: Update Recipe File

For each affected component's `.recipe.ts` file:

1. Extract the `variants` object to a separate const with `as const` assertion
2. Pass the const to `defineSlotRecipe`
3. Export type aliases using direct `keyof typeof`

**Example for Drawer:**

```typescript
// drawer.recipe.ts
import { defineSlotRecipe } from "@chakra-ui/react/styled-system";

// 1. Extract variants to const with as const
const drawerVariants = {
  placement: {
    left: {
      /* ... */
    },
    right: {
      /* ... */
    },
    top: {
      /* ... */
    },
    bottom: {
      /* ... */
    },
  },
  showBackdrop: {
    true: {
      /* ... */
    },
    false: {
      /* ... */
    },
  },
} as const;

// 2. Use the const in recipe definition
export const drawerSlotRecipe = defineSlotRecipe({
  slots: ["trigger", "modalOverlay", "modal", "content" /* ... */],
  className: "nimbus-drawer",
  base: {
    /* ... */
  },
  variants: drawerVariants, // â† Reference the const
  defaultVariants: {
    placement: "right",
    showBackdrop: true,
  },
});

// 3. Export derived types using direct keyof typeof
export type DrawerPlacement = keyof typeof drawerVariants.placement;
export type DrawerShowBackdrop = boolean; // For true/false variants, use boolean directly
```

**For Alert:**

```typescript
// alert.recipe.ts
const alertVariants = {
  variant: {
    flat: {},
    outlined: {
      /* ... */
    },
  },
} as const;

export const alertRecipe = defineSlotRecipe({
  slots: ["root", "title", "description", "icon", "actions", "dismissButton"],
  className: "nimbus-alert",
  base: {
    /* ... */
  },
  variants: alertVariants,
});

export type AlertVariant = keyof typeof alertVariants.variant;
```

### Step 2: Update Types File

For each affected component's `.types.ts` file:

1. Remove `SlotRecipeProps` import
2. Import `ConditionalValue` from `@chakra-ui/react`
3. Import the derived types from the recipe file
4. Update the recipe props type to use the imported types
5. Wrap non-boolean props in `ConditionalValue` to preserve responsive support

**Example for Drawer:**

```typescript
// drawer.types.ts
import type {
  HTMLChakraProps,
  ConditionalValue, // â† Import ConditionalValue
} from "@chakra-ui/react";
import type { DrawerPlacement } from "./drawer.recipe"; // â† Import from recipe

type DrawerRecipeProps = {
  /** Placement of the drawer in the viewport */
  placement?: ConditionalValue<DrawerPlacement>; // â† Wrap in ConditionalValue
  /** Whether to show backdrop overlay */
  showBackdrop?: boolean; // â† Boolean variants don't need ConditionalValue
};
```

**Example for Alert:**

```typescript
// alert.types.ts
import type { HTMLChakraProps, ConditionalValue } from "@chakra-ui/react";
import type { AlertVariant } from "./alert.recipe";

type AlertRecipeProps = {
  /** Visual style variant of the alert */
  variant?: ConditionalValue<AlertVariant>;
};
```

### Step 3: Build and Verify

After making changes:

```bash
# 1. Build the Nimbus package
pnpm --filter @commercetools/nimbus build

# 2. Rebuild docs site (to regenerate PropsTable JSON)
pnpm --filter docs build:docs

# 3. Verify the generated type files
cat packages/nimbus/dist/components/drawer/drawer.types.d.ts
cat packages/nimbus/dist/components/drawer/drawer.recipe.d.ts

# 4. Verify PropsTable extraction
cat apps/docs/src/data/types/DrawerRoot.json
```

**What to check:**

- âœ… `.d.ts` files contain concrete union types (not `SlotRecipeProps`
  references)
- âœ… PropsTable JSON shows `ConditionalValue<"value1" | "value2">` format
- âœ… TypeScript compilation succeeds without errors

### Step 4: Handling Different Variant Patterns

**For string union variants:**

```typescript
// Export as keyof typeof
export type MyComponentSize = keyof typeof myComponentVariants.size;
// Use with ConditionalValue in types file
size?: ConditionalValue<MyComponentSize>;
```

**For boolean variants (true/false keys):**

```typescript
// Export as boolean directly
export type MyComponentShowSomething = boolean;
// Use without ConditionalValue in types file
showSomething?: boolean;
```

**For variants with no responsive support needed:**

```typescript
// Still export from recipe for single source of truth
export type MyComponentMode = keyof typeof myComponentVariants.mode;
// Use without ConditionalValue if responsive values don't make sense
mode?: MyComponentMode;
```

---

## Rollout Strategy

This section provides a complete implementation plan for rolling out the fix
across all affected components.

### Scope: Complete Component Inventory

**Total components to update: 47**

This includes ALL components using `RecipeProps` or `SlotRecipeProps`, whether
they extract individual props or use the full recipe type. Both patterns have
the same type resolution bug.

**Breakdown:**

- Components using `SlotRecipeProps`: 30
- Components using `RecipeProps`: 17
- Components NOT affected (no recipe variants): 21
- POC validated (not committed): 2 (drawer, alert)

**Note:** Earlier estimates suggested ~30 affected components based on
`SlotRecipeProps` usage only. Comprehensive analysis revealed `RecipeProps` also
has the same issue, bringing the total to 47.

### Why Update All Components?

1. **All are affected** - Both `RecipeProps` and `SlotRecipeProps` resolve
   against consumer's Chakra installation
2. **Consistency** - Establishes one clear pattern across the entire codebase
3. **Maintainability** - Future contributors see a consistent approach
4. **Prevents confusion** - Mixed patterns would be harder to understand and
   maintain

### Recommended Approach

Update components in **priority order** to maximize impact while maintaining
quality. Use the Complete Component Reference Table below as the master tracking
sheet.

### Progress Tracking

- **Completed:** 0/47 (0%)
- **Tier 1 Remaining:** 21/21 (100%)
- **Tier 2 Remaining:** 26/26 (100%)

**Note:** POC implementation was completed on Drawer and Alert to validate the
approach, but these changes have not been committed to the main branch yet.

### Implementation Notes by Pattern

**For components using FULL recipe type** (e.g.,
`type AccordionRecipeProps = SlotRecipeProps<"accordion">`):

Even though the types file uses the full recipe type, you still need to export
individual variant types:

1. Extract ALL variants from the recipe to a const
2. Export a type for EACH variant property:

   ```typescript
   // accordion.recipe.ts
   const accordionVariants = {
     size: {
       sm: {
         /* ... */
       },
       md: {
         /* ... */
       },
     },
   } as const;

   export const accordionSlotRecipe = defineSlotRecipe({
     variants: accordionVariants,
   });

   // Export type for each variant (not the full recipe object)
   export type AccordionSize = keyof typeof accordionVariants.size;
   ```

3. In types file, replace full recipe type with explicit variant props:

   ```typescript
   // Before
   type AccordionRecipeProps = SlotRecipeProps<"accordion">;

   // After
   import type { ConditionalValue } from "@chakra-ui/react";
   import type { AccordionSize } from "./accordion.recipe";

   type AccordionRecipeProps = {
     size?: ConditionalValue<AccordionSize>;
   };
   ```

**Note:** This converts "full recipe type" usage to explicit props, which is
clearer and avoids the Chakra type lookup issue.

**For components using INDIVIDUAL props** (e.g.,
`size?: RecipeProps<"button">["size"]`):

1. Extract only the relevant variants to a const
2. Export types for each extracted prop:
   ```typescript
   export type ButtonSize = keyof typeof buttonVariants.size;
   export type ButtonVariant = keyof typeof buttonVariants.variant;
   ```
3. In types file, import and wrap each in `ConditionalValue`

**For components with BOOLEAN variants** (e.g.,
`showBackdrop: { true: {}, false: {} }`):

1. Export as `boolean` directly (not `keyof typeof`)
2. Use directly in types file without `ConditionalValue` wrapper

### Complete Component Reference Table

Use this table to track implementation progress and understand each component's
requirements:

| Component            | Recipe Type     | Usage Pattern | Props Extracted                                              | Priority | Status |
| -------------------- | --------------- | ------------- | ------------------------------------------------------------ | -------- | ------ |
| accordion            | SlotRecipeProps | Full          | (all variants)                                               | Tier 1   | â¬œ     |
| alert                | RecipeProps     | Full          | (all variants)                                               | Tier 1   | â¬œ ğŸ§ª  |
| avatar               | RecipeProps     | Individual    | `size`                                                       | Tier 1   | â¬œ     |
| badge                | RecipeProps     | Individual    | `size`                                                       | Tier 1   | â¬œ     |
| button               | RecipeProps     | Individual    | `size`, `variant`                                            | Tier 1   | â¬œ     |
| calendar             | SlotRecipeProps | Full          | (all variants)                                               | Tier 1   | â¬œ     |
| card                 | SlotRecipeProps | Individual    | `cardPadding`, `borderStyle`, `elevation`, `backgroundStyle` | Tier 2   | â¬œ     |
| checkbox             | SlotRecipeProps | Individual    | `size`                                                       | Tier 1   | â¬œ     |
| code                 | RecipeProps     | Full          | (all variants)                                               | Tier 2   | â¬œ     |
| collapsible-motion   | SlotRecipeProps | Full          | (all variants)                                               | Tier 2   | â¬œ     |
| combobox             | SlotRecipeProps | Individual    | `size`, `variant`                                            | Tier 2   | â¬œ     |
| data-table           | SlotRecipeProps | Full          | (all variants)                                               | Tier 1   | â¬œ     |
| date-input           | SlotRecipeProps | Individual    | `size`, `variant`                                            | Tier 2   | â¬œ     |
| date-picker          | SlotRecipeProps | Individual    | `size`, `variant`                                            | Tier 2   | â¬œ     |
| date-range-picker    | SlotRecipeProps | Individual    | `size`, `variant`                                            | Tier 2   | â¬œ     |
| dialog               | SlotRecipeProps | Individual    | `placement`, `scrollBehavior`                                | Tier 1   | â¬œ     |
| draggable-list       | SlotRecipeProps | Individual    | `size`                                                       | Tier 2   | â¬œ     |
| drawer               | RecipeProps     | Full          | (all variants)                                               | Tier 1   | â¬œ ğŸ§ª  |
| field-errors         | SlotRecipeProps | Full          | (all variants)                                               | Tier 1   | â¬œ     |
| form-field           | SlotRecipeProps | Individual    | `size`, `direction`                                          | Tier 1   | â¬œ     |
| group                | RecipeProps     | Full          | (all variants)                                               | Tier 2   | â¬œ     |
| heading              | RecipeProps     | Individual    | `size`                                                       | Tier 2   | â¬œ     |
| icon                 | RecipeProps     | Full          | (all variants)                                               | Tier 2   | â¬œ     |
| kbd                  | RecipeProps     | Full          | (all variants)                                               | Tier 2   | â¬œ     |
| link                 | RecipeProps     | Individual    | `size`, `fontColor`                                          | Tier 2   | â¬œ     |
| list                 | SlotRecipeProps | Full          | (all variants)                                               | Tier 2   | â¬œ     |
| loading-spinner      | RecipeProps     | Individual    | `size`                                                       | Tier 2   | â¬œ     |
| localized-field      | SlotRecipeProps | Individual    | `size`, `type`                                               | Tier 2   | â¬œ     |
| menu                 | SlotRecipeProps | Full          | (all variants)                                               | Tier 1   | â¬œ     |
| money-input          | SlotRecipeProps | Individual    | `size`                                                       | Tier 2   | â¬œ     |
| multiline-text-input | SlotRecipeProps | Individual    | `size`, `variant`                                            | Tier 2   | â¬œ     |
| number-input         | SlotRecipeProps | Individual    | `size`, `variant`                                            | Tier 2   | â¬œ     |
| popover              | RecipeProps     | Full          | (all variants)                                               | Tier 1   | â¬œ     |
| progress-bar         | SlotRecipeProps | Individual    | `size`, `isDynamic`, `isIndeterminate`, `variant`, `layout`  | Tier 2   | â¬œ     |
| radio-input          | RecipeProps     | Individual    | `orientation`                                                | Tier 1   | â¬œ     |
| range-calendar       | SlotRecipeProps | Full          | (all variants)                                               | Tier 1   | â¬œ     |
| rich-text-input      | SlotRecipeProps | Full          | (all variants)                                               | Tier 2   | â¬œ     |
| scoped-search-input  | SlotRecipeProps | Individual    | `size`                                                       | Tier 2   | â¬œ     |
| search-input         | SlotRecipeProps | Individual    | `size`, `variant`                                            | Tier 2   | â¬œ     |
| select               | SlotRecipeProps | Individual    | `size`, `variant`                                            | Tier 1   | â¬œ     |
| separator            | RecipeProps     | Full          | (all variants)                                               | Tier 1   | â¬œ     |
| split-button         | SlotRecipeProps | Full          | (all variants)                                               | Tier 2   | â¬œ     |
| switch               | SlotRecipeProps | Full          | (all variants)                                               | Tier 1   | â¬œ     |
| table                | SlotRecipeProps | Full          | (all variants)                                               | Tier 1   | â¬œ     |
| tabs                 | SlotRecipeProps | Individual    | `variant`, `orientation`, `placement`, `size`                | Tier 1   | â¬œ     |
| tag-group            | RecipeProps     | Individual    | `size`                                                       | Tier 2   | â¬œ     |
| text-input           | SlotRecipeProps | Individual    | `size`, `variant`                                            | Tier 2   | â¬œ     |
| time-input           | SlotRecipeProps | Individual    | `size`, `variant`                                            | Tier 2   | â¬œ     |
| toggle-button        | RecipeProps     | Individual    | `size`, `variant`                                            | Tier 2   | â¬œ     |
| toggle-button-group  | RecipeProps     | Full          | (all variants)                                               | Tier 2   | â¬œ     |
| toolbar              | RecipeProps     | Individual    | `size`, `orientation`, `variant`                             | Tier 2   | â¬œ     |
| tooltip              | RecipeProps     | Full          | (all variants)                                               | Tier 2   | â¬œ     |

**Legend:**

- â¬œ = Pending implementation
- ğŸ§ª = Used for POC validation (implementation was tested but not committed to
  main branch)
- **Recipe Type**: Whether component uses `RecipeProps` (single-element recipes)
  or `SlotRecipeProps` (multi-element recipes)
- **Usage Pattern**: Whether types file currently uses full recipe type or
  extracts individual props
- **Props Extracted**: Specific variant props referenced in types file (only for
  Individual pattern)
- **Priority**: Tier 1 = Chakra name conflicts (highest user impact), Tier 2 =
  Nimbus-specific names

### Coordination Tips

**To avoid merge conflicts:**

1. **Claim components** before starting work (update table with
   assignee/in-progress marker)
2. **Work in small batches** (3-5 components at a time)
3. **Commit frequently** (per component or small groups)
4. **Prioritize Tier 1** components first (highest user impact)

**Estimated effort per component:**

- **Individual props pattern**: ~5-10 minutes
- **Full recipe type pattern**: ~10-15 minutes (need to identify all variants)
- **Components with boolean variants**: Add ~2-3 minutes

**File locations:**

- Recipe files:
  `packages/nimbus/src/components/[component]/[component].recipe.ts` (or `.tsx`)
- Type files: `packages/nimbus/src/components/[component]/[component].types.ts`
  (or `.tsx`)

**Total estimated effort:**

- Tier 1 (21 components): ~3-5 hours
- Tier 2 (26 components): ~3-6 hours
- Testing and verification: ~2 hours
- **Total: ~8-13 hours of focused work**

Can be parallelized across multiple contributors with proper coordination.

### Migration Checklist Per Component

For each component:

- [ ] Extract variants to const with `as const`
- [ ] Export variant types using `keyof typeof`
- [ ] Update types file to import and use exported types
- [ ] Wrap in `ConditionalValue` where appropriate
- [ ] Build: `pnpm --filter @commercetools/nimbus build`
- [ ] Verify generated `.d.ts` files
- [ ] Rebuild docs: `pnpm --filter docs build:docs`
- [ ] Verify PropsTable JSON contains correct types
- [ ] Run tests: `pnpm test packages/nimbus/src/components/[component]/`

### Validation Checklist Per Component

After implementing the fix for each component, verify:

**1. Recipe file validation:**

```bash
# Check the recipe file exports types
grep "export type" packages/nimbus/src/components/[component]/[component].recipe.ts
```

Expected: See exported type aliases like `export type ComponentSize = ...`

**2. Types file validation:**

```bash
# Check types file imports from recipe
grep "from \"./[component].recipe\"" packages/nimbus/src/components/[component]/[component].types.ts
```

Expected: See imports like
`import type { ComponentSize } from "./component.recipe"`

**3. Build verification:**

```bash
# Build generates correct .d.ts
pnpm --filter @commercetools/nimbus build
cat packages/nimbus/dist/components/[component]/[component].types.d.ts | grep "ConditionalValue"
```

Expected: See concrete types like
`ConditionalValue<"left" | "right" | "top" | "bottom">`, NOT `SlotRecipeProps`
references

**4. PropsTable verification:**

```bash
# Rebuild docs and check extraction
pnpm --filter docs build:docs
cat apps/docs/src/data/types/[Component]Root.json
```

Expected: `"type": { "name": "ConditionalValue<\"value1\" | \"value2\">" }` (not
`"any"`)

**5. Type checking:**

```bash
# No TypeScript errors introduced
pnpm --filter @commercetools/nimbus typecheck
```

Expected: Clean build with no errors

### Testing Strategy

**Before merging:**

1. **Unit tests** - Should pass without changes (types only, no runtime changes)
2. **Storybook tests** - Should pass without changes (runtime unchanged)
3. **Type checking** - `pnpm typecheck` should pass across entire workspace
4. **Documentation build** - All PropsTable JSON files show concrete types (not
   `"any"`)
5. **Spot check generated `.d.ts`** - Verify concrete types in dist folder

**After merging:**

1. Monitor consumer applications for any type errors
2. Check documentation site for any rendering issues
3. Verify IDE autocomplete works correctly in consumer apps
4. Test responsive props still work:
   `placement={{ base: "bottom", md: "left" }}`

### Final Verification: All Components Updated

After completing all component updates, run this command to verify no components
were missed:

```bash
# Check for any remaining SlotRecipeProps or RecipeProps usage in types files
grep -r "SlotRecipeProps\|RecipeProps" packages/nimbus/src/components/*/*.types.ts* | \
  grep -v "import" | \
  grep -v "//" | \
  grep -v "node_modules"
```

**Expected output:** Empty (no matches)

If any matches appear, those components still need to be updated.

**Alternative - count remaining components:**

```bash
# Count files still using the old pattern
grep -rl "SlotRecipeProps<\|RecipeProps<" packages/nimbus/src/components/*/[^/]*.types.ts* 2>/dev/null | \
  wc -l
```

**Expected output:** `0`

---

## Appendix

### Existing Precedent in Codebase

This pattern already exists in `rich-text-input/constants/editor-constants.ts`:

```typescript
export const BLOCK_TAGS = {
  blockquote: "block-quote",
  p: "paragraph",
  pre: "code",
  // ...
} as const;

export type BlockTagKey = keyof typeof BLOCK_TAGS;
export type BlockTagValue = (typeof BLOCK_TAGS)[BlockTagKey];
```

### Alternatives Considered

#### Alternative 1: Module Augmentation

Ask consumers to augment Chakra's types in their applications:

```typescript
// Consumer would add this to their project
declare module "@chakra-ui/react" {
  interface DrawerVariant {
    placement?: "left" | "right" | "top" | "bottom";
  }
}
```

**Why this was rejected:**

- Requires manual consumer setup (bad DX)
- Easy to forget or misconfigure
- Types still not automatically synced with actual recipe
- Requires documentation and onboarding overhead

#### Alternative 2: Bundle Chakra UI with Nimbus

Bundle Chakra's runtime code and re-export its types from
`@commercetools/nimbus`:

```typescript
// Nimbus would re-export everything
export { SlotRecipeProps, ConditionalValue /* ... */ } from "@chakra-ui/react";
```

**Why this was rejected:**

- **Doesn't solve the problem**: `SlotRecipeProps<"drawer">` still performs a
  lookup against `ConfigSlotRecipes` interface, which would still resolve
  against Chakra's defaults
- Massive maintenance burden (hundreds of types to re-export)
- Tight version coupling to specific Chakra version
- Prevents consumers from using Chakra directly alongside Nimbus
- Significantly larger bundle size
- Breaking change requiring all consumers to update imports
- Type resolution happens at **compile time** in the consumer's TypeScript
  compiler, not at runtime, so bundling JavaScript doesn't affect type lookups

#### Alternative 3: Use ExtractVariantKeys Utility Type

Create a utility type to compute variant types:

```typescript
export type ExtractVariantKeys<T> = keyof T extends "true" | "false"
  ? boolean
  : keyof T;

export type DrawerPlacement = ExtractVariantKeys<
  typeof drawerVariants.placement
>;
```

**Why this was rejected:**

- `react-docgen-typescript` cannot fully resolve complex utility types across
  file boundaries
- Parser would show `"any"` instead of concrete union types in PropsTable
- Direct `keyof typeof` achieves the same result with better tooling support
- Adds unnecessary complexity for marginal DX benefit

#### Alternative 4: Chosen Solution - Direct keyof typeof

Export types directly from recipe using `keyof typeof`:

```typescript
export type DrawerPlacement = keyof typeof drawerVariants.placement;
```

**Why this was chosen:**

- âœ… Single source of truth (variants defined once)
- âœ… Types baked into `.d.ts` files at build time
- âœ… Works with `react-docgen-typescript` for documentation
- âœ… Simple and explicit
- âœ… POC validated on Drawer and Alert components
- âœ… No consumer setup required
- âœ… Preserves responsive prop support via `ConditionalValue`

### Why This Doesn't Affect Runtime

JavaScript doesn't have types at runtime. The component implementation reads the
actual variant values from the recipe object, not from TypeScript types. So even
with wrong types, the component works correctly.

### POC Reference Implementation

A POC implementation was completed on Drawer and Alert components to validate
this approach. While the POC changes were not committed to the main branch, the
patterns tested are documented below as implementation examples.

**File paths and patterns tested during POC:**

| File Type              | Drawer Example                              | Alert Example                             | Purpose                                |
| ---------------------- | ------------------------------------------- | ----------------------------------------- | -------------------------------------- |
| Recipe source          | `components/drawer/drawer.recipe.ts`        | `components/alert/alert.recipe.ts`        | Extract variants, export types         |
| Types source           | `components/drawer/drawer.types.ts`         | `components/alert/alert.types.ts`         | Import types, wrap in ConditionalValue |
| Generated recipe .d.ts | `dist/components/drawer/drawer.recipe.d.ts` | `dist/components/alert/alert.recipe.d.ts` | Verify exported types                  |
| Generated types .d.ts  | `dist/components/drawer/drawer.types.d.ts`  | `dist/components/alert/alert.types.d.ts`  | Verify concrete unions in props        |
| PropsTable JSON        | `apps/docs/src/data/types/DrawerRoot.json`  | `apps/docs/src/data/types/AlertRoot.json` | Verify documentation extraction        |

**Key patterns validated during POC:**

1. **Recipe file pattern**: Extract variants to `const` with `as const`, export
   types using `keyof typeof`
2. **Types file pattern**: Import from recipe, wrap in `ConditionalValue`
3. **Build output**: Generated `.d.ts` files contain concrete union types (e.g.,
   `"left" | "right" | "top" | "bottom"`)
4. **Documentation**: PropsTable correctly extracts types (e.g.,
   `ConditionalValue<"flat" | "outlined">`)

**POC tested these code changes:**

```typescript
// drawer.recipe.ts - Extract variants
const drawerVariants = {
  placement: { left: {}, right: {}, top: {}, bottom: {} },
  showBackdrop: { true: {}, false: {} },
} as const;

export const drawerSlotRecipe = defineSlotRecipe({
  variants: drawerVariants,
});

export type DrawerPlacement = keyof typeof drawerVariants.placement;
export type DrawerShowBackdrop = boolean;

// drawer.types.ts - Import and use
import type { ConditionalValue } from "@chakra-ui/react";
import type { DrawerPlacement } from "./drawer.recipe";

type DrawerRecipeProps = {
  placement?: ConditionalValue<DrawerPlacement>;
  showBackdrop?: boolean;
};
```

### Related Resources

- [TypeScript `keyof` operator](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
- [TypeScript `as const` assertions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)
- [Chakra UI Recipe System](https://www.chakra-ui.com/docs/theming/recipes)
- [react-docgen-typescript](https://github.com/styleguidist/react-docgen-typescript) -
  Documentation type extraction tool
