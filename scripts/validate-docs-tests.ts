#!/usr/bin/env tsx
/**
 * Validates test code blocks in engineering documentation (.dev.mdx files)
 *
 * This script:
 * 1. Finds all .dev.mdx files
 * 2. Extracts code blocks tagged with <!-- test:validate -->
 * 3. Combines them into a temporary test file
 * 4. Runs the tests with Vitest
 * 5. Reports results
 *
 * Usage:
 *   pnpm validate:docs-tests
 *   pnpm validate:docs-tests --file=text-input.dev.mdx
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from "fs";
import { glob } from "glob";
import { join, relative } from "path";
import { execSync } from "child_process";

interface ExtractedTest {
  sourceFile: string;
  sectionTitle: string;
  code: string;
  startLine: number;
  endLine: number;
}

/**
 * Extract test blocks from MDX content
 */
function extractTestBlocks(content: string, filePath: string): ExtractedTest[] {
  const tests: ExtractedTest[] = [];
  const lines = content.split("\n");

  let inTestBlock = false;
  let currentTest: string[] = [];
  let startLine = 0;
  let sectionTitle = "Unknown Section";

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Track section titles (###)
    if (line.startsWith("###")) {
      sectionTitle = line.replace(/^###\s*/, "").trim();
    }

    // Start of test block
    if (line.trim() === "<!-- test:validate -->") {
      inTestBlock = true;
      startLine = i + 1;
      currentTest = [];
      continue;
    }

    // End of test block
    if (line.trim() === "<!-- /test:validate -->") {
      if (inTestBlock && currentTest.length > 0) {
        // Remove the opening and closing code fence
        const codeLines = currentTest.slice(1, -1);
        const code = codeLines.join("\n");

        tests.push({
          sourceFile: filePath,
          sectionTitle,
          code,
          startLine,
          endLine: i,
        });
      }
      inTestBlock = false;
      currentTest = [];
      continue;
    }

    // Collect lines inside test block
    if (inTestBlock) {
      currentTest.push(line);
    }
  }

  return tests;
}

/**
 * Wrap render calls with NimbusProvider
 */
function wrapRenderCalls(code: string): string {
  // Replace render( with renderWithProvider(
  // But preserve { render } from imports
  return code
    .split("\n")
    .map((line) => {
      // Don't modify import lines
      if (line.trim().startsWith("import ")) {
        return line;
      }
      // Replace standalone render( calls (not in imports)
      return line.replace(/\brender\(/g, "renderWithProvider(");
    })
    .join("\n");
}

/**
 * Generate a complete test file from extracted blocks
 */
function generateTestFile(tests: ExtractedTest[]): string {
  const imports = new Set<string>();
  const testBodies: string[] = [];

  // Collect all unique imports and test bodies
  for (const test of tests) {
    const lines = test.code.split("\n");
    let inImports = true;
    const testLines: string[] = [];

    for (const line of lines) {
      const trimmed = line.trim();

      // Collect imports
      if (inImports && (trimmed.startsWith("import ") || trimmed === "")) {
        if (trimmed) {
          imports.add(trimmed);
        }
        continue;
      }

      // Once we hit non-import code, stop collecting imports
      if (trimmed && !trimmed.startsWith("import ")) {
        inImports = false;
      }

      // Collect test code
      if (!inImports) {
        testLines.push(line);
      }
    }

    // Wrap render calls with provider
    const wrappedCode = wrapRenderCalls(testLines.join("\n"));

    // Add source comment
    testBodies.push(`// Source: ${test.sourceFile} (${test.sectionTitle})`);
    testBodies.push(wrappedCode);
    testBodies.push(""); // Blank line between tests
  }

  // Add required imports for provider wrapper
  imports.add("import { NimbusProvider } from '@commercetools/nimbus';");

  // Combine into complete file with wrapper utility
  const importsArray = Array.from(imports).sort();
  const fileContent = [
    "// Auto-generated test file from .dev.mdx documentation",
    "// DO NOT EDIT - This file is generated by validate-docs-tests.ts",
    "",
    ...importsArray,
    "",
    "// Wrapper utility to provide NimbusProvider context",
    "function renderWithProvider(ui: React.ReactElement) {",
    "  const result = render(",
    "    <NimbusProvider>",
    "      {ui}",
    "    </NimbusProvider>",
    "  );",
    "  ",
    "  // Wrap rerender to also use provider",
    "  const originalRerender = result.rerender;",
    "  result.rerender = (rerenderUi: React.ReactElement) => {",
    "    return originalRerender(",
    "      <NimbusProvider>",
    "        {rerenderUi}",
    "      </NimbusProvider>",
    "    );",
    "  };",
    "  ",
    "  return result;",
    "}",
    "",
    ...testBodies,
  ].join("\n");

  return fileContent;
}

/**
 * Main execution
 */
async function main() {
  const args = process.argv.slice(2);
  const fileArg = args.find((arg) => arg.startsWith("--file="));
  const specificFile = fileArg?.split("=")[1];

  console.log("ðŸ” Validating engineering documentation tests...\n");

  // Find all .dev.mdx files or specific file
  const pattern = specificFile
    ? `packages/nimbus/src/**/${specificFile}`
    : "packages/nimbus/src/**/*.dev.mdx";

  const files = await glob(pattern, {
    cwd: process.cwd(),
    absolute: true,
  });

  if (files.length === 0) {
    console.error("âŒ No .dev.mdx files found");
    process.exit(1);
  }

  console.log(`Found ${files.length} file(s) to validate:\n`);

  // Extract all test blocks
  const allTests: ExtractedTest[] = [];
  for (const file of files) {
    const content = readFileSync(file, "utf-8");
    const tests = extractTestBlocks(content, relative(process.cwd(), file));

    if (tests.length > 0) {
      console.log(
        `  âœ“ ${relative(process.cwd(), file)} - ${tests.length} test block(s)`
      );
      allTests.push(...tests);
    } else {
      console.log(`  - ${relative(process.cwd(), file)} - No tagged tests`);
    }
  }

  console.log(`\nTotal: ${allTests.length} test block(s) extracted\n`);

  if (allTests.length === 0) {
    console.log("âœ… No tests to validate");
    return;
  }

  // Generate test file
  const testFileContent = generateTestFile(allTests);
  const tempDir = join(process.cwd(), "packages/nimbus/src/test");
  const tempTestFile = join(tempDir, "docs-validation.generated.spec.tsx");

  // Ensure temp directory exists
  if (!existsSync(tempDir)) {
    mkdirSync(tempDir, { recursive: true });
  }

  writeFileSync(tempTestFile, testFileContent, "utf-8");
  console.log(
    `ðŸ“ Generated test file: ${relative(process.cwd(), tempTestFile)}\n`
  );

  // Run tests with Vitest
  console.log("ðŸ§ª Running extracted tests...\n");
  try {
    execSync(
      `pnpm vitest run ${tempTestFile} --project=unit --reporter=verbose`,
      {
        stdio: "inherit",
        cwd: process.cwd(),
      }
    );
    console.log("\nâœ… All documentation tests passed!");
  } catch {
    console.error("\nâŒ Documentation tests failed!");
    console.error("\nSome test examples in your .dev.mdx files are broken.");
    console.error(
      "Please update the documentation to match current component behavior.\n"
    );
    process.exit(1);
  }
}

main().catch((error) => {
  console.error("Error:", error);
  process.exit(1);
});
