{
  "meta": {
    "id": "Components-ScopedSearchInput",
    "title": "ScopedSearchInput",
    "description": "Enables users to define where their search query is applied using a closely paired scope selector.",
    "order": 999,
    "repoPath": "packages/nimbus/src/components/scoped-search-input/scoped-search-input.mdx",
    "menu": [
      "Components",
      "Inputs",
      "ScopedSearchInput"
    ],
    "route": "components/inputs/scopedsearchinput",
    "tags": [
      "component",
      "input",
      "search",
      "select",
      "scoped"
    ],
    "toc": [
      {
        "value": "Overview",
        "href": "#overview",
        "depth": 2,
        "numbering": [
          1,
          1
        ],
        "parent": "root"
      },
      {
        "value": "Resources",
        "href": "#resources",
        "depth": 3,
        "numbering": [
          1,
          1,
          1
        ],
        "parent": "root"
      },
      {
        "value": "Variables",
        "href": "#variables",
        "depth": 2,
        "numbering": [
          1,
          2
        ],
        "parent": "root"
      },
      {
        "value": "Size",
        "href": "#size",
        "depth": 3,
        "numbering": [
          1,
          2,
          1
        ],
        "parent": "root"
      },
      {
        "value": "With form fields",
        "href": "#with-form-fields",
        "depth": 3,
        "numbering": [
          1,
          2,
          2
        ],
        "parent": "root"
      },
      {
        "value": "Guidelines",
        "href": "#guidelines",
        "depth": 2,
        "numbering": [
          1,
          3
        ],
        "parent": "root"
      },
      {
        "value": "Best practices",
        "href": "#best-practices",
        "depth": 3,
        "numbering": [
          1,
          3,
          1
        ],
        "parent": "root"
      },
      {
        "value": "Usage",
        "href": "#usage",
        "depth": 3,
        "numbering": [
          1,
          3,
          2
        ],
        "parent": "root"
      },
      {
        "value": "Scoped search do's and don'ts",
        "href": "#scoped-search-dos-and-donts",
        "depth": 3,
        "numbering": [
          1,
          3,
          3
        ],
        "parent": "root"
      },
      {
        "value": "Specs",
        "href": "#specs",
        "depth": 2,
        "numbering": [
          1,
          4
        ],
        "parent": "root"
      },
      {
        "value": "Accessibility",
        "href": "#accessibility",
        "depth": 2,
        "numbering": [
          1,
          5
        ],
        "parent": "root"
      },
      {
        "value": "Accessibility standards",
        "href": "#accessibility-standards",
        "depth": 3,
        "numbering": [
          1,
          5,
          1
        ],
        "parent": "root"
      }
    ],
    "figmaLink": "https://www.figma.com/design/AvtPX6g7OGGCRvNlatGOIY/NIMBUS-design-system?node-id=7190-35198&m=dev",
    "layout": "app-frame",
    "tabs": [
      {
        "key": "overview",
        "title": "Overview",
        "order": 0
      }
    ]
  },
  "mdx": "\n# Scoped search input\n\nEnables users to define where their search query is applied using a closely paired scope selector.\n\n## Overview\n\nThe scoped search input combines an input field with a functional scope selector (often a dropdown or button group), ensuring users can precisely target their query to a specific data segment, such as searching only 'Products' or only 'Customers', yielding more accurate and relevant results.\n\n### Resources\n\nDeep dive into implementation details and access the Nimbus design library.\n\n[Figma library](https://www.figma.com/design/AvtPX6g7OGGCRvNlatGOIY/NIMBUS-design-system?node-id=7190-35198&m=dev)\n[React Aria SearchField](https://react-spectrum.adobe.com/react-aria/SearchField.html)\n\n## Variables\n\nGet familiar with the features.\n\n### Size\n\nThere are two sizes, the default is medium (md) and supporting a more compact size (sm).\n\n```jsx-live\nconst App = () => {\n  const [valueSm, setValueSm] = useState({ text: '', option: 'all' });\n  const [valueMd, setValueMd] = useState({ text: '', option: 'all' });\n\n  const options = [\n    { label: 'All fields', value: 'all' },\n    { label: 'Name', value: 'name' },\n    { label: 'Email', value: 'email' },\n  ];\n\n  return (\n    <Stack direction=\"column\" gap=\"400\">\n      <ScopedSearchInput\n        size=\"md\"\n        value={valueMd}\n        onValueChange={setValueMd}\n        onSubmit={(val) => console.log('Search:', val)}\n        options={options}\n        searchPlaceholder=\"Search...\"\n      />\n      <ScopedSearchInput\n        size=\"sm\"\n        value={valueSm}\n        onValueChange={setValueSm}\n        onSubmit={(val) => console.log('Search:', val)}\n        options={options}\n        searchPlaceholder=\"Search...\"\n      />\n    </Stack>\n  );\n};\n```\n\n### With form fields\n\nWhen used in combination with form field patterns there is more support for any label, description, and error states needed.\n\n```jsx-live\nconst App = () => {\n  const [value, setValue] = useState({ text: '', option: 'all' });\n\n  const options = [\n    { label: 'All fields', value: 'all' },\n    { label: 'Name', value: 'name' },\n    { label: 'Email', value: 'email' },\n  ];\n\n  return (\n    <Box width=\"600px\">\n      <FormField.Root isRequired>\n        <FormField.Label>Label</FormField.Label>\n        <FormField.Input>\n          <ScopedSearchInput\n            value={value}\n            onValueChange={setValue}\n            onSubmit={(val) => console.log('Search:', val)}\n            options={options}\n            searchPlaceholder=\"Search...\"\n          />\n        </FormField.Input>\n        <FormField.Description>Descriptive text</FormField.Description>\n        <FormField.InfoBox>\n          Info box content\n        </FormField.InfoBox>\n      </FormField.Root>\n    </Box>\n  );\n};\n```\n\n## Guidelines\n\nScoped search guidelines establish how the component is used to manage multi-domain data, ensuring consistency and accessibility in defining the search context.\n\n### Best practices\n\n- **Set a smart default**: Choose the default scope that will be used by the vast majority of users. This saves the user an extra click most of the time.\n- **Instant application of scope**: When the user changes the scope (e.g., switches from \"All\" to \"Orders\"), that choice should be applied immediately without requiring the user to re-type the search query.\n- **Default scope clarity**: Always define a clear, logical default scope (e.g., \"All\" or the most common category) and clearly display it before the user interacts with the component.\n- **Persistent scope**: Ensure the scope selector remains visible and accessible next to the input field, clearly communicating the current search context at all times.\n- **Intuitive scope options**: Keep scope options concise and meaningful to the area that they are being placed in.\n- **Display results contextually**: When the search results page loads, reiterate the search parameters clearly: \"Showing 15 results for 'Jackets' within the 'Products' scope.\"\n- **Handle zero results gracefully**: If the user selects a very narrow scope and gets zero results, suggest alternative, broader scopes they can try without leaving the current page.\n- **Clear iconography**: If the scope selector uses icons, ensure they are universally understood and directly relate to the content they filter.\n\n### Usage\n\nThe scoped search component is used to enable users to perform precise searches by filtering the query to a specific, predefined domain or content area, leading to more relevant results.\n\n> [!TIP]\\\n> When to use\n\n- **Multi-domain data**: When the application contains large, distinct data types that users often need to query separately (e.g., searching for \"Jackets\" within Products vs. searching for \"Jackets\" within Customers).\n- **Precision is key**: When users require highly precise results and filtering the search domain reduces irrelevant noise (common in back-office solutions).\n- **Restricted permissions**: To restrict searches based on user permissions (e.g., a manager can search \"All Teams,\" but a team member can only search \"My Team\").\n\n> [!CAUTION]\\\n> When not to use\n\n- **Homogeneous data**: When all data belongs to a single, unified domain and scoping would offer minimal benefit (e.g., searching within a simple, short blog archive).\n- **Global search default**: If the vast majority of users always search \"everything,\" avoid forcing them to define a scope. A single global search with filters applied after the results load is often better.\n- **Limited screen space**: If screen real estate is minimal, avoid the dual-component structure of scoped search; consider a single input with filtering options revealed on search results page.\n\n### Scoped search do's and don'ts\n\n> [!TIP]\\\n> **Do**\n>\n> - Ensure the scope selector is accessible and its current state is conveyed via ARIA.\n> - Use concise labels for scope options, the short and descriptive is best.\n> - Do set a smart default for scopes.\n\n```jsx-live\nconst App = () => {\n  const [value, setValue] = useState({ text: '', option: 'all' });\n\n  const options = [\n    { label: 'All fields', value: 'all' },\n    { label: 'Products', value: 'products' },\n    { label: 'Customers', value: 'customers' },\n  ];\n\n  return (\n    <ScopedSearchInput\n      value={value}\n      onValueChange={setValue}\n      onSubmit={(val) => console.log('Search:', val)}\n      options={options}\n      searchPlaceholder=\"Search...\"\n    />\n  );\n};\n```\n\n> [!CAUTION]\\\n> **Don't**\n>\n> - Don't use confusing or abstract icons for scopes\n> - Don't reset the scope back to the default after every search or page refresh.\n> - Don't mix global and scoped results.\n> - Don't offer too many scopes.\n> - Don't force users to select a scope, determine a reasonable default for users.\n> - Don't use highly technical or internal terms for scope labels (e.g., \"Database Table A\" instead of \"Products\").\n\n```jsx-live\nconst App = () => {\n  const [value, setValue] = useState({ text: '', option: 'complex-query' });\n\n  const options = [\n    { label: 'Products that were published in the last month but no other time', value: 'complex-query' },\n    { label: 'Categories', value: 'categories' },\n    { label: 'Products not published this month', value: 'not-published' },\n    { label: 'Products published by Kevin that have been recalled in May', value: 'oh-kevin' },\n  ];\n\n  return (\n    <ScopedSearchInput\n      value={value}\n      onValueChange={setValue}\n      onSubmit={(val) => console.log('Search:', val)}\n      options={options}\n      searchPlaceholder=\"Search...\"\n    />\n  );\n};\n```\n\n## Specs\n\n<PropsTable id=\"ScopedSearchInput\" />\n\n## Accessibility\n\nAccessibility ensures that digital content and functionality are usable by everyone, including people with disabilities, by addressing visual, auditory, cognitive, and physical limitations.\n\n```jsx-live\nconst App = () => {\n  const [value, setValue] = useState({ text: '', option: 'all' });\n\n  const options = [\n    { label: 'All fields', value: 'all' },\n    { label: 'Name', value: 'name' },\n    { label: 'Email', value: 'email' },\n  ];\n\n  return (\n    <ScopedSearchInput\n      value={value}\n      onValueChange={setValue}\n      onSubmit={(val) => console.log('Search:', val)}\n      options={options}\n      searchPlaceholder=\"Search...\"\n    />\n  );\n};\n```\n\n### Accessibility standards\n\n- **Keyboard flow**: Ensure the Tab order moves logically between the scope selector and the text input field.\n- **ARIA roles**: The scope selector (if a dropdown) must use the appropriate ARIA roles (role=\"combobox\", aria-expanded).\n- **Labeling**: Provide clear programmatic labels for both the search input (`aria-label` or visible `<label>`) and the scope selector to explain their function to screen readers.\n- **State communication**: Use aria-live regions if search results appear dynamically, to announce the updated results count after a scope change or query submission.\n",
  "views": {
    "overview": {
      "mdx": "\n# Scoped search input\n\nEnables users to define where their search query is applied using a closely paired scope selector.\n\n## Overview\n\nThe scoped search input combines an input field with a functional scope selector (often a dropdown or button group), ensuring users can precisely target their query to a specific data segment, such as searching only 'Products' or only 'Customers', yielding more accurate and relevant results.\n\n### Resources\n\nDeep dive into implementation details and access the Nimbus design library.\n\n[Figma library](https://www.figma.com/design/AvtPX6g7OGGCRvNlatGOIY/NIMBUS-design-system?node-id=7190-35198&m=dev)\n[React Aria SearchField](https://react-spectrum.adobe.com/react-aria/SearchField.html)\n\n## Variables\n\nGet familiar with the features.\n\n### Size\n\nThere are two sizes, the default is medium (md) and supporting a more compact size (sm).\n\n```jsx-live\nconst App = () => {\n  const [valueSm, setValueSm] = useState({ text: '', option: 'all' });\n  const [valueMd, setValueMd] = useState({ text: '', option: 'all' });\n\n  const options = [\n    { label: 'All fields', value: 'all' },\n    { label: 'Name', value: 'name' },\n    { label: 'Email', value: 'email' },\n  ];\n\n  return (\n    <Stack direction=\"column\" gap=\"400\">\n      <ScopedSearchInput\n        size=\"md\"\n        value={valueMd}\n        onValueChange={setValueMd}\n        onSubmit={(val) => console.log('Search:', val)}\n        options={options}\n        searchPlaceholder=\"Search...\"\n      />\n      <ScopedSearchInput\n        size=\"sm\"\n        value={valueSm}\n        onValueChange={setValueSm}\n        onSubmit={(val) => console.log('Search:', val)}\n        options={options}\n        searchPlaceholder=\"Search...\"\n      />\n    </Stack>\n  );\n};\n```\n\n### With form fields\n\nWhen used in combination with form field patterns there is more support for any label, description, and error states needed.\n\n```jsx-live\nconst App = () => {\n  const [value, setValue] = useState({ text: '', option: 'all' });\n\n  const options = [\n    { label: 'All fields', value: 'all' },\n    { label: 'Name', value: 'name' },\n    { label: 'Email', value: 'email' },\n  ];\n\n  return (\n    <Box width=\"600px\">\n      <FormField.Root isRequired>\n        <FormField.Label>Label</FormField.Label>\n        <FormField.Input>\n          <ScopedSearchInput\n            value={value}\n            onValueChange={setValue}\n            onSubmit={(val) => console.log('Search:', val)}\n            options={options}\n            searchPlaceholder=\"Search...\"\n          />\n        </FormField.Input>\n        <FormField.Description>Descriptive text</FormField.Description>\n        <FormField.InfoBox>\n          Info box content\n        </FormField.InfoBox>\n      </FormField.Root>\n    </Box>\n  );\n};\n```\n\n## Guidelines\n\nScoped search guidelines establish how the component is used to manage multi-domain data, ensuring consistency and accessibility in defining the search context.\n\n### Best practices\n\n- **Set a smart default**: Choose the default scope that will be used by the vast majority of users. This saves the user an extra click most of the time.\n- **Instant application of scope**: When the user changes the scope (e.g., switches from \"All\" to \"Orders\"), that choice should be applied immediately without requiring the user to re-type the search query.\n- **Default scope clarity**: Always define a clear, logical default scope (e.g., \"All\" or the most common category) and clearly display it before the user interacts with the component.\n- **Persistent scope**: Ensure the scope selector remains visible and accessible next to the input field, clearly communicating the current search context at all times.\n- **Intuitive scope options**: Keep scope options concise and meaningful to the area that they are being placed in.\n- **Display results contextually**: When the search results page loads, reiterate the search parameters clearly: \"Showing 15 results for 'Jackets' within the 'Products' scope.\"\n- **Handle zero results gracefully**: If the user selects a very narrow scope and gets zero results, suggest alternative, broader scopes they can try without leaving the current page.\n- **Clear iconography**: If the scope selector uses icons, ensure they are universally understood and directly relate to the content they filter.\n\n### Usage\n\nThe scoped search component is used to enable users to perform precise searches by filtering the query to a specific, predefined domain or content area, leading to more relevant results.\n\n> [!TIP]\\\n> When to use\n\n- **Multi-domain data**: When the application contains large, distinct data types that users often need to query separately (e.g., searching for \"Jackets\" within Products vs. searching for \"Jackets\" within Customers).\n- **Precision is key**: When users require highly precise results and filtering the search domain reduces irrelevant noise (common in back-office solutions).\n- **Restricted permissions**: To restrict searches based on user permissions (e.g., a manager can search \"All Teams,\" but a team member can only search \"My Team\").\n\n> [!CAUTION]\\\n> When not to use\n\n- **Homogeneous data**: When all data belongs to a single, unified domain and scoping would offer minimal benefit (e.g., searching within a simple, short blog archive).\n- **Global search default**: If the vast majority of users always search \"everything,\" avoid forcing them to define a scope. A single global search with filters applied after the results load is often better.\n- **Limited screen space**: If screen real estate is minimal, avoid the dual-component structure of scoped search; consider a single input with filtering options revealed on search results page.\n\n### Scoped search do's and don'ts\n\n> [!TIP]\\\n> **Do**\n>\n> - Ensure the scope selector is accessible and its current state is conveyed via ARIA.\n> - Use concise labels for scope options, the short and descriptive is best.\n> - Do set a smart default for scopes.\n\n```jsx-live\nconst App = () => {\n  const [value, setValue] = useState({ text: '', option: 'all' });\n\n  const options = [\n    { label: 'All fields', value: 'all' },\n    { label: 'Products', value: 'products' },\n    { label: 'Customers', value: 'customers' },\n  ];\n\n  return (\n    <ScopedSearchInput\n      value={value}\n      onValueChange={setValue}\n      onSubmit={(val) => console.log('Search:', val)}\n      options={options}\n      searchPlaceholder=\"Search...\"\n    />\n  );\n};\n```\n\n> [!CAUTION]\\\n> **Don't**\n>\n> - Don't use confusing or abstract icons for scopes\n> - Don't reset the scope back to the default after every search or page refresh.\n> - Don't mix global and scoped results.\n> - Don't offer too many scopes.\n> - Don't force users to select a scope, determine a reasonable default for users.\n> - Don't use highly technical or internal terms for scope labels (e.g., \"Database Table A\" instead of \"Products\").\n\n```jsx-live\nconst App = () => {\n  const [value, setValue] = useState({ text: '', option: 'complex-query' });\n\n  const options = [\n    { label: 'Products that were published in the last month but no other time', value: 'complex-query' },\n    { label: 'Categories', value: 'categories' },\n    { label: 'Products not published this month', value: 'not-published' },\n    { label: 'Products published by Kevin that have been recalled in May', value: 'oh-kevin' },\n  ];\n\n  return (\n    <ScopedSearchInput\n      value={value}\n      onValueChange={setValue}\n      onSubmit={(val) => console.log('Search:', val)}\n      options={options}\n      searchPlaceholder=\"Search...\"\n    />\n  );\n};\n```\n\n## Specs\n\n<PropsTable id=\"ScopedSearchInput\" />\n\n## Accessibility\n\nAccessibility ensures that digital content and functionality are usable by everyone, including people with disabilities, by addressing visual, auditory, cognitive, and physical limitations.\n\n```jsx-live\nconst App = () => {\n  const [value, setValue] = useState({ text: '', option: 'all' });\n\n  const options = [\n    { label: 'All fields', value: 'all' },\n    { label: 'Name', value: 'name' },\n    { label: 'Email', value: 'email' },\n  ];\n\n  return (\n    <ScopedSearchInput\n      value={value}\n      onValueChange={setValue}\n      onSubmit={(val) => console.log('Search:', val)}\n      options={options}\n      searchPlaceholder=\"Search...\"\n    />\n  );\n};\n```\n\n### Accessibility standards\n\n- **Keyboard flow**: Ensure the Tab order moves logically between the scope selector and the text input field.\n- **ARIA roles**: The scope selector (if a dropdown) must use the appropriate ARIA roles (role=\"combobox\", aria-expanded).\n- **Labeling**: Provide clear programmatic labels for both the search input (`aria-label` or visible `<label>`) and the scope selector to explain their function to screen readers.\n- **State communication**: Use aria-live regions if search results appear dynamically, to announce the updated results count after a scope change or query submission.\n",
      "toc": [
        {
          "value": "Overview",
          "href": "#overview",
          "depth": 2,
          "numbering": [
            1,
            1
          ],
          "parent": "root"
        },
        {
          "value": "Resources",
          "href": "#resources",
          "depth": 3,
          "numbering": [
            1,
            1,
            1
          ],
          "parent": "root"
        },
        {
          "value": "Variables",
          "href": "#variables",
          "depth": 2,
          "numbering": [
            1,
            2
          ],
          "parent": "root"
        },
        {
          "value": "Size",
          "href": "#size",
          "depth": 3,
          "numbering": [
            1,
            2,
            1
          ],
          "parent": "root"
        },
        {
          "value": "With form fields",
          "href": "#with-form-fields",
          "depth": 3,
          "numbering": [
            1,
            2,
            2
          ],
          "parent": "root"
        },
        {
          "value": "Guidelines",
          "href": "#guidelines",
          "depth": 2,
          "numbering": [
            1,
            3
          ],
          "parent": "root"
        },
        {
          "value": "Best practices",
          "href": "#best-practices",
          "depth": 3,
          "numbering": [
            1,
            3,
            1
          ],
          "parent": "root"
        },
        {
          "value": "Usage",
          "href": "#usage",
          "depth": 3,
          "numbering": [
            1,
            3,
            2
          ],
          "parent": "root"
        },
        {
          "value": "Scoped search do's and don'ts",
          "href": "#scoped-search-dos-and-donts",
          "depth": 3,
          "numbering": [
            1,
            3,
            3
          ],
          "parent": "root"
        },
        {
          "value": "Specs",
          "href": "#specs",
          "depth": 2,
          "numbering": [
            1,
            4
          ],
          "parent": "root"
        },
        {
          "value": "Accessibility",
          "href": "#accessibility",
          "depth": 2,
          "numbering": [
            1,
            5
          ],
          "parent": "root"
        },
        {
          "value": "Accessibility standards",
          "href": "#accessibility-standards",
          "depth": 3,
          "numbering": [
            1,
            5,
            1
          ],
          "parent": "root"
        }
      ]
    }
  }
}